import {
  BrowserRouter,
  useSearchParams
} from "./chunk-3LMYZUTU.js";
import {
  Action,
  MemoryRouter,
  Route,
  Routes,
  useLocation,
  useNavigate,
  useNavigationType,
  useParams,
  useRouteError
} from "./chunk-RCYWHHGX.js";
import {
  require_react_dom
} from "./chunk-PJEEZAML.js";
import {
  require_prop_types
} from "./chunk-74XLRBUK.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __commonJS,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment2(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo2(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment2;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo2;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r2, e) {
  if (null == r2) return {};
  var t = {};
  for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r2[n];
  }
  return t;
}

// node_modules/zmp-ui/esm/components/app/index.js
var import_react2 = __toESM(require_react());

// node_modules/zmp-ui/esm/hooks/useTheme/index.js
var import_react = __toESM(require_react());
var ThemeSwitcherContext = import_react.default.createContext(void 0);
function useTheme() {
  var context = import_react.default.useContext(ThemeSwitcherContext);
  if (!context) {
    throw new Error("To use `useTheme`, component must be contained with App components");
  }
  return [context.themeMode, context.setThemeMode];
}

// node_modules/zmp-ui/esm/components/app/index.js
var _excluded = ["theme"];
var App = function App2(props) {
  var _props$theme = props.theme, theme = _props$theme === void 0 ? "light" : _props$theme, rest = _objectWithoutPropertiesLoose(props, _excluded);
  var _useState = (0, import_react2.useState)(theme || "light"), currentTheme = _useState[0], setCurrentTheme = _useState[1];
  (0, import_react2.useEffect)(function() {
    if (currentTheme === "dark" || currentTheme === "light") {
      document.body.setAttribute("zaui-theme", currentTheme);
    }
  }, [currentTheme]);
  var switcher = (0, import_react2.useCallback)(function(_ref) {
    var mode = _ref.mode;
    if (mode === currentTheme) return;
    if (mode === "dark" || mode === "light") {
      setCurrentTheme(mode);
    }
  }, [currentTheme]);
  var value = import_react2.default.useMemo(function() {
    return {
      setThemeMode: switcher,
      themeMode: currentTheme
    };
  }, [switcher, currentTheme]);
  return import_react2.default.createElement(ThemeSwitcherContext.Provider, _extends({
    value
  }, rest));
};
var app_default = App;

// node_modules/zmp-ui/esm/components/button/index.js
var import_react4 = __toESM(require_react());

// node_modules/clsx/dist/clsx.m.js
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  else for (t in e) e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; ) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default = clsx;

// node_modules/zmp-ui/esm/constants/config.js
var CLASS_PREFIX = "zaui";

// node_modules/zmp-ui/esm/utils/class.js
var getPrefixCls = function getPrefixCls2(suffixCls, customizePrefixCls) {
  if (customizePrefixCls) return customizePrefixCls;
  return suffixCls ? CLASS_PREFIX + "-" + suffixCls : CLASS_PREFIX;
};

// node_modules/zmp-ui/esm/components/button/loading-icon.js
var import_react3 = __toESM(require_react());
var LoadingIcon = function LoadingIcon2() {
  return import_react3.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 24 24",
    fill: "none"
  }, import_react3.default.createElement("path", {
    d: "M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM2.49 12C2.49 17.2522 6.74777 21.51 12 21.51C17.2522 21.51 21.51 17.2522 21.51 12C21.51 6.74777 17.2522 2.49 12 2.49C6.74777 2.49 2.49 6.74777 2.49 12Z",
    fill: "black",
    fillOpacity: "0.1"
  }), import_react3.default.createElement("path", {
    d: "M15.6784 1.89361C15.9136 1.24748 16.6317 0.908557 17.25 1.20938C18.2892 1.71497 19.2519 2.369 20.1071 3.15267C21.2689 4.21731 22.2097 5.50037 22.8757 6.92858C23.5417 8.3568 23.9198 9.90221 23.9886 11.4766C24.0392 12.6355 23.9214 13.7933 23.6407 14.9143C23.4737 15.5814 22.7525 15.9136 22.1064 15.6784C21.4603 15.4433 21.1358 14.7295 21.2846 14.0582C21.4641 13.2486 21.5373 12.4172 21.5009 11.5852C21.4465 10.3375 21.1468 9.11276 20.619 7.9809C20.0912 6.84904 19.3456 5.83222 18.4249 4.98849C17.8108 4.42584 17.1269 3.94752 16.3914 3.5646C15.7815 3.24709 15.4433 2.53973 15.6784 1.89361Z",
    fill: "currentColor"
  }));
};
var loading_icon_default = LoadingIcon;

// node_modules/zmp-ui/esm/components/button/index.js
var _excluded2 = ["children", "prefixIcon", "suffixIcon", "icon", "fullWidth", "loading", "disabled", "type", "size", "className", "variant", "htmlType", "onClick"];
var Button = import_react4.default.forwardRef(function(props, ref) {
  var _classNames;
  var children2 = props.children, prefixIcon = props.prefixIcon, suffixIcon = props.suffixIcon, icon2 = props.icon, fullWidth = props.fullWidth, loading = props.loading, disabled = props.disabled, type = props.type, size = props.size, className = props.className, _props$variant = props.variant, variant = _props$variant === void 0 ? "primary" : _props$variant, _props$htmlType = props.htmlType, htmlType = _props$htmlType === void 0 ? "button" : _props$htmlType, onClick = props.onClick, rest = _objectWithoutPropertiesLoose(props, _excluded2);
  var prefixCls = getPrefixCls("btn");
  var buttonRef = ref || import_react4.default.createRef();
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-highlight"] = type === "highlight", _classNames[prefixCls + "-danger"] = type === "danger", _classNames[prefixCls + "-neutral"] = type === "neutral", _classNames[prefixCls + "-primary"] = variant === "primary", _classNames[prefixCls + "-secondary"] = variant === "secondary", _classNames[prefixCls + "-tertiary"] = variant === "tertiary", _classNames[prefixCls + "-disabled"] = disabled, _classNames[prefixCls + "-loading"] = loading && !disabled, _classNames[prefixCls + "-icon-only"] = icon2, _classNames[prefixCls + "-suffix-icon"] = suffixIcon, _classNames[prefixCls + "-prefix-icon"] = prefixIcon, _classNames[prefixCls + "-small"] = size === "small", _classNames[prefixCls + "-medium"] = size === "medium", _classNames[prefixCls + "-large"] = size === "large", _classNames[prefixCls + "-full-width"] = fullWidth, _classNames[prefixCls + "-prefix-icon"] = prefixIcon, _classNames[prefixCls + "-suffix-icon"] = suffixIcon, _classNames[prefixCls + "-icon-only"] = icon2, _classNames["" + className] = className, _classNames));
  var onClickHandler = function onClickHandler2(event) {
    if (onClick && typeof onClick === "function") {
      onClick(event);
    }
  };
  var buttonChildren = function buttonChildren2() {
    if (icon2 && !loading) {
      return import_react4.default.createElement("div", {
        className: prefixCls + "-container"
      }, import_react4.default.createElement("span", {
        className: prefixCls + "-icon"
      }, icon2));
    }
    return import_react4.default.createElement("div", {
      className: prefixCls + "-container"
    }, loading && !disabled && import_react4.default.createElement("span", {
      className: prefixCls + "-loading-container"
    }, import_react4.default.createElement("span", {
      role: "img",
      className: prefixCls + "-loading-icon"
    }, import_react4.default.createElement(loading_icon_default, null))), prefixIcon && import_react4.default.createElement("span", {
      className: prefixCls + "-icon"
    }, prefixIcon), import_react4.default.createElement("span", null, children2), suffixIcon && import_react4.default.createElement("span", {
      className: prefixCls + "-icon"
    }, suffixIcon));
  };
  return import_react4.default.createElement("button", _extends({
    onClick: onClickHandler,
    className: cls,
    ref: buttonRef,
    type: htmlType,
    disabled
  }, rest), buttonChildren());
});
var button_default = Button;

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r2) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r2 || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e, r2, t) {
  return (r2 = toPropertyKey(r2)) in e ? Object.defineProperty(e, r2, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r2] = t, e;
}

// node_modules/zmp-ui/esm/components/icon/index.js
var import_react5 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/icon/icons.js
var icon = {
  zi_add_member: "zi_add_member",
  zi_add_member_solid: "zi_add_member_solid",
  zi_add_user: "zi_add_user",
  zi_add_user_solid: "zi_add_user_solid",
  zi_admin: "zi_admin",
  zi_create_group: "zi_create_group",
  zi_create_group_solid: "zi_create_group_solid",
  zi_group: "zi_group",
  zi_group_solid: "zi_group_solid",
  zi_members: "zi_members",
  zi_members_solid: "zi_members_solid",
  zi_stranger: "zi_stranger",
  zi_stranger_solid: "zi_stranger_solid",
  zi_switch_users: "zi_switch_users",
  zi_switch_users_solid: "zi_switch_users_solid",
  zi_user: "zi_user",
  zi_user_check: "zi_user_check",
  zi_user_circle: "zi_user_circle",
  zi_user_circle_solid: "zi_user_circle_solid",
  zi_user_search: "zi_user_search",
  zi_user_search_solid: "zi_user_search_solid",
  zi_user_settings: "zi_user_settings",
  zi_user_settings_solid: "zi_user_settings_solid",
  zi_user_solid: "zi_user_solid",
  zi_add_photo: "zi_add_photo",
  zi_camera: "zi_camera",
  zi_gallery: "zi_gallery",
  zi_link: "zi_link",
  zi_livestream: "zi_livestream",
  zi_pause: "zi_pause",
  zi_pause_solid: "zi_pause_solid",
  zi_photo: "zi_photo",
  zi_photo_search: "zi_photo_search",
  zi_photo_solid: "zi_photo_solid",
  zi_play: "zi_play",
  zi_play_solid: "zi_play_solid",
  zi_add_story: "zi_add_story",
  zi_ban: "zi_ban",
  zi_bullet_solid: "zi_bullet_solid",
  zi_check: "zi_check",
  zi_check_circle: "zi_check_circle",
  zi_check_circle_solid: "zi_check_circle_solid",
  zi_close: "zi_close",
  zi_close_circle: "zi_close_circle",
  zi_close_circle_solid: "zi_close_circle_solid",
  zi_copy: "zi_copy",
  zi_delete: "zi_delete",
  zi_drag_indicator_solid: "zi_drag_indicator_solid",
  zi_filter: "zi_filter",
  zi_filter_solid: "zi_filter_solid",
  zi_home: "zi_home",
  zi_leave: "zi_leave",
  zi_leave_solid: "zi_leave_solid",
  zi_list_1: "zi_list_1",
  zi_list_2: "zi_list_2",
  zi_minus_circle: "zi_minus_circle",
  zi_minus_circle_solid: "zi_minus_circle_solid",
  zi_more_diamond_solid: "zi_more_diamond_solid",
  zi_more_grid: "zi_more_grid",
  zi_more_grid_solid: "zi_more_grid_solid",
  zi_more_horiz: "zi_more_horiz",
  zi_more_horiz_solid: "zi_more_horiz_solid",
  zi_more_vert: "zi_more_vert",
  zi_plus: "zi_plus",
  zi_plus_circle: "zi_plus_circle",
  zi_plus_circle_solid: "zi_plus_circle_solid",
  zi_radio_checked: "zi_radio_checked",
  zi_radio_unchecked: "zi_radio_unchecked",
  zi_save_to_collection: "zi_save_to_collection",
  zi_search: "zi_search",
  zi_setting: "zi_setting",
  zi_tune: "zi_tune",
  zi_arrow_down: "zi_arrow_down",
  zi_arrow_left: "zi_arrow_left",
  zi_arrow_right: "zi_arrow_right",
  zi_arrow_up: "zi_arrow_up",
  zi_auto: "zi_auto",
  zi_auto_solid: "zi_auto_solid",
  zi_backup_arrow_solid: "zi_backup_arrow_solid",
  zi_chevron_double_down: "zi_chevron_double_down",
  zi_chevron_double_up: "zi_chevron_double_up",
  zi_chevron_down: "zi_chevron_down",
  zi_chevron_left: "zi_chevron_left",
  zi_chevron_left_header: "zi_chevron_left_header",
  zi_chevron_right: "zi_chevron_right",
  zi_chevron_up: "zi_chevron_up",
  zi_download: "zi_download",
  zi_download_solid: "zi_download_solid",
  zi_reorder_solid: "zi_reorder_solid",
  zi_reply: "zi_reply",
  zi_reply_solid: "zi_reply_solid",
  zi_retry: "zi_retry",
  zi_retry_solid: "zi_retry_solid",
  zi_share: "zi_share",
  zi_share_external_1: "zi_share_external_1",
  zi_share_external_2: "zi_share_external_2",
  zi_share_solid: "zi_share_solid",
  zi_unfold_less: "zi_unfold_less",
  zi_unfold_more: "zi_unfold_more",
  zi_upload: "zi_upload",
  zi_at: "zi_at",
  zi_bubble_multiselect: "zi_bubble_multiselect",
  zi_call: "zi_call",
  zi_call_solid: "zi_call_solid",
  zi_chat: "zi_chat",
  zi_chat_solid: "zi_chat_solid",
  zi_grid_solid: "zi_grid_solid",
  zi_location: "zi_location",
  zi_location_solid: "zi_location_solid",
  zi_mic: "zi_mic",
  zi_quote: "zi_quote",
  zi_quote_solid: "zi_quote_solid",
  zi_recall: "zi_recall",
  zi_send_solid: "zi_send_solid",
  zi_user_window_solid: "zi_user_window_solid",
  zi_video: "zi_video",
  zi_video_group: "zi_video_group",
  zi_video_solid: "zi_video_solid",
  zi_wifi: "zi_wifi",
  zi_wifi_off: "zi_wifi_off",
  zi_backup_solid: "zi_backup_solid",
  zi_backup_success_solid: "zi_backup_success_solid",
  zi_backup_warning_solid: "zi_backup_warning_solid",
  zi_bookmark: "zi_bookmark",
  zi_bookmark_delete: "zi_bookmark_delete",
  zi_favorite_list: "zi_favorite_list",
  zi_heart: "zi_heart",
  zi_heart_solid: "zi_heart_solid",
  zi_pin: "zi_pin",
  zi_pin_solid: "zi_pin_solid",
  zi_star: "zi_star",
  zi_star_solid: "zi_star_solid",
  zi_unpin: "zi_unpin",
  zi_calendar: "zi_calendar",
  zi_calendar_solid: "zi_calendar_solid",
  zi_clock_1: "zi_clock_1",
  zi_clock_1_solid: "zi_clock_1_solid",
  zi_clock_2: "zi_clock_2",
  zi_clock_2_solid: "zi_clock_2_solid",
  zi_memory: "zi_memory",
  zi_reminder: "zi_reminder",
  zi_reminder_delete: "zi_reminder_delete",
  zi_reminder_solid: "zi_reminder_solid",
  zi_edit: "zi_edit",
  zi_edit_delete: "zi_edit_delete",
  zi_edit_delete_solid: "zi_edit_delete_solid",
  zi_edit_solid: "zi_edit_solid",
  zi_edit_text: "zi_edit_text",
  zi_edit_text_solid: "zi_edit_text_solid",
  zi_post: "zi_post",
  zi_exclamation: "zi_exclamation",
  zi_help_circle: "zi_help_circle",
  zi_info_circle: "zi_info_circle",
  zi_info_circle_solid: "zi_info_circle_solid",
  zi_warning: "zi_warning",
  zi_warning_circle: "zi_warning_circle",
  zi_warning_circle_solid: "zi_warning_circle_solid",
  zi_warning_solid: "zi_warning_solid",
  zi_file: "zi_file",
  zi_inbox: "zi_inbox",
  zi_note: "zi_note",
  zi_note_delete: "zi_note_delete",
  zi_pcline: "zi_pcline",
  zi_poll: "zi_poll",
  zi_poll_solid: "zi_poll_solid",
  zi_qrline: "zi_qrline",
  zi_truyen_file: "zi_truyen_file",
  zi_wallpaper: "zi_wallpaper",
  zi_hide: "zi_hide",
  zi_key_solid: "zi_key_solid",
  zi_lock: "zi_lock",
  zi_lock_open_solid: "zi_lock_open_solid",
  zi_lock_solid: "zi_lock_solid",
  zi_notif: "zi_notif",
  zi_notif_off: "zi_notif_off",
  zi_notif_off_solid: "zi_notif_off_solid",
  zi_notif_ring: "zi_notif_ring",
  zi_shield_solid: "zi_shield_solid",
  zi_unhide: "zi_unhide",
  zi_unlock: "zi_unlock",
  zi_unlock_solid: "zi_unlock_solid"
};
var icons_default = icon;

// node_modules/zmp-ui/esm/components/icon/index.js
var _excluded3 = ["children", "size", "icon", "style", "className"];
function ownKeys(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Icon = import_react5.default.forwardRef(function(props, ref) {
  var _classNames;
  var children2 = props.children, size = props.size, icon2 = props.icon, style = props.style, className = props.className, rest = _objectWithoutPropertiesLoose(props, _excluded3);
  var prefixCls = getPrefixCls("icon");
  var getIcon3 = function getIcon4(iconStr) {
    if (typeof iconStr === "string") {
      var iconKey = iconStr.replace(/-/g, "_");
      var _iconContent = icons_default[iconKey];
      return _iconContent || null;
    }
    return null;
  };
  var iconStyle = {};
  if (style) {
    iconStyle = _objectSpread({}, style);
  }
  var classes = clsx_m_default(prefixCls, (_classNames = {}, _classNames["" + className] = className, _classNames));
  if (typeof size === "number") {
    iconStyle.fontSize = size + "px";
  }
  var iconContent = getIcon3(icon2 || children2);
  return import_react5.default.createElement("i", _extends({
    ref,
    className: classes,
    style: iconStyle
  }, rest), iconContent);
});
var icon_default = Icon;

// node_modules/zmp-ui/esm/components/list/item.js
var import_react6 = __toESM(require_react());
var _excluded4 = ["title", "children", "subTitle", "prefix", "suffix", "brackets", "className", "onClick"];
var ListItem = import_react6.default.forwardRef(function(props, ref) {
  var _classNames;
  var title = props.title, children2 = props.children, subTitle = props.subTitle, prefix2 = props.prefix, suffix = props.suffix, brackets = props.brackets, className = props.className, onClick = props.onClick, rest = _objectWithoutPropertiesLoose(props, _excluded4);
  var prefixCls = getPrefixCls("list-item");
  var classes = clsx_m_default(prefixCls, (_classNames = {}, _classNames["" + className] = className, _classNames));
  var handleClick = function handleClick2(event) {
    if (onClick) {
      onClick(event);
    }
  };
  return import_react6.default.createElement("li", _extends({}, rest, {
    role: "presentation",
    onClick: handleClick,
    ref,
    className: classes
  }), prefix2 && import_react6.default.createElement("div", {
    className: prefixCls + "-prefix"
  }, prefix2), import_react6.default.createElement("div", {
    className: prefixCls + "-right"
  }, import_react6.default.createElement("div", {
    className: prefixCls + "-content"
  }, title && import_react6.default.createElement(import_react6.default.Fragment, null, import_react6.default.createElement("div", {
    className: prefixCls + "-title-container"
  }, title && import_react6.default.createElement("span", {
    className: prefixCls + "-title"
  }, title), brackets && import_react6.default.createElement("span", {
    className: prefixCls + "-brackets"
  }, "(", brackets, ")")), subTitle && import_react6.default.createElement("div", {
    className: prefixCls + "-subtitle"
  }, subTitle)), children2), suffix && import_react6.default.createElement("div", {
    className: prefixCls + "-suffix"
  }, " ", suffix)));
});
var item_default = ListItem;

// node_modules/zmp-ui/esm/components/list/list.js
var import_react7 = __toESM(require_react());
var _excluded5 = ["className", "dataSource", "renderItem", "children", "divider", "loading", "noSpacing"];
function List(props, ref) {
  var _classNames;
  var className = props.className, dataSource = props.dataSource, renderItem = props.renderItem, children2 = props.children, _props$divider = props.divider, divider = _props$divider === void 0 ? true : _props$divider, loading = props.loading, noSpacing = props.noSpacing, rest = _objectWithoutPropertiesLoose(props, _excluded5);
  var prefixCls = getPrefixCls("list");
  var classes = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-loading"] = loading, _classNames[prefixCls + "-no-divider"] = !divider, _classNames[prefixCls + "-no-spacing"] = !!noSpacing, _classNames["" + className] = className, _classNames));
  return import_react7.default.createElement("ul", _extends({
    ref,
    className: classes
  }, rest), dataSource ? dataSource.map(function(item, index2) {
    if (renderItem) {
      return renderItem(item, index2, loading);
    }
    return import_react7.default.createElement(item_default, {
      title: item.title,
      prefix: item.prefix,
      suffix: item.suffix,
      subTitle: item.subTitle,
      brackets: item.brackets,
      style: item.style,
      className: item.className,
      id: item.id
    });
  }) : children2);
}
var LinkWithRef = import_react7.default.forwardRef(List);
var list_default = LinkWithRef;

// node_modules/zmp-ui/esm/components/list/index.js
var List2 = list_default;
List2.displayName = "List";
List2.Item = item_default;
var list_default2 = List2;

// node_modules/zmp-ui/esm/components/input/Input.js
var import_react16 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/input/utils/commonUtils.js
function hasAddon(props) {
  return !!(props.addonBefore || props.addonAfter);
}
function fixControlledValue(value) {
  if (typeof value === "undefined" || value === null) {
    return "";
  }
  return String(value);
}
function resolveOnChange(target, e, onChange, targetValue) {
  if (!onChange) {
    return;
  }
  var event = e;
  if (e.type === "click") {
    var currentTarget = target.cloneNode(true);
    event = Object.create(e, {
      target: {
        value: currentTarget
      },
      currentTarget: {
        value: currentTarget
      }
    });
    currentTarget.value = "";
    onChange(event);
    return;
  }
  if (targetValue !== void 0) {
    event = Object.create(e, {
      target: {
        value: target
      },
      currentTarget: {
        value: target
      }
    });
    target.value = targetValue;
    onChange(event);
    return;
  }
  onChange(event);
}
function triggerFocus(element, option) {
  if (!element) return;
  element.focus(option);
  var _ref = option || {}, cursor = _ref.cursor;
  if (cursor) {
    var len = element.value.length;
    switch (cursor) {
      case "start":
        element.setSelectionRange(0, 0);
        break;
      case "end":
        element.setSelectionRange(len, len);
        break;
      default:
        element.setSelectionRange(0, len);
    }
  }
}

// node_modules/zmp-ui/esm/utils/omit.js
function ownKeys2(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys2(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
function omit(obj, fields) {
  var clone = _objectSpread2({}, obj);
  if (Array.isArray(fields)) {
    fields.forEach(function(key) {
      delete clone[key];
    });
  }
  return clone;
}

// node_modules/zmp-ui/esm/hooks/useMergedState.js
var import_react9 = __toESM(require_react());

// node_modules/zmp-ui/esm/hooks/useEvent.js
var import_react8 = __toESM(require_react());
function useEvent(callback) {
  var fnRef = import_react8.default.useRef();
  fnRef.current = callback;
  return import_react8.default.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return fnRef.current == null ? void 0 : fnRef.current.apply(fnRef, args);
  }, []);
}

// node_modules/zmp-ui/esm/hooks/useLayoutUpdateEffect.js
var React9 = __toESM(require_react());
var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
  var firstMountRef = React9.useRef(true);
  React9.useLayoutEffect(function() {
    if (!firstMountRef.current) {
      return callback();
    }
    return void 0;
  }, deps);
  React9.useLayoutEffect(function() {
    firstMountRef.current = false;
    return function() {
      firstMountRef.current = true;
    };
  }, []);
};

// node_modules/zmp-ui/esm/hooks/useMergedState.js
var Source = function(Source2) {
  Source2[Source2["INNER"] = 0] = "INNER";
  Source2[Source2["PROP"] = 1] = "PROP";
  return Source2;
}(Source || {});
function hasValue(value) {
  return value !== void 0;
}
function useMergedState(defaultStateValue, option) {
  var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
  var _useState = (0, import_react9.useState)(function() {
    var finalValue;
    var source;
    if (hasValue(value)) {
      finalValue = value;
      source = Source.PROP;
    } else if (hasValue(defaultValue)) {
      finalValue = typeof defaultValue === "function" ? defaultValue() : defaultValue;
      source = Source.PROP;
    } else {
      finalValue = typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      source = Source.INNER;
    }
    return [finalValue, source, finalValue];
  }), mergedValue = _useState[0], setMergedValue = _useState[1];
  var chosenValue = hasValue(value) ? value : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue;
  useLayoutUpdateEffect(function() {
    if (hasValue(value)) {
      setMergedValue(function(_ref2) {
        var prevValue = _ref2[0];
        return [value, Source.PROP, prevValue];
      });
    }
  }, [value]);
  var changeEventPrevRef = import_react9.default.useRef();
  var triggerChange = useEvent(function(updater) {
    setMergedValue(function(prev) {
      var prevValue = prev[0], prevSource = prev[1], prevPrevValue = prev[2];
      var nextValue = typeof updater === "function" ? updater(prevValue) : updater;
      if (nextValue === prevValue) {
        return prev;
      }
      var overridePrevValue = prevSource === Source.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source.INNER, overridePrevValue];
    });
  });
  var onChangeFn = useEvent(onChange);
  (0, import_react9.useLayoutEffect)(function() {
    var current = mergedValue[0], source = mergedValue[1], prev = mergedValue[2];
    if (current !== prev && source === Source.INNER) {
      onChangeFn(current, prev);
      changeEventPrevRef.current = prev;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}

// node_modules/zmp-ui/esm/utils/type.js
var tuple = function tuple2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args;
};

// node_modules/zmp-ui/esm/utils/statusUtils.js
var ValidateStatuses = tuple("success", "warning", "error", "validating", "");
var InputStatuses = tuple("success", "error", "");
function getStatusClassNames(prefixCls, status, hasFeedback) {
  var _classNames;
  return clsx_m_default((_classNames = {}, _classNames[prefixCls + "-status-success"] = status === "success", _classNames[prefixCls + "-status-warning"] = status === "warning", _classNames[prefixCls + "-status-error"] = status === "error", _classNames[prefixCls + "-status-validating"] = status === "validating", _classNames[prefixCls + "-has-feedback"] = hasFeedback, _classNames));
}
var getMergedStatus = function getMergedStatus2(contextStatus, customStatus) {
  return customStatus || contextStatus;
};

// node_modules/zmp-ui/esm/config-provider/DisabledContext.js
var React11 = __toESM(require_react());
var DisabledContext = React11.createContext(false);
var DisabledContextProvider = function DisabledContextProvider2(_ref) {
  var children2 = _ref.children, disabled = _ref.disabled;
  var originDisabled = React11.useContext(DisabledContext);
  return React11.createElement(DisabledContext.Provider, {
    value: disabled || originDisabled
  }, children2);
};
DisabledContextProvider.defaultProps = {
  disabled: false,
  children: null
};
var DisabledContext_default = DisabledContext;

// node_modules/zmp-ui/esm/config-provider/SizeContext.js
var React12 = __toESM(require_react());
var SizeContext = React12.createContext(void 0);
var SizeContextProvider = function SizeContextProvider2(_ref) {
  var children2 = _ref.children, size = _ref.size;
  return React12.createElement(SizeContext.Consumer, null, function(originSize) {
    return React12.createElement(SizeContext.Provider, {
      value: size || originSize
    }, children2);
  });
};
SizeContextProvider.defaultProps = {
  size: "medium",
  children: null
};
var SizeContext_default = SizeContext;

// node_modules/zmp-ui/esm/components/input/ClearableLabeledBaseInput.js
var import_react15 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/input/BaseInput.js
var import_react10 = __toESM(require_react());
var BaseInput = function BaseInput2(props) {
  var _classNames2;
  var inputElement = props.inputElement, prefixCls = props.prefixCls, prefix2 = props.prefix, suffix = props.suffix, addonBefore = props.addonBefore, addonAfter = props.addonAfter, className = props.className, style = props.style, affixWrapperClassName = props.affixWrapperClassName, groupClassName = props.groupClassName, wrapperClassName = props.wrapperClassName, disabled = props.disabled, readOnly = props.readOnly, focused = props.focused, triggerFocus2 = props.triggerFocus, allowClear = props.allowClear, value = props.value, handleReset = props.handleReset, hidden = props.hidden, onInputTriggerClick = props.onInputTriggerClick;
  var containerRef = (0, import_react10.useRef)(null);
  var onInputMouseDown = function onInputMouseDown2(e) {
    var _containerRef$current;
    if ((_containerRef$current = containerRef.current) != null && _containerRef$current.contains(e.target)) {
      triggerFocus2 == null || triggerFocus2();
    }
  };
  var getClearIcon = function getClearIcon2() {
    var _classNames;
    if (!allowClear) {
      return null;
    }
    var needClear = !disabled && !readOnly && value;
    var clearIconCls = prefixCls + "-clear-btn";
    var iconNode = typeof allowClear === "object" && allowClear != null && allowClear.clearIcon ? allowClear.clearIcon : "âœ–";
    return import_react10.default.createElement("span", {
      key: prefixCls + "-clear-btn",
      onClick: handleReset,
      onMouseDown: function onMouseDown(e) {
        return e.preventDefault();
      },
      className: clsx_m_default(prefixCls + "-suffix-item", clearIconCls, (_classNames = {}, _classNames[clearIconCls + "-hidden"] = !needClear, _classNames[clearIconCls + "-has-suffix"] = !!suffix, _classNames)),
      role: "button",
      tabIndex: -1
    }, iconNode);
  };
  var element = (0, import_react10.cloneElement)(inputElement, {
    value,
    hidden
  });
  var affixWrapperPrefixCls = prefixCls + "-affix-wrapper";
  var affixWrapperCls = clsx_m_default(affixWrapperPrefixCls, (_classNames2 = {}, _classNames2[affixWrapperPrefixCls + "-disabled"] = disabled, _classNames2[affixWrapperPrefixCls + "-focused"] = focused, _classNames2[affixWrapperPrefixCls + "-readonly"] = readOnly, _classNames2[affixWrapperPrefixCls + "-input-with-clear-btn"] = suffix && allowClear && value, _classNames2), !hasAddon(props) && className, affixWrapperClassName);
  var suffixNode = (suffix || allowClear) && import_react10.default.createElement("span", {
    className: prefixCls + "-suffix"
  }, !disabled && getClearIcon(), suffix);
  element = import_react10.default.createElement("span", {
    className: affixWrapperCls,
    style,
    hidden: !hasAddon(props) && hidden,
    onMouseDown: onInputMouseDown,
    ref: containerRef,
    role: "presentation",
    onClick: onInputTriggerClick
  }, prefix2 && import_react10.default.createElement("span", {
    className: prefixCls + "-prefix"
  }, prefix2), (0, import_react10.cloneElement)(inputElement, {
    style: null,
    value,
    hidden: null
  }), suffixNode);
  if (hasAddon(props)) {
    var wrapperCls = prefixCls + "-group";
    var addonCls = wrapperCls + "-addon";
    var mergedWrapperClassName = clsx_m_default(prefixCls + "-wrapper", wrapperCls, wrapperClassName);
    var mergedGroupClassName = clsx_m_default(prefixCls + "-group-wrapper", className, groupClassName);
    return import_react10.default.createElement("span", {
      className: mergedGroupClassName,
      style,
      hidden
    }, import_react10.default.createElement("span", {
      className: mergedWrapperClassName
    }, addonBefore && import_react10.default.createElement("span", {
      className: addonCls
    }, addonBefore), (0, import_react10.cloneElement)(element, {
      style: null,
      hidden: null
    }), addonAfter && import_react10.default.createElement("span", {
      className: addonCls
    }, addonAfter)));
  }
  return element;
};
var BaseInput_default = BaseInput;

// node_modules/zmp-ui/esm/components/input/icons/close-circle.js
var import_react11 = __toESM(require_react());
var CloseCircleIcon = function CloseCircleIcon2(props) {
  return import_react11.default.createElement("svg", _extends({
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), import_react11.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1.09961 7.99961C1.09961 4.18884 4.18884 1.09961 7.99961 1.09961C11.8104 1.09961 14.8996 4.18884 14.8996 7.99961C14.8996 11.8104 11.8104 14.8996 7.99961 14.8996C4.18884 14.8996 1.09961 11.8104 1.09961 7.99961ZM5.27535 5.27535C5.50966 5.04103 5.88956 5.04103 6.12387 5.27535L7.99961 7.15108L9.87535 5.27535C10.1097 5.04103 10.4896 5.04103 10.7239 5.27535C10.9582 5.50966 10.9582 5.88956 10.7239 6.12387L8.84814 7.99961L10.7239 9.87535C10.9582 10.1097 10.9582 10.4896 10.7239 10.7239C10.4896 10.9582 10.1097 10.9582 9.87535 10.7239L7.99961 8.84814L6.12387 10.7239C5.88956 10.9582 5.50966 10.9582 5.27535 10.7239C5.04103 10.4896 5.04103 10.1097 5.27535 9.87535L7.15108 7.99961L5.27535 6.12387C5.04103 5.88956 5.04103 5.50966 5.27535 5.27535Z",
    fill: "currentColor"
  }));
};
var close_circle_default = CloseCircleIcon;

// node_modules/zmp-ui/esm/components/input/icons/info-circle.js
var import_react12 = __toESM(require_react());
var InfoCircleIcon = function InfoCircleIcon2(props) {
  return import_react12.default.createElement("svg", _extends({
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), import_react12.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1.09961 7.99961C1.09961 4.18884 4.18884 1.09961 7.99961 1.09961C11.8104 1.09961 14.8996 4.18884 14.8996 7.99961C14.8996 11.8104 11.8104 14.8996 7.99961 14.8996C4.18884 14.8996 1.09961 11.8104 1.09961 7.99961ZM7.9996 5.99963C8.55189 5.99963 8.9996 5.55192 8.9996 4.99963C8.9996 4.44735 8.55189 3.99963 7.9996 3.99963C7.44732 3.99963 6.9996 4.44735 6.9996 4.99963C6.9996 5.55192 7.44732 5.99963 7.9996 5.99963ZM7.9996 6.89966C8.44143 6.89966 8.7996 7.25783 8.7996 7.69966V11.2997C8.7996 11.7415 8.44143 12.0997 7.9996 12.0997C7.55778 12.0997 7.1996 11.7415 7.1996 11.2997V7.69966C7.1996 7.25783 7.55778 6.89966 7.9996 6.89966Z",
    fill: "currentColor"
  }));
};
var info_circle_default = InfoCircleIcon;

// node_modules/zmp-ui/esm/components/input/icons/success-circle.js
var import_react13 = __toESM(require_react());
var SuccessCircleIcon = function SuccessCircleIcon2(props) {
  return import_react13.default.createElement("svg", _extends({
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), import_react13.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1.09961 7.99961C1.09961 4.18884 4.18884 1.09961 7.99961 1.09961C11.8104 1.09961 14.8996 4.18884 14.8996 7.99961C14.8996 11.8104 11.8104 14.8996 7.99961 14.8996C4.18884 14.8996 1.09961 11.8104 1.09961 7.99961ZM11.6239 6.22386C11.8582 5.98955 11.8582 5.60965 11.6239 5.37534C11.3896 5.14102 11.0097 5.14102 10.7753 5.37534L6.69961 9.45107L5.12387 7.87534C4.88956 7.64102 4.50966 7.64102 4.27535 7.87534C4.04103 8.10965 4.04103 8.48955 4.27535 8.72386L6.27535 10.7239C6.50966 10.9582 6.88956 10.9582 7.12387 10.7239L11.6239 6.22386Z",
    fill: "currentColor"
  }));
};
var success_circle_default = SuccessCircleIcon;

// node_modules/zmp-ui/esm/components/input/icons/warning.js
var import_react14 = __toESM(require_react());
var WarningIcon = function WarningIcon2(props) {
  return import_react14.default.createElement("svg", _extends({
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), import_react14.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M6.72975 2.28802C7.29427 1.31024 8.70557 1.31024 9.27009 2.28802L14.809 11.8816C15.3735 12.8594 14.6678 14.0816 13.5388 14.0816H2.46104C1.332 14.0816 0.626351 12.8594 1.19087 11.8816L6.72975 2.28802ZM7.37248 5.62619C7.36081 5.28382 7.63519 4.99992 7.97776 4.99992H8.02228C8.36485 4.99992 8.63924 5.28381 8.62757 5.62619L8.50094 9.34061C8.49299 9.57365 8.30177 9.75847 8.06859 9.75847H7.93145C7.69827 9.75847 7.50705 9.57365 7.49911 9.34061L7.37248 5.62619ZM8.70672 11.2906C8.70672 11.6809 8.39032 11.9973 8.00001 11.9973C7.6097 11.9973 7.29329 11.6809 7.29329 11.2906C7.29329 10.9003 7.6097 10.5839 8.00001 10.5839C8.39032 10.5839 8.70672 10.9003 8.70672 11.2906Z",
    fill: "currentColor"
  }));
};
var warning_default = WarningIcon;

// node_modules/zmp-ui/esm/components/input/ClearableLabeledBaseInput.js
var _excluded6 = ["label", "helperText", "errorText", "status", "clearable", "allowClear", "addonBefore", "addonAfter", "suffix", "disabled", "value", "affixWrapperClassName", "groupClassName", "maxLength", "showCount"];
function ownKeys3(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread3(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys3(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var ClearableLabeledBaseInput = function ClearableLabeledBaseInput2(props) {
  var label = props.label, helperText = props.helperText, errorText = props.errorText, status = props.status, clearable = props.clearable, allowClear = props.allowClear, addonBefore = props.addonBefore, addonAfter = props.addonAfter, suffix = props.suffix, disabled = props.disabled, value = props.value, affixWrapperClassName = props.affixWrapperClassName, groupClassName = props.groupClassName, maxLength = props.maxLength, showCount = props.showCount, rest = _objectWithoutPropertiesLoose(props, _excluded6);
  var prefixCls = getPrefixCls("input");
  var getSuffix = function getSuffix2() {
    var hasMaxLength = Number(maxLength) > 0;
    if (suffix || showCount || status === "success") {
      var _classNames, _classNames2;
      var val = fixControlledValue(value);
      var valueLength = val.length;
      var maxLengthStr = hasMaxLength ? "/ " + maxLength : "";
      var dataCount = typeof showCount === "object" ? showCount.formatter({
        value: val,
        count: valueLength,
        maxLength
      }) : "" + valueLength + maxLengthStr;
      return import_react15.default.createElement(import_react15.default.Fragment, null, status === "success" && value && !disabled && import_react15.default.createElement("span", {
        className: clsx_m_default(prefixCls + "-status-success", (_classNames = {}, _classNames[prefixCls + "-status-success-has-suffix"] = !!suffix, _classNames))
      }, import_react15.default.createElement(success_circle_default, {
        className: prefixCls + "-status-success-icon"
      })), !!showCount && import_react15.default.createElement("span", {
        className: clsx_m_default(prefixCls + "-show-count-suffix", (_classNames2 = {}, _classNames2[prefixCls + "-show-count-has-suffix"] = !!suffix, _classNames2))
      }, dataCount), suffix);
    }
    return null;
  };
  var getAddonBefore = function getAddonBefore2() {
    if (label) {
      return import_react15.default.createElement(import_react15.default.Fragment, null, import_react15.default.createElement("span", {
        className: prefixCls + "-label"
      }, label), addonBefore);
    }
    return null;
  };
  var getAddonAfter = function getAddonAfter2() {
    if (addonAfter || helperText || errorText) {
      var _classNames3;
      var hasError = status === "error";
      return import_react15.default.createElement(import_react15.default.Fragment, null, (helperText || errorText) && import_react15.default.createElement("span", {
        className: clsx_m_default(prefixCls + "-helper-text", (_classNames3 = {}, _classNames3[prefixCls + "-helper-text-has-error"] = hasError && !disabled, _classNames3))
      }, hasError && !disabled ? import_react15.default.createElement(import_react15.default.Fragment, null, import_react15.default.createElement(warning_default, {
        className: prefixCls + "-helper-text-icon"
      }), import_react15.default.createElement("span", {
        className: prefixCls + "-helper-text-content"
      }, errorText)) : helperText ? import_react15.default.createElement(import_react15.default.Fragment, null, import_react15.default.createElement(info_circle_default, {
        className: prefixCls + "-helper-text-icon"
      }), import_react15.default.createElement("span", {
        className: prefixCls + "-helper-text-content"
      }, helperText)) : null), addonAfter);
    }
    return null;
  };
  var getAllowClear = function getAllowClear2() {
    if (!disabled && (clearable || allowClear)) {
      var _classNames4;
      if (allowClear) {
        if (typeof allowClear === "object" && allowClear.clearIcon) {
          var _props;
          var customIcon = import_react15.default.cloneElement(allowClear.clearIcon, {
            className: clsx_m_default(prefixCls + "-clear-icon", (_props = allowClear.clearIcon.props) == null ? void 0 : _props.className)
          });
          return _objectSpread3(_objectSpread3({}, allowClear), {}, {
            clearIcon: customIcon
          });
        }
        return allowClear;
      }
      var displayMode = typeof clearable === "object" && clearable != null && clearable.mode ? clearable.mode : "always";
      return {
        clearIcon: import_react15.default.createElement(close_circle_default, {
          className: clsx_m_default(prefixCls + "-clear-icon", (_classNames4 = {}, _classNames4[prefixCls + "-clear-icon-display-mode-focus"] = displayMode === "focus", _classNames4))
        })
      };
    }
    return false;
  };
  return import_react15.default.createElement(BaseInput_default, _extends({}, rest, {
    disabled,
    value: fixControlledValue(value),
    addonBefore: getAddonBefore(),
    addonAfter: getAddonAfter(),
    allowClear: getAllowClear(),
    suffix: getSuffix(),
    affixWrapperClassName: clsx_m_default(getStatusClassNames(prefixCls + "-affix-wrapper", status), affixWrapperClassName),
    groupClassName: clsx_m_default(getStatusClassNames(prefixCls + "-group-wrapper", status), groupClassName)
  }));
};
var ClearableLabeledBaseInput_default = ClearableLabeledBaseInput;

// node_modules/zmp-ui/esm/components/input/Input.js
var _excluded7 = ["onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "type", "disabled", "className", "inputClassName", "defaultValue", "status", "size"];
var Input = (0, import_react16.forwardRef)(function(props, ref) {
  var onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown = props.onKeyDown, _props$type = props.type, type = _props$type === void 0 ? "text" : _props$type, customDisabled = props.disabled, className = props.className, inputClassName = props.inputClassName, defaultValue = props.defaultValue, customStatus = props.status, customSize = props.size, rest = _objectWithoutPropertiesLoose(props, _excluded7);
  var prefixCls = getPrefixCls("input");
  var _useMergedState = useMergedState(defaultValue, {
    value: props.value
  }), value = _useMergedState[0], setValue = _useMergedState[1];
  var _useState = (0, import_react16.useState)(false), focused = _useState[0], setFocused = _useState[1];
  var inputRef = (0, import_react16.useRef)(null);
  var focus = function focus2(option) {
    if (inputRef.current) {
      triggerFocus(inputRef.current, option);
    }
  };
  var size = import_react16.default.useContext(SizeContext_default);
  var mergedSize = customSize || size;
  var disabled = import_react16.default.useContext(DisabledContext_default);
  var mergedDisabled = customDisabled || disabled;
  var contextStatus = "";
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var removePasswordTimeoutRef = (0, import_react16.useRef)([]);
  var removePasswordTimeout = function removePasswordTimeout2() {
    removePasswordTimeoutRef.current.push(window.setTimeout(function() {
      var _inputRef$current, _inputRef$current2;
      if (inputRef.current && ((_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.getAttribute("type")) === "password" && (_inputRef$current2 = inputRef.current) != null && _inputRef$current2.hasAttribute("value")) {
        var _inputRef$current3;
        (_inputRef$current3 = inputRef.current) == null || _inputRef$current3.removeAttribute("value");
      }
    }));
  };
  (0, import_react16.useImperativeHandle)(ref, function() {
    return {
      focus,
      blur: function blur() {
        var _inputRef$current4;
        (_inputRef$current4 = inputRef.current) == null || _inputRef$current4.blur();
      },
      setSelectionRange: function setSelectionRange(start2, end, direction) {
        var _inputRef$current5;
        (_inputRef$current5 = inputRef.current) == null || _inputRef$current5.setSelectionRange(start2, end, direction);
      },
      select: function select() {
        var _inputRef$current6;
        (_inputRef$current6 = inputRef.current) == null || _inputRef$current6.select();
      },
      input: inputRef.current
    };
  });
  (0, import_react16.useEffect)(function() {
    setFocused(function(prev) {
      return prev && mergedDisabled ? false : prev;
    });
  }, [mergedDisabled]);
  (0, import_react16.useEffect)(function() {
    removePasswordTimeout();
    return function() {
      return removePasswordTimeoutRef.current.forEach(function(item) {
        return window.clearTimeout(item);
      });
    };
  }, []);
  var handleChange = function handleChange2(e) {
    if (props.value === void 0) {
      setValue(e.target.value);
    }
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e, onChange);
    }
  };
  var handleKeyDown = function handleKeyDown2(e) {
    if (onPressEnter && e.key === "Enter") {
      onPressEnter(e);
    }
    onKeyDown == null || onKeyDown(e);
  };
  var handleFocus = function handleFocus2(e) {
    setFocused(true);
    removePasswordTimeout();
    onFocus == null || onFocus(e);
  };
  var handleBlur = function handleBlur2(e) {
    setFocused(false);
    removePasswordTimeout();
    onBlur == null || onBlur(e);
  };
  var handleReset = function handleReset2(e) {
    setValue("");
    focus();
    if (inputRef.current) {
      resolveOnChange(inputRef.current, e, onChange);
    }
  };
  var getInputElement = function getInputElement2() {
    var _classNames;
    var otherProps = omit(props, [
      "onPressEnter",
      "prefix",
      "suffix",
      "clearable",
      "allowClear",
      "status",
      "helperText",
      "errorText",
      "size",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "affixWrapperClassName",
      "groupClassName",
      "inputClassName",
      "wrapperClassName",
      "onInputTriggerClick"
    ]);
    return import_react16.default.createElement("input", _extends({}, otherProps, {
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      className: clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-small"] = mergedSize === "small", _classNames[prefixCls + "-large"] = mergedSize === "large", _classNames[prefixCls + "-disabled"] = mergedDisabled, _classNames), (!!value || mergedStatus === "error") && getStatusClassNames(prefixCls, mergedStatus), inputClassName, className),
      ref: inputRef,
      type
    }));
  };
  return import_react16.default.createElement(ClearableLabeledBaseInput_default, _extends({}, rest, {
    prefixCls,
    className,
    inputElement: getInputElement(),
    handleReset,
    value,
    focused,
    triggerFocus: focus,
    disabled: mergedDisabled || void 0,
    status: mergedStatus
  }));
});
Input.defaultProps = {
  onInputTriggerClick: void 0
};
var Input_default = Input;

// node_modules/zmp-ui/esm/components/input/Password.js
var import_react19 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/input/icons/eye.js
var import_react17 = __toESM(require_react());
var EyeIcon = function EyeIcon2(props) {
  return import_react17.default.createElement("svg", _extends({
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), import_react17.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M1.90039 12.0004C1.90039 14.6904 6.66039 18.1004 12.0004 18.1004C17.3404 18.1004 22.1004 14.6904 22.1004 12.0004C22.1004 9.31039 17.3404 5.90039 12.0004 5.90039C6.66039 5.90039 1.90039 9.31039 1.90039 12.0004ZM3.10039 12.0004C3.10039 10.1504 7.26039 7.10039 12.0004 7.10039C16.7404 7.10039 20.9004 10.1004 20.9004 12.0004C20.9004 13.9004 16.7404 16.9004 12.0004 16.9004C7.26039 16.9004 3.10039 13.8504 3.10039 12.0004ZM10.0003 14.9937C10.5924 15.3893 11.2884 15.6004 12.0004 15.6004C12.9552 15.6004 13.8708 15.2211 14.546 14.546C15.2211 13.8708 15.6004 12.9552 15.6004 12.0004C15.6004 11.2884 15.3893 10.5924 14.9937 10.0003C14.5981 9.40832 14.0359 8.9469 13.3781 8.67443C12.7202 8.40195 11.9964 8.33066 11.2981 8.46957C10.5997 8.60847 9.95828 8.95134 9.45481 9.45481C8.95134 9.95828 8.60847 10.5997 8.46957 11.2981C8.33066 11.9964 8.40195 12.7202 8.67443 13.3781C8.9469 14.0359 9.40832 14.5981 10.0003 14.9937ZM10.667 10.0049C11.0617 9.74115 11.5257 9.60039 12.0004 9.60039C12.6361 9.60302 13.245 9.85673 13.6945 10.3062C14.1441 10.7558 14.3978 11.3647 14.4004 12.0004C14.4004 12.4751 14.2596 12.9391 13.9959 13.3338C13.7322 13.7284 13.3574 14.0361 12.9188 14.2177C12.4803 14.3994 11.9977 14.4469 11.5322 14.3543C11.0666 14.2617 10.639 14.0331 10.3033 13.6974C9.96769 13.3618 9.73911 12.9342 9.64651 12.4686C9.5539 12.0031 9.60143 11.5205 9.78308 11.082C9.96473 10.6434 10.2723 10.2686 10.667 10.0049Z",
    fill: "currentColor"
  }));
};
var eye_default = EyeIcon;

// node_modules/zmp-ui/esm/components/input/icons/eye-invisible.js
var import_react18 = __toESM(require_react());
var EyeInvisibleIcon = function EyeInvisibleIcon2(props) {
  return import_react18.default.createElement("svg", _extends({
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), import_react18.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3.18358 20.9928C3.27679 21.0578 3.38653 21.0949 3.50005 21.1C3.57718 21.1026 3.65405 21.0898 3.72617 21.0623C3.79829 21.0349 3.8642 20.9933 3.92005 20.94L7.54763 17.3124C8.97515 17.8262 10.4809 18.0929 12 18.1C17.34 18.1 22.1 14.69 22.1 12.02C22.1 10.65 20.87 9.10001 18.87 7.86001C18.7394 7.80657 18.5941 7.80089 18.4597 7.84397C18.3253 7.88704 18.2104 7.97611 18.1352 8.09552C18.06 8.21492 18.0292 8.35703 18.0484 8.49685C18.0676 8.63667 18.1354 8.76526 18.24 8.86001C19.9 9.85001 20.9 11.08 20.9 12C20.9 13.9 16.74 16.9 12 16.9C10.8104 16.8954 9.62992 16.714 8.49686 16.3632L9.92199 14.9381C10.139 15.0944 10.3737 15.2258 10.6218 15.3293C11.0583 15.5115 11.5271 15.6036 12 15.6C12.9548 15.6 13.8705 15.2207 14.5456 14.5456C15.2208 13.8704 15.6 12.9548 15.6 12C15.6 11.8409 15.5368 11.6883 15.4243 11.5757C15.3118 11.4632 15.1592 11.4 15 11.4C14.8409 11.4 14.6883 11.4632 14.5758 11.5757C14.4633 11.6883 14.4 11.8409 14.4 12C14.4012 12.4755 14.2611 12.9407 13.9975 13.3365C13.7338 13.7322 13.3586 14.0407 12.9193 14.2229C12.48 14.405 11.9965 14.4525 11.5302 14.3595C11.2662 14.3067 11.0144 14.2103 10.7847 14.0754L20.92 3.94C21.0314 3.8286 21.094 3.67753 21.094 3.51999C21.094 3.36246 21.0314 3.21139 20.92 3.09999C20.8087 2.9886 20.6576 2.92603 20.5 2.92603C20.3425 2.92603 20.1914 2.9886 20.08 3.09999L16.4815 6.69851C15.045 6.1792 13.5294 5.90883 12 5.89999C6.66002 5.89999 1.90002 9.30999 1.90002 12C1.90002 13.36 3.09002 14.9 5.08002 16.13C5.17651 16.1886 5.28715 16.2197 5.40002 16.22C5.52999 16.2187 5.65601 16.1752 5.75914 16.0961C5.86227 16.017 5.93693 15.9066 5.97189 15.7814C6.00685 15.6562 6.00022 15.5231 5.95299 15.402C5.90577 15.2809 5.8205 15.1784 5.71002 15.11C4.10002 14.13 3.10002 12.91 3.10002 12C3.10002 10.15 7.26003 7.09999 12 7.09999C13.2003 7.10461 14.3913 7.28926 15.5337 7.64632L14.1013 9.07878C13.8778 8.91502 13.6352 8.77788 13.3783 8.67066C12.9418 8.4885 12.473 8.39644 12 8.4C11.0452 8.4 10.1296 8.77929 9.45444 9.45442C8.77931 10.1295 8.40002 11.0452 8.40002 12C8.40002 12.1591 8.46324 12.3117 8.57576 12.4243C8.68828 12.5368 8.84089 12.6 9.00002 12.6C9.15915 12.6 9.31177 12.5368 9.42429 12.4243C9.53681 12.3117 9.60003 12.1591 9.60003 12C9.59886 11.5245 9.73898 11.0593 10.0026 10.6635C10.2662 10.2678 10.6415 9.95926 11.0808 9.77712C11.5201 9.59498 12.0035 9.54745 12.4699 9.64054C12.7435 9.69518 13.0041 9.79681 13.2405 9.93954L9.56117 13.6189C9.52488 13.642 9.49093 13.6691 9.46004 13.7C9.42915 13.7309 9.40201 13.7648 9.37892 13.8011L7.09363 16.0864C6.9986 16.1402 6.92009 16.2188 6.86643 16.3136L3.08005 20.1C3.00418 20.1846 2.9539 20.289 2.93505 20.401C2.91619 20.5131 2.92954 20.6282 2.97354 20.7329C3.01754 20.8377 3.09038 20.9278 3.18358 20.9928Z",
    fill: "currentColor"
  }));
};
var eye_invisible_default = EyeInvisibleIcon;

// node_modules/zmp-ui/esm/components/input/Password.js
var _excluded8 = ["className", "visibilityToggle"];
function ownKeys4(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread4(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys4(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys4(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Password = import_react19.default.forwardRef(function(props, ref) {
  var _useState = (0, import_react19.useState)(false), visible = _useState[0], setVisible = _useState[1];
  var onVisibleChange = function onVisibleChange2() {
    var disabled = props.disabled;
    if (disabled) {
      return;
    }
    setVisible(!visible);
  };
  var getIcon3 = function getIcon4(prefixCls) {
    var _props$iconRender = props.iconRender, iconRender2 = _props$iconRender === void 0 ? function() {
      return null;
    } : _props$iconRender;
    var icon2 = iconRender2(visible);
    var iconProps = {
      onClick: onVisibleChange,
      className: prefixCls + "-icon",
      key: "passwordIcon",
      onMouseDown: function onMouseDown(e) {
        e.preventDefault();
      },
      onMouseUp: function onMouseUp(e) {
        e.preventDefault();
      }
    };
    return import_react19.default.cloneElement(import_react19.default.isValidElement(icon2) ? icon2 : import_react19.default.createElement("span", null, icon2), iconProps);
  };
  var renderPassword = function renderPassword2() {
    var className = props.className, visibilityToggle = props.visibilityToggle, restProps = _objectWithoutPropertiesLoose(props, _excluded8);
    var prefixCls = getPrefixCls("input-password");
    var suffixIcon = visibilityToggle && getIcon3(prefixCls);
    var inputClassName = clsx_m_default(prefixCls, className);
    var omittedProps = _objectSpread4(_objectSpread4({}, omit(restProps, ["suffix", "iconRender"])), {}, {
      type: visible ? "text" : "password",
      className: inputClassName,
      suffix: suffixIcon
    });
    return import_react19.default.createElement(Input_default, _extends({
      ref
    }, omittedProps));
  };
  return renderPassword();
});
Password.defaultProps = {
  visibilityToggle: true,
  iconRender: function iconRender(visible) {
    return visible ? import_react19.default.createElement(eye_default, null) : import_react19.default.createElement(eye_invisible_default, null);
  }
};
var Password_default = Password;

// node_modules/zmp-ui/esm/components/input/Search.js
var import_react21 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/input/icons/search-outlined.js
var import_react20 = __toESM(require_react());
var SearchOutlined = function SearchOutlined2(props) {
  return import_react20.default.createElement("svg", _extends({
    // width="19"
    // height="19"
    viewBox: "0 0 19 19",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props), import_react20.default.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M2.10039 8.00039C2.10039 4.74191 4.74191 2.10039 8.00039 2.10039C11.2589 2.10039 13.9004 4.74191 13.9004 8.00039C13.9004 11.2589 11.2589 13.9004 8.00039 13.9004C4.74191 13.9004 2.10039 11.2589 2.10039 8.00039ZM8.00039 0.900391C4.07917 0.900391 0.900391 4.07917 0.900391 8.00039C0.900391 11.9216 4.07917 15.1004 8.00039 15.1004C9.67283 15.1004 11.2102 14.5221 12.4235 13.5547C12.4272 13.5585 12.431 13.5623 12.4348 13.5661L17.4348 18.5661C17.7472 18.8785 18.2537 18.8785 18.5661 18.5661C18.8785 18.2537 18.8785 17.7472 18.5661 17.4348L13.5661 12.4348C13.5623 12.431 13.5585 12.4272 13.5547 12.4235C14.5221 11.2102 15.1004 9.67283 15.1004 8.00039C15.1004 4.07917 11.9216 0.900391 8.00039 0.900391Z",
    fill: "currentColor"
  }));
};
var search_outlined_default = SearchOutlined;

// node_modules/zmp-ui/esm/utils/ref.js
var import_react_is = __toESM(require_react_is());
function fillRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else if (typeof ref === "object" && ref && "current" in ref) {
    ref.current = node;
  }
}
function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  var refList = refs.filter(function(ref) {
    return ref;
  });
  if (refList.length <= 1) {
    return refList[0];
  }
  return function(node) {
    refs.forEach(function(ref) {
      fillRef(ref, node);
    });
  };
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;
  var type = (0, import_react_is.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
  if (typeof type === "function" && !((_type$prototype = type.prototype) != null && _type$prototype.render)) {
    return false;
  }
  return !(typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) != null && _nodeOrComponent$prot.render));
}

// node_modules/zmp-ui/esm/components/input/Search.js
var _excluded9 = ["className", "suffix", "loading", "disabled", "size", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"];
var Search = import_react21.default.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, suffix = props.suffix, loading = props.loading, disabled = props.disabled, customizeSize = props.size, customOnSearch = props.onSearch, customOnChange = props.onChange, onCompositionStart = props.onCompositionStart, onCompositionEnd = props.onCompositionEnd, restProps = _objectWithoutPropertiesLoose(props, _excluded9);
  var contextSize = import_react21.default.useContext(SizeContext_default);
  var composedRef = import_react21.default.useRef(false);
  var size = customizeSize || contextSize;
  var inputRef = import_react21.default.useRef(null);
  var onChange = function onChange2(e) {
    if (e && e.target && e.type === "click" && customOnSearch) {
      customOnSearch(e.target.value, e);
    }
    if (customOnChange) {
      customOnChange(e);
    }
  };
  var onMouseDown = function onMouseDown2(e) {
    var _inputRef$current;
    if (document.activeElement === ((_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.input)) {
      e.preventDefault();
    }
  };
  var onSearch = function onSearch2(e) {
    if (customOnSearch) {
      var _inputRef$current2;
      customOnSearch(((_inputRef$current2 = inputRef.current) == null || (_inputRef$current2 = _inputRef$current2.input) == null ? void 0 : _inputRef$current2.value) || "", e);
    }
  };
  var onPressEnter = function onPressEnter2(e) {
    if (composedRef.current) {
      return;
    }
    onSearch(e);
  };
  var prefixCls = getPrefixCls("input-search");
  var searchIcon = import_react21.default.createElement(search_outlined_default, null);
  var btnClassName = prefixCls + "-button";
  var buttonSearch = import_react21.default.createElement(button_default, {
    className: btnClassName,
    variant: "tertiary",
    type: "neutral",
    disabled,
    key: "enterButton",
    onMouseDown,
    onClick: onSearch,
    loading,
    icon: searchIcon,
    size
  });
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-" + size] = !!size, _classNames), className);
  var handleOnCompositionStart = function handleOnCompositionStart2(e) {
    composedRef.current = true;
    onCompositionStart == null || onCompositionStart(e);
  };
  var handleOnCompositionEnd = function handleOnCompositionEnd2(e) {
    composedRef.current = false;
    onCompositionEnd == null || onCompositionEnd(e);
  };
  return import_react21.default.createElement(Input_default, _extends({
    ref: composeRef(inputRef, ref),
    onPressEnter
  }, restProps, {
    size,
    label: "",
    helperText: "",
    onCompositionStart: handleOnCompositionStart,
    onCompositionEnd: handleOnCompositionEnd,
    prefix: buttonSearch,
    suffix,
    onChange,
    className: cls,
    disabled
  }));
});
var Search_default = Search;

// node_modules/zmp-ui/esm/components/input/TextArea.js
var import_react22 = __toESM(require_react());
var _excluded10 = ["onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "disabled", "className", "defaultValue", "status", "size", "autoHeight"];
var TextArea = (0, import_react22.forwardRef)(function(props, ref) {
  var onChange = props.onChange, onFocus = props.onFocus, onBlur = props.onBlur, onPressEnter = props.onPressEnter, onKeyDown = props.onKeyDown, customDisabled = props.disabled, className = props.className, defaultValue = props.defaultValue, customStatus = props.status, customSize = props.size, autoHeight = props.autoHeight, rest = _objectWithoutPropertiesLoose(props, _excluded10);
  var inputPrefixCls = getPrefixCls("input");
  var prefixCls = getPrefixCls("input-textarea");
  var inputClassName = clsx_m_default(prefixCls, className);
  var _useMergedState = useMergedState(defaultValue, {
    value: props.value
  }), value = _useMergedState[0], setValue = _useMergedState[1];
  var _useState = (0, import_react22.useState)(value), currentValue = _useState[0], setCurrentValue = _useState[1];
  var _useState2 = (0, import_react22.useState)(false), focused = _useState2[0], setFocused = _useState2[1];
  var textareaRef = (0, import_react22.useRef)(null);
  var focus = function focus2(option) {
    if (textareaRef.current) {
      triggerFocus(textareaRef.current, option);
    }
  };
  var size = import_react22.default.useContext(SizeContext_default);
  var mergedSize = customSize || size;
  var disabled = import_react22.default.useContext(DisabledContext_default);
  var mergedDisabled = customDisabled || disabled;
  var contextStatus = "";
  var mergedStatus = getMergedStatus(contextStatus, customStatus);
  var removePasswordTimeoutRef = (0, import_react22.useRef)([]);
  var removePasswordTimeout = function removePasswordTimeout2() {
    removePasswordTimeoutRef.current.push(window.setTimeout(function() {
      var _textareaRef$current, _textareaRef$current2;
      if (textareaRef.current && ((_textareaRef$current = textareaRef.current) == null ? void 0 : _textareaRef$current.getAttribute("type")) === "password" && (_textareaRef$current2 = textareaRef.current) != null && _textareaRef$current2.hasAttribute("value")) {
        var _textareaRef$current3;
        (_textareaRef$current3 = textareaRef.current) == null || _textareaRef$current3.removeAttribute("value");
      }
    }));
  };
  (0, import_react22.useImperativeHandle)(ref, function() {
    return {
      focus,
      blur: function blur() {
        var _textareaRef$current4;
        (_textareaRef$current4 = textareaRef.current) == null || _textareaRef$current4.blur();
      },
      setSelectionRange: function setSelectionRange(start2, end, direction) {
        var _textareaRef$current5;
        (_textareaRef$current5 = textareaRef.current) == null || _textareaRef$current5.setSelectionRange(start2, end, direction);
      },
      select: function select() {
        var _textareaRef$current6;
        (_textareaRef$current6 = textareaRef.current) == null || _textareaRef$current6.select();
      },
      textarea: textareaRef.current
    };
  });
  (0, import_react22.useEffect)(function() {
    setFocused(function(prev) {
      return prev && mergedDisabled ? false : prev;
    });
  }, [mergedDisabled]);
  (0, import_react22.useEffect)(function() {
    removePasswordTimeout();
    return function() {
      return removePasswordTimeoutRef.current.forEach(function(item) {
        return window.clearTimeout(item);
      });
    };
  }, []);
  (0, import_react22.useEffect)(function() {
    if (autoHeight && textareaRef.current) {
      textareaRef.current.style.height = "auto";
      var scrollHeight = textareaRef.current.scrollHeight;
      textareaRef.current.style.height = scrollHeight + "px";
    }
  }, [autoHeight, currentValue]);
  var handleChange = function handleChange2(e) {
    if (props.value === void 0) {
      setValue(e.target.value);
    }
    if (autoHeight) {
      setCurrentValue(e.target.value);
    }
    if (textareaRef.current) {
      resolveOnChange(textareaRef.current, e, onChange);
    }
  };
  var handleKeyDown = function handleKeyDown2(e) {
    if (onPressEnter && e.key === "Enter") {
      onPressEnter(e);
    }
    onKeyDown == null || onKeyDown(e);
  };
  var handleFocus = function handleFocus2(e) {
    setFocused(true);
    removePasswordTimeout();
    onFocus == null || onFocus(e);
  };
  var handleBlur = function handleBlur2(e) {
    setFocused(false);
    removePasswordTimeout();
    onBlur == null || onBlur(e);
  };
  var handleReset = function handleReset2(e) {
    setValue("");
    focus();
    if (textareaRef.current) {
      resolveOnChange(textareaRef.current, e, onChange);
    }
  };
  var getInputElement = function getInputElement2() {
    var _classNames, _classNames2;
    var otherProps = omit(props, [
      "onPressEnter",
      "prefix",
      "suffix",
      "clearable",
      "status",
      "helperText",
      "errorText",
      "size",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "affixWrapperClassName",
      "groupClassName",
      "inputClassName",
      "wrapperClassName",
      "showCount"
    ]);
    return import_react22.default.createElement("textarea", _extends({}, otherProps, {
      onChange: handleChange,
      onFocus: handleFocus,
      onBlur: handleBlur,
      onKeyDown: handleKeyDown,
      className: clsx_m_default(inputPrefixCls, (_classNames = {}, _classNames[inputPrefixCls + "-small"] = mergedSize === "small", _classNames[inputPrefixCls + "-medium"] = mergedSize === "medium", _classNames[inputPrefixCls + "-large"] = mergedSize === "large", _classNames[inputPrefixCls + "-disabled"] = mergedDisabled, _classNames), !!value && getStatusClassNames(inputPrefixCls, mergedStatus), inputClassName, (_classNames2 = {}, _classNames2[prefixCls + "-min-height"] = !mergedSize, _classNames2[prefixCls + "-has-show-count"] = rest.showCount, _classNames2), className),
      ref: textareaRef
    }));
  };
  return import_react22.default.createElement(ClearableLabeledBaseInput_default, _extends({}, rest, {
    prefixCls: inputPrefixCls,
    className,
    inputElement: getInputElement(),
    handleReset,
    value,
    focused,
    triggerFocus: focus,
    disabled: mergedDisabled || void 0,
    status: mergedStatus,
    affixWrapperClassName: prefixCls + "-affix-wrapper"
  }));
});
var TextArea_default = TextArea;

// node_modules/zmp-ui/esm/components/input/OTP.js
var import_react23 = __toESM(require_react());
var OTP = import_react23.default.forwardRef(function(props, ref) {
  var disabled = props.disabled, _props$otpLength = props.otpLength, otpLength = _props$otpLength === void 0 ? 4 : _props$otpLength, _props$show = props.show, show = _props$show === void 0 ? false : _props$show, defaultValue = props.defaultValue, onChange = props.onChange, rawValue = props.value, readOnly = props.readOnly, className = props.className, style = props.style, id = props.id;
  var inputRef = import_react23.default.useRef(null);
  var inputPrefixCls = getPrefixCls("input");
  var prefixCls = getPrefixCls("input-otp");
  var _useMergedState = useMergedState(defaultValue || "", {
    value: rawValue
  }), value = _useMergedState[0], setValue = _useMergedState[1];
  var _useState = (0, import_react23.useState)(false), isFocus = _useState[0], setIsFocus = _useState[1];
  var _useState2 = (0, import_react23.useState)(null), focusIndex = _useState2[0], setFocusIndex = _useState2[1];
  var handleFocus = (0, import_react23.useCallback)(function() {
    var _inputRef$current;
    if (disabled || readOnly) return;
    setIsFocus(true);
    (_inputRef$current = inputRef.current) == null || _inputRef$current.focus();
  }, [disabled, readOnly]);
  var handleSetFocusIndex = (0, import_react23.useCallback)(function(selectedIndex) {
    var len = value.length;
    if (selectedIndex && len > selectedIndex && len - selectedIndex <= 1) {
      setFocusIndex(selectedIndex);
    } else if (len === otpLength) {
      setFocusIndex(len - 1);
    } else {
      setFocusIndex(len);
    }
  }, [value, otpLength]);
  var handleRawInputChange = (0, import_react23.useCallback)(function(event) {
    var inputValue = event.target.value;
    if (inputValue.length <= otpLength) {
      setValue(inputValue);
      setFocusIndex(inputValue.length);
      onChange == null || onChange(event);
    }
  }, [otpLength, setValue, onChange]);
  var handleClickOtpItem = (0, import_react23.useCallback)(function(selectedIndex) {
    handleSetFocusIndex(selectedIndex);
    handleFocus();
  }, [handleSetFocusIndex, handleFocus]);
  (0, import_react23.useImperativeHandle)(ref, function() {
    return {
      el: inputRef.current,
      focus: function focus() {
        handleSetFocusIndex();
        handleFocus();
      },
      blur: function blur() {
        var _inputRef$current2;
        (_inputRef$current2 = inputRef.current) == null || _inputRef$current2.blur();
      }
    };
  });
  return import_react23.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-wrapper")
  }, import_react23.default.createElement("input", {
    type: "number",
    inputMode: "numeric",
    pattern: "[0-9]*",
    autoComplete: "one-time-code",
    maxLength: otpLength,
    ref: inputRef,
    disabled,
    onFocus: function onFocus() {
      return handleFocus();
    },
    onBlur: function onBlur() {
      return setIsFocus(false);
    },
    value,
    onChange: handleRawInputChange,
    readOnly,
    className: clsx_m_default(prefixCls + "-hidden-input"),
    id
  }), import_react23.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-list")
  }, Array(otpLength).fill("").map(function(_, index2) {
    var _classNames;
    var num = value.slice(index2, index2 + 1);
    var focus = focusIndex === index2 && isFocus;
    return import_react23.default.createElement("div", {
      role: "presentation",
      onClick: function onClick() {
        return handleClickOtpItem(index2);
      },
      key: index2,
      className: clsx_m_default(inputPrefixCls, prefixCls, (_classNames = {}, _classNames[inputPrefixCls + "-disabled"] = disabled, _classNames[prefixCls + "-active"] = focus && !disabled, _classNames[prefixCls + "-cursor"] = focus && !num && !disabled, _classNames), className),
      style
    }, num ? show ? num : import_react23.default.createElement("span", {
      className: prefixCls + "-dot"
    }) : "");
  })));
});
OTP.defaultProps = {
  otpLength: 4,
  show: false
};
var OTP_default = OTP;

// node_modules/zmp-ui/esm/components/input/index.js
var Input2 = Input_default;
Input2.Password = Password_default;
Input2.Search = Search_default;
Input2.TextArea = TextArea_default;
Input2.OTP = OTP_default;
var input_default = Input2;

// node_modules/zmp-ui/esm/components/avatar/avatar.js
var import_react25 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/avatar/props-type.js
var StoryStatus = function(StoryStatus2) {
  StoryStatus2["seen"] = "seen";
  StoryStatus2["default"] = "default";
  return StoryStatus2;
}({});

// node_modules/zmp-ui/esm/components/avatar/block-icon.js
var import_react24 = __toESM(require_react());
var BlockedIcon = function BlockedIcon2() {
  var prefixCls = getPrefixCls("avatar-block-icon-bg");
  return import_react24.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    fill: "none"
  }, import_react24.default.createElement("rect", {
    width: "12",
    height: "12",
    rx: "6",
    fill: "#DC1F18"
  }), import_react24.default.createElement("path", {
    className: prefixCls,
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M6 10.5C8.48528 10.5 10.5 8.48528 10.5 6C10.5 5.07331 10.2199 4.21205 9.73972 3.49626C9.63951 3.34688 9.429 3.33467 9.30181 3.46186L3.46186 9.30181C3.33467 9.429 3.34688 9.63951 3.49626 9.73972C4.21205 10.2199 5.07331 10.5 6 10.5ZM2.26028 8.50374C2.36048 8.65312 2.57099 8.66532 2.69819 8.53813L8.53813 2.69819C8.66533 2.57099 8.65312 2.36048 8.50374 2.26028C7.78795 1.78011 6.92668 1.5 6 1.5C3.51472 1.5 1.5 3.51472 1.5 6C1.5 6.92668 1.78011 7.78795 2.26028 8.50374Z",
    fill: "white"
  }));
};
var block_icon_default = BlockedIcon;

// node_modules/zmp-ui/esm/components/avatar/avatar.js
var _excluded11 = ["story", "blocked", "children", "src", "online", "className", "size", "style", "backgroundColor"];
function ownKeys5(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread5(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys5(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys5(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var TOTAL_GRADIENT_VARIANTS = 4;
var calculateAvatarColor = function calculateAvatarColor2(name) {
  if (typeof name !== "string") {
    return "GREEN-GREENLIGHT";
  }
  var sum = 0;
  var length = name.length;
  for (var i = 0; i < length; i += 1) {
    sum += name.charCodeAt(i);
  }
  var colorIndex = sum % TOTAL_GRADIENT_VARIANTS;
  switch (colorIndex) {
    case 1:
      return "GREEN-GREENLIGHT";
    case 2:
      return "PURPLE-BLUE";
    case 3:
      return "SKYBLUE-GREEN";
    default:
      return "BLUE-BLUELIGHT";
  }
};
var Avatar = import_react25.default.forwardRef(function(props, ref) {
  var _classNames;
  var story = props.story, blocked = props.blocked, children2 = props.children, src = props.src, online = props.online, className = props.className, size = props.size, style = props.style, backgroundColor = props.backgroundColor, rest = _objectWithoutPropertiesLoose(props, _excluded11);
  var prefixCls = getPrefixCls("avatar");
  var bgColor = backgroundColor;
  if (!bgColor && typeof children2 === "string") {
    bgColor = calculateAvatarColor(children2);
  }
  var classes = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-story"] = story === StoryStatus["default"], _classNames[prefixCls + "-story-seen"] = story === StoryStatus.seen, _classNames[prefixCls + "-text-xsmall"] = size && size <= 24, _classNames[prefixCls + "-text-small"] = size && size > 24 && size <= 32, _classNames[prefixCls + "-text-medium"] = size && size > 32 && size <= 48, _classNames[prefixCls + "-text-large"] = size && size > 48, _classNames[prefixCls + "-color-01"] = bgColor === "BLUE-BLUELIGHT", _classNames[prefixCls + "-color-02"] = bgColor === "PURPLE-BLUE", _classNames[prefixCls + "-color-03"] = bgColor === "SKYBLUE-GREEN", _classNames[prefixCls + "-color-04"] = bgColor === "GREEN-GREENLIGHT", _classNames["" + className] = className, _classNames));
  var avatarStyle = {};
  if (style) {
    avatarStyle = _objectSpread5({}, style);
  }
  if (size) {
    avatarStyle = _objectSpread5(_objectSpread5({}, avatarStyle), {}, {
      "--zaui-avatar-size": size + "px"
    });
  }
  return import_react25.default.createElement("div", _extends({
    ref,
    className: classes,
    style: avatarStyle
  }, rest), src ? import_react25.default.createElement("img", {
    className: prefixCls + "-image",
    src,
    alt: ""
  }) : import_react25.default.createElement("div", {
    className: prefixCls + "-inner"
  }, children2), online && import_react25.default.createElement("span", {
    className: prefixCls + "-online"
  }), blocked && import_react25.default.createElement("span", {
    className: prefixCls + "-blocked"
  }, import_react25.default.createElement(block_icon_default, null)));
});
var avatar_default = Avatar;

// node_modules/zmp-ui/esm/components/avatar/group.js
var import_react26 = __toESM(require_react());
var _excluded12 = ["children", "horizontal", "className", "maxCounter", "onCounterClick", "total"];
var DEFAULT_AVATAR_GROUP_COUNTER = 3;
var MAX_VERTICAL_AVATAR_GROUP_COUNTER = 4;
var Group = function Group2(props) {
  var _classNames;
  var children2 = props.children, horizontalProps = props.horizontal, className = props.className, _props$maxCounter = props.maxCounter, maxCounterProps = _props$maxCounter === void 0 ? DEFAULT_AVATAR_GROUP_COUNTER : _props$maxCounter, onCounterClick = props.onCounterClick, totalAvatar = props.total, rest = _objectWithoutPropertiesLoose(props, _excluded12);
  var prefixCls = getPrefixCls("avatar-group");
  var handleOnCounterClick = function handleOnCounterClick2(event) {
    if (typeof onCounterClick === "function") {
      onCounterClick(event);
    }
  };
  var maxCounter = maxCounterProps < 1 ? DEFAULT_AVATAR_GROUP_COUNTER : maxCounterProps;
  var horizontal = maxCounter > MAX_VERTICAL_AVATAR_GROUP_COUNTER ? true : horizontalProps;
  var childrenComponents = [];
  if (children2 && import_react26.default.Children.count(children2)) {
    childrenComponents = import_react26.default.Children.toArray(children2);
  }
  var total = totalAvatar && totalAvatar >= childrenComponents.length ? totalAvatar : childrenComponents.length;
  var totalDisplay = total === maxCounter ? total : maxCounter;
  var dataToDisplay = childrenComponents.slice(0, totalDisplay).map(function(child) {
    return child.props;
  });
  var classes = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-horizontal"] = horizontal, _classNames), className);
  var maxCounterCls = clsx_m_default(prefixCls + "-item", prefixCls + "-item-max-counter");
  return import_react26.default.createElement("div", _extends({
    className: classes
  }, rest), dataToDisplay.map(function(avatarProps, index2) {
    return import_react26.default.createElement(avatar_default, _extends({
      className: prefixCls + "-item",
      key: (avatarProps == null ? void 0 : avatarProps.id) || "zaui-avatar-" + index2
    }, avatarProps, {
      story: false,
      online: false,
      size: 24
    }));
  }), total > totalDisplay && import_react26.default.createElement(avatar_default, {
    onClick: handleOnCounterClick,
    className: maxCounterCls,
    size: 24
  }, "+", total - totalDisplay));
};
Group.displayName = "Avatar.Group";
var group_default = Group;

// node_modules/zmp-ui/esm/components/avatar/index.js
var Avatar2 = avatar_default;
Avatar2.Group = group_default;
var avatar_default2 = Avatar2;

// node_modules/zmp-ui/esm/components/modal/index.js
var import_react37 = __toESM(require_react());

// node_modules/zmp-ui/esm/common/modal-mask/index.js
var import_react34 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
    return t2.__proto__ = e2, t2;
  }, _setPrototypeOf(t, e);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(t, o) {
  t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_prop_types3 = __toESM(require_prop_types());

// node_modules/dom-helpers/esm/hasClass.js
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

// node_modules/dom-helpers/esm/addClass.js
function addClass(element, className) {
  if (element.classList) element.classList.add(className);
  else if (!hasClass(element, className)) if (typeof element.className === "string") element.className = element.className + " " + className;
  else element.setAttribute("class", (element.className && element.className.baseVal || "") + " " + className);
}

// node_modules/dom-helpers/esm/removeClass.js
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", "g"), "$1").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === "string") {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute("class", replaceClassName(element.className && element.className.baseVal || "", className));
  }
}

// node_modules/react-transition-group/esm/CSSTransition.js
var import_react29 = __toESM(require_react());

// node_modules/react-transition-group/esm/Transition.js
var import_prop_types2 = __toESM(require_prop_types());
var import_react28 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/react-transition-group/esm/config.js
var config_default = {
  disabled: false
};

// node_modules/react-transition-group/esm/utils/PropTypes.js
var import_prop_types = __toESM(require_prop_types());
var timeoutsShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
  enter: import_prop_types.default.number,
  exit: import_prop_types.default.number,
  appear: import_prop_types.default.number
}).isRequired]) : null;
var classNamesShape = true ? import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  active: import_prop_types.default.string
}), import_prop_types.default.shape({
  enter: import_prop_types.default.string,
  enterDone: import_prop_types.default.string,
  enterActive: import_prop_types.default.string,
  exit: import_prop_types.default.string,
  exitDone: import_prop_types.default.string,
  exitActive: import_prop_types.default.string
})]) : null;

// node_modules/react-transition-group/esm/TransitionGroupContext.js
var import_react27 = __toESM(require_react());
var TransitionGroupContext_default = import_react27.default.createContext(null);

// node_modules/react-transition-group/esm/utils/reflow.js
var forceReflow = function forceReflow2(node) {
  return node.scrollTop;
};

// node_modules/react-transition-group/esm/Transition.js
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout2 = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout2;
    if (timeout2 != null && typeof timeout2 !== "number") {
      exit = timeout2.exit;
      enter = timeout2.enter;
      appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
          if (node) forceReflow(node);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts2 = this.getTimeouts();
    var enterTimeout = appearing ? timeouts2.appear : timeouts2.enter;
    if (!mounting && !enter || config_default.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts2 = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
    if (!exit || config_default.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts2.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout2 != null) {
      setTimeout(this.nextCallback, timeout2);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children2 = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      import_react28.default.createElement(TransitionGroupContext_default.Provider, {
        value: null
      }, typeof children2 === "function" ? children2(status, childProps) : import_react28.default.cloneElement(import_react28.default.Children.only(children2), childProps))
    );
  };
  return Transition2;
}(import_react28.default.Component);
Transition.contextType = TransitionGroupContext_default;
Transition.propTypes = true ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: import_prop_types2.default.shape({
    current: typeof Element === "undefined" ? import_prop_types2.default.any : function(propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return import_prop_types2.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),
  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: import_prop_types2.default.oneOfType([import_prop_types2.default.func.isRequired, import_prop_types2.default.element.isRequired]).isRequired,
  /**
   * Show the component; triggers the enter or exit states
   */
  in: import_prop_types2.default.bool,
  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: import_prop_types2.default.bool,
  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: import_prop_types2.default.bool,
  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: import_prop_types2.default.bool,
  /**
   * Enable or disable enter transitions.
   */
  enter: import_prop_types2.default.bool,
  /**
   * Enable or disable exit transitions.
   */
  exit: import_prop_types2.default.bool,
  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = timeoutsShape;
    if (!props.addEndListener) pt = pt.isRequired;
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return pt.apply(void 0, [props].concat(args));
  },
  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: import_prop_types2.default.func,
  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: import_prop_types2.default.func,
  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types2.default.func,
  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: import_prop_types2.default.func,
  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: import_prop_types2.default.func,
  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: import_prop_types2.default.func,
  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: import_prop_types2.default.func
} : {};
function noop() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
var Transition_default = Transition;

// node_modules/react-transition-group/esm/CSSTransition.js
var _addClass = function addClass2(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return addClass(node, c);
  });
};
var removeClass2 = function removeClass3(node, classes) {
  return node && classes && classes.split(" ").forEach(function(c) {
    return removeClass(node, c);
  });
};
var CSSTransition = function(_React$Component) {
  _inheritsLoose(CSSTransition2, _React$Component);
  function CSSTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };
    _this.onEnter = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument[0], appearing = _this$resolveArgument[1];
      _this.removeClasses(node, "exit");
      _this.addClass(node, appearing ? "appear" : "enter", "base");
      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };
    _this.onEntering = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument2[0], appearing = _this$resolveArgument2[1];
      var type = appearing ? "appear" : "enter";
      _this.addClass(node, type, "active");
      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };
    _this.onEntered = function(maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing), node = _this$resolveArgument3[0], appearing = _this$resolveArgument3[1];
      var type = appearing ? "appear" : "enter";
      _this.removeClasses(node, type);
      _this.addClass(node, type, "done");
      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };
    _this.onExit = function(maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode), node = _this$resolveArgument4[0];
      _this.removeClasses(node, "appear");
      _this.removeClasses(node, "enter");
      _this.addClass(node, "exit", "base");
      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };
    _this.onExiting = function(maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode), node = _this$resolveArgument5[0];
      _this.addClass(node, "exit", "active");
      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };
    _this.onExited = function(maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode), node = _this$resolveArgument6[0];
      _this.removeClasses(node, "exit");
      _this.addClass(node, "exit", "done");
      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };
    _this.resolveArguments = function(maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] : [maybeNode, maybeAppearing];
    };
    _this.getClassNames = function(type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === "string";
      var prefix2 = isStringClassNames && classNames ? classNames + "-" : "";
      var baseClassName = isStringClassNames ? "" + prefix2 + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName,
        activeClassName,
        doneClassName
      };
    };
    return _this;
  }
  var _proto = CSSTransition2.prototype;
  _proto.addClass = function addClass3(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];
    var _this$getClassNames = this.getClassNames("enter"), doneClassName = _this$getClassNames.doneClassName;
    if (type === "appear" && phase === "done" && doneClassName) {
      className += " " + doneClassName;
    }
    if (phase === "active") {
      if (node) forceReflow(node);
    }
    if (className) {
      this.appliedClasses[type][phase] = className;
      _addClass(node, className);
    }
  };
  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type], baseClassName = _this$appliedClasses$.base, activeClassName = _this$appliedClasses$.active, doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};
    if (baseClassName) {
      removeClass2(node, baseClassName);
    }
    if (activeClassName) {
      removeClass2(node, activeClassName);
    }
    if (doneClassName) {
      removeClass2(node, doneClassName);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, _ = _this$props.classNames, props = _objectWithoutPropertiesLoose(_this$props, ["classNames"]);
    return import_react29.default.createElement(Transition_default, _extends({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };
  return CSSTransition2;
}(import_react29.default.Component);
CSSTransition.defaultProps = {
  classNames: ""
};
CSSTransition.propTypes = true ? _extends({}, Transition_default.propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: classNamesShape,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: import_prop_types3.default.func,
  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: import_prop_types3.default.func
}) : {};
var CSSTransition_default = CSSTransition;

// node_modules/react-transition-group/esm/ReplaceTransition.js
var import_prop_types5 = __toESM(require_prop_types());
var import_react32 = __toESM(require_react());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var import_prop_types4 = __toESM(require_prop_types());
var import_react31 = __toESM(require_react());

// node_modules/react-transition-group/esm/utils/ChildMapping.js
var import_react30 = __toESM(require_react());
function getChildMapping(children2, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && (0, import_react30.isValidElement)(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children2) import_react30.Children.map(children2, function(c) {
    return c;
  }).forEach(function(child) {
    result[child.key] = mapper(child);
  });
  return result;
}
function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};
  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i;
  var childMapping = {};
  for (var nextKey2 in next) {
    if (nextKeysPending[nextKey2]) {
      for (i = 0; i < nextKeysPending[nextKey2].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey2][i];
        childMapping[nextKeysPending[nextKey2][i]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey2] = getValueForKey(nextKey2);
  }
  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return (0, import_react30.cloneElement)(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children2 = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children2).forEach(function(key) {
    var child = children2[key];
    if (!(0, import_react30.isValidElement)(child)) return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = (0, import_react30.isValidElement)(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children2[key] = (0, import_react30.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children2[key] = (0, import_react30.cloneElement)(child, {
        in: false
      });
    } else if (hasNext && hasPrev && (0, import_react30.isValidElement)(prevChild)) {
      children2[key] = (0, import_react30.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children2;
}

// node_modules/react-transition-group/esm/TransitionGroup.js
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k) {
    return obj[k];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping) return;
    if (child.props.onExited) {
      child.props.onExited(node);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children2 = _extends({}, state.children);
        delete children2[child.key];
        return {
          children: children2
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children2 = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return import_react31.default.createElement(TransitionGroupContext_default.Provider, {
        value: contextValue
      }, children2);
    }
    return import_react31.default.createElement(TransitionGroupContext_default.Provider, {
      value: contextValue
    }, import_react31.default.createElement(Component, props, children2));
  };
  return TransitionGroup2;
}(import_react31.default.Component);
TransitionGroup.propTypes = true ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: import_prop_types4.default.any,
  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: import_prop_types4.default.node,
  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: import_prop_types4.default.bool,
  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: import_prop_types4.default.bool,
  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: import_prop_types4.default.bool,
  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: import_prop_types4.default.func
} : {};
TransitionGroup.defaultProps = defaultProps;
var TransitionGroup_default = TransitionGroup;

// node_modules/react-transition-group/esm/ReplaceTransition.js
var ReplaceTransition = function(_React$Component) {
  _inheritsLoose(ReplaceTransition2, _React$Component);
  function ReplaceTransition2() {
    var _this;
    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
    _this.handleEnter = function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return _this.handleLifecycle("onEnter", 0, args);
    };
    _this.handleEntering = function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return _this.handleLifecycle("onEntering", 0, args);
    };
    _this.handleEntered = function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return _this.handleLifecycle("onEntered", 0, args);
    };
    _this.handleExit = function() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }
      return _this.handleLifecycle("onExit", 1, args);
    };
    _this.handleExiting = function() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }
      return _this.handleLifecycle("onExiting", 1, args);
    };
    _this.handleExited = function() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }
      return _this.handleLifecycle("onExited", 1, args);
    };
    return _this;
  }
  var _proto = ReplaceTransition2.prototype;
  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;
    var children2 = this.props.children;
    var child = import_react32.default.Children.toArray(children2)[idx];
    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);
    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? void 0 : import_react_dom2.default.findDOMNode(this);
      this.props[handler](maybeNode);
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, inProp = _this$props.in, props = _objectWithoutPropertiesLoose(_this$props, ["children", "in"]);
    var _React$Children$toArr = import_react32.default.Children.toArray(children2), first = _React$Children$toArr[0], second = _React$Children$toArr[1];
    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return import_react32.default.createElement(TransitionGroup_default, props, inProp ? import_react32.default.cloneElement(first, {
      key: "first",
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : import_react32.default.cloneElement(second, {
      key: "second",
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };
  return ReplaceTransition2;
}(import_react32.default.Component);
ReplaceTransition.propTypes = true ? {
  in: import_prop_types5.default.bool.isRequired,
  children: function children(props, propName) {
    if (import_react32.default.Children.count(props[propName]) !== 2) return new Error('"' + propName + '" must be exactly two transition components.');
    return null;
  }
} : {};

// node_modules/react-transition-group/esm/SwitchTransition.js
var import_react33 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var _leaveRenders;
var _enterRenders;
function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren) return false;
  if (import_react33.default.isValidElement(oldChildren) && import_react33.default.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }
  return true;
}
var modes = {
  out: "out-in",
  in: "in-out"
};
var callHook = function callHook2(element, name, cb) {
  return function() {
    var _element$props;
    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};
var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function(_ref) {
  var current = _ref.current, changeState = _ref.changeState;
  return import_react33.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERING, null);
    })
  });
}, _leaveRenders[modes.in] = function(_ref2) {
  var current = _ref2.current, changeState = _ref2.changeState, children2 = _ref2.children;
  return [current, import_react33.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERING);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function(_ref3) {
  var children2 = _ref3.children, changeState = _ref3.changeState;
  return import_react33.default.cloneElement(children2, {
    in: true,
    onEntered: callHook(children2, "onEntered", function() {
      changeState(ENTERED, import_react33.default.cloneElement(children2, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function(_ref4) {
  var current = _ref4.current, children2 = _ref4.children, changeState = _ref4.changeState;
  return [import_react33.default.cloneElement(current, {
    in: false,
    onExited: callHook(current, "onExited", function() {
      changeState(ENTERED, import_react33.default.cloneElement(children2, {
        in: true
      }));
    })
  }), import_react33.default.cloneElement(children2, {
    in: true
  })];
}, _enterRenders);
var SwitchTransition = function(_React$Component) {
  _inheritsLoose(SwitchTransition2, _React$Component);
  function SwitchTransition2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: ENTERED,
      current: null
    };
    _this.appeared = false;
    _this.changeState = function(status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }
      _this.setState({
        status,
        current
      });
    };
    return _this;
  }
  var _proto = SwitchTransition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };
  SwitchTransition2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }
    if (state.status === ENTERING && props.mode === modes.in) {
      return {
        status: ENTERING
      };
    }
    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: EXITING
      };
    }
    return {
      current: import_react33.default.cloneElement(props.children, {
        in: true
      })
    };
  };
  _proto.render = function render() {
    var _this$props = this.props, children2 = _this$props.children, mode = _this$props.mode, _this$state = this.state, status = _this$state.status, current = _this$state.current;
    var data = {
      children: children2,
      current,
      changeState: this.changeState,
      status
    };
    var component;
    switch (status) {
      case ENTERING:
        component = enterRenders[mode](data);
        break;
      case EXITING:
        component = leaveRenders[mode](data);
        break;
      case ENTERED:
        component = current;
    }
    return import_react33.default.createElement(TransitionGroupContext_default.Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };
  return SwitchTransition2;
}(import_react33.default.Component);
SwitchTransition.propTypes = true ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: import_prop_types6.default.oneOf([modes.in, modes.out]),
  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: import_prop_types6.default.oneOfType([import_prop_types6.default.element.isRequired])
} : {};
SwitchTransition.defaultProps = {
  mode: modes.out
};

// node_modules/zmp-ui/esm/common/modal-mask/index.js
var Mask = function Mask2(props) {
  var _useState = (0, import_react34.useState)(false), animationVisible = _useState[0], setAnimationVisible = _useState[1];
  var nodeRef = (0, import_react34.useRef)(null);
  var _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, style = props.style, maskProps = props.maskProps, children2 = props.children, className = props.className;
  var prefixCls = getPrefixCls("mask");
  var cls = clsx_m_default(prefixCls, className);
  (0, import_react34.useEffect)(function() {
    setAnimationVisible(visible);
  }, [visible]);
  return import_react34.default.createElement(CSSTransition_default, {
    key: "modal-mask",
    "in": animationVisible,
    nodeRef,
    timeout: {
      exit: 300,
      enter: 300
    },
    classNames: prefixCls
  }, import_react34.default.createElement("div", _extends({
    ref: nodeRef,
    style,
    className: cls
  }, maskProps), children2));
};
var modal_mask_default = Mask;

// node_modules/zmp-ui/esm/components/modal/content.js
var import_react35 = __toESM(require_react());
var _excluded13 = ["className", "onClick", "highLight", "danger", "close"];
function ownKeys6(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread6(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys6(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Content = import_react35.default.forwardRef(function(props, ref) {
  var _classNames;
  var title = props.title, ariaId = props.ariaId, children2 = props.children, coverSrc = props.coverSrc, description = props.description, actions = props.actions, verticalActions = props.verticalActions, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, onVisibleChanged = props.onVisibleChanged, onClose = props.onClose, _props$actionsDivider = props.actionsDivider, actionsDivider = _props$actionsDivider === void 0 ? true : _props$actionsDivider, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, modalClassName = props.modalClassName, modalStyle = props.modalStyle, height = props.height, width = props.width;
  var prefixCls = getPrefixCls("modal-content");
  var cls = clsx_m_default(prefixCls, modalClassName);
  var actionsCls = clsx_m_default(prefixCls + "-actions", (_classNames = {}, _classNames[prefixCls + "-actions-vertical"] = verticalActions, _classNames[prefixCls + "-actions-no-divider"] = actionsDivider === false, _classNames));
  var modalContentStyle = {};
  if (modalStyle) {
    modalContentStyle = _objectSpread6({}, modalStyle);
  }
  if (height) {
    modalContentStyle.height = height;
  }
  if (width) {
    modalContentStyle.width = width;
  }
  var coverNode = import_react35.default.createElement("div", {
    className: prefixCls + "-cover"
  }, import_react35.default.createElement("img", {
    src: coverSrc,
    alt: title
  }));
  var mainContent = import_react35.default.createElement("div", {
    className: prefixCls + "-main"
  }, import_react35.default.createElement("div", {
    className: prefixCls + "-title"
  }, title), import_react35.default.createElement("div", {
    className: prefixCls + "-description"
  }, description), children2);
  var actionContent = actions ? import_react35.default.createElement("div", {
    className: actionsCls
  }, actions.map(function(action, index2) {
    var _classNames2;
    var actionClassName = action.className, onClick = action.onClick, highLight = action.highLight, danger = action.danger, close = action.close, buttonProps = _objectWithoutPropertiesLoose(action, _excluded13);
    var btnCls = clsx_m_default(actionClassName, prefixCls + "-action", (_classNames2 = {}, _classNames2[prefixCls + "-action-highlight"] = highLight, _classNames2));
    var onActionClick = function onActionClick2(e) {
      if (close && onClose) {
        onClose(e);
        return;
      }
      if (onClick) {
        onClick(e);
      }
    };
    var actionType = "neutral";
    if (highLight) {
      actionType = "highlight";
    }
    if (danger) {
      actionType = "danger";
    }
    return import_react35.default.createElement(button_default, _extends({}, buttonProps, {
      key: action.key || "zaui-modal-action-key-" + index2,
      className: btnCls,
      onClick: onActionClick,
      variant: "tertiary",
      type: actionType
    }), action.text);
  })) : null;
  return import_react35.default.createElement(CSSTransition_default, {
    "in": visible,
    timeout: {
      exit: 300,
      enter: 300
    },
    classNames: prefixCls,
    key: "modal-content",
    onEnter: function onEnter() {
      onVisibleChanged == null || onVisibleChanged(true);
    },
    nodeRef: ref,
    onExited: function onExited() {
      return onVisibleChanged == null ? void 0 : onVisibleChanged(false);
    }
  }, import_react35.default.createElement("div", {
    ref,
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": title ? ariaId : void 0,
    "aria-modal": "true",
    className: cls,
    onMouseDown,
    onMouseUp,
    style: modalContentStyle
  }, coverSrc && coverNode, mainContent, actionContent));
});
var content_default = Content;

// node_modules/zmp-ui/esm/common/modal-wrapper/index.js
var import_react36 = __toESM(require_react());
var _excluded14 = ["visible", "afterClose", "maskClosable", "onClose", "children", "style", "className"];
function ownKeys7(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread7(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys7(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys7(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var ModalWrapper = function ModalWrapper2(props) {
  var _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, afterClose = props.afterClose, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, onClose = props.onClose, children2 = props.children, style = props.style, className = props.className, rest = _objectWithoutPropertiesLoose(props, _excluded14);
  var _useState = (0, import_react36.useState)(visible), animatedVisible = _useState[0], setAnimatedVisible = _useState[1];
  var wrapperRef = (0, import_react36.useRef)();
  var contentClickRef = (0, import_react36.useRef)(false);
  var contentTimeoutRef = (0, import_react36.useRef)();
  (0, import_react36.useEffect)(function() {
    var pageElement = document.querySelector(".zaui-page");
    if (visible) {
      if (pageElement) {
        pageElement.classList.add("disable-scrolling");
      }
      setAnimatedVisible(true);
    } else if (pageElement) {
      pageElement.classList.remove("disable-scrolling");
    }
  }, [visible]);
  var onVisibleChange = function onVisibleChange2(newVisible) {
    if (!newVisible) {
      setAnimatedVisible(false);
      afterClose == null || afterClose();
    }
  };
  var onContentMouseDown = function onContentMouseDown2() {
    clearTimeout(contentTimeoutRef.current);
    contentClickRef.current = true;
  };
  var onContentMouseUp = function onContentMouseUp2() {
    contentTimeoutRef.current = setTimeout(function() {
      contentClickRef.current = false;
    });
  };
  var onWrapperClick = function onWrapperClick2(e) {
    if (!maskClosable) {
      return;
    }
    if (contentClickRef.current) {
      contentClickRef.current = false;
    } else if (wrapperRef.current === e.target) {
      onClose == null || onClose(e);
    }
  };
  var prefixCls = getPrefixCls("modal-wrapper");
  var cls = clsx_m_default(prefixCls, className);
  return import_react36.default.createElement("div", _extends({}, rest, {
    ref: wrapperRef,
    onClick: onWrapperClick,
    style: _objectSpread7({
      display: !animatedVisible ? "none" : void 0
    }, style || {}),
    className: cls,
    role: "presentation"
  }), import_react36.default.cloneElement(children2, {
    onMouseDown: onContentMouseDown,
    onMouseUp: onContentMouseUp,
    onVisibleChanged: onVisibleChange
  }));
};
var modal_wrapper_default = ModalWrapper;

// node_modules/zmp-ui/esm/components/modal/index.js
var Modal = import_react37.default.forwardRef(function(props, ref) {
  var _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, afterClose = props.afterClose, className = props.className, maskClassName = props.maskClassName, maskStyle = props.maskStyle, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, zIndex = props.zIndex, onClose = props.onClose, unmountOnClose = props.unmountOnClose;
  var _useState = (0, import_react37.useState)(visible), animatedVisible = _useState[0], setAnimatedVisible = _useState[1];
  var _useState2 = (0, import_react37.useState)(!unmountOnClose), contentVisible = _useState2[0], setContentVisible = _useState2[1];
  var contentRef = (0, import_react37.useRef)(null);
  (0, import_react37.useEffect)(function() {
    if (unmountOnClose && visible) {
      setContentVisible(visible);
    }
    setAnimatedVisible(visible);
  }, [visible]);
  var handleAfterClose = function handleAfterClose2() {
    if (unmountOnClose) {
      setContentVisible(false);
    }
    afterClose == null || afterClose();
  };
  var prefixCls = getPrefixCls("modal");
  var cls = clsx_m_default(prefixCls, className);
  if (unmountOnClose && !contentVisible) {
    return null;
  }
  return import_react37.default.createElement("div", {
    className: cls,
    ref
  }, mask && import_react37.default.createElement(modal_mask_default, {
    visible: animatedVisible,
    style: maskStyle,
    className: maskClassName
  }), import_react37.default.createElement(modal_wrapper_default, {
    style: {
      zIndex
    },
    maskClosable,
    visible: animatedVisible,
    afterClose: handleAfterClose,
    onClose
  }, import_react37.default.createElement(content_default, _extends({}, props, {
    visible: animatedVisible,
    ref: contentRef
  }))));
});
var modal_default = Modal;

// node_modules/zmp-ui/esm/components/sheet/sheet.js
var import_react45 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/sheet/content.js
var import_react43 = __toESM(require_react());

// node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js
function clamp(v, min, max) {
  return Math.max(min, Math.min(v, max));
}
var V = {
  toVector(v, fallback) {
    if (v === void 0) v = fallback;
    return Array.isArray(v) ? v : [v, v];
  },
  add(v1, v2) {
    return [v1[0] + v2[0], v1[1] + v2[1]];
  },
  sub(v1, v2) {
    return [v1[0] - v2[0], v1[1] - v2[1]];
  },
  addTo(v1, v2) {
    v1[0] += v2[0];
    v1[1] += v2[1];
  },
  subTo(v1, v2) {
    v1[0] -= v2[0];
    v1[1] -= v2[1];
  }
};
function rubberband(distance, dimension, constant) {
  if (dimension === 0 || Math.abs(dimension) === Infinity) return Math.pow(distance, constant * 5);
  return distance * dimension * constant / (dimension + constant * distance);
}
function rubberbandIfOutOfBounds(position, min, max, constant = 0.15) {
  if (constant === 0) return clamp(position, min, max);
  if (position < min) return -rubberband(min - position, max - min, constant) + min;
  if (position > max) return +rubberband(position - max, max - min, constant) + max;
  return position;
}
function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
  const [[X0, X1], [Y0, Y1]] = bounds;
  return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
}

// node_modules/@use-gesture/core/dist/actions-fe213e88.esm.js
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _defineProperty2(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys8(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread22(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys8(Object(t), true).forEach(function(r3) {
      _defineProperty2(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys8(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var EVENT_TYPE_MAP = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function capitalize(string) {
  if (!string) return "";
  return string[0].toUpperCase() + string.slice(1);
}
var actionsWithoutCaptureSupported = ["enter", "leave"];
function hasCapture(capture = false, actionKey) {
  return capture && !actionsWithoutCaptureSupported.includes(actionKey);
}
function toHandlerProp(device, action = "", capture = false) {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
}
var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
function parseProp(prop) {
  let eventKey = prop.substring(2).toLowerCase();
  const passive = !!~eventKey.indexOf("passive");
  if (passive) eventKey = eventKey.replace("passive", "");
  const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
  const capture = !!~eventKey.indexOf(captureKey);
  if (capture) eventKey = eventKey.replace("capture", "");
  return {
    device: eventKey,
    capture,
    passive
  };
}
function toDomEventType(device, action = "") {
  const deviceProps = EVENT_TYPE_MAP[device];
  const actionKey = deviceProps ? deviceProps[action] || action : action;
  return device + actionKey;
}
function isTouch(event) {
  return "touches" in event;
}
function getPointerType(event) {
  if (isTouch(event)) return "touch";
  if ("pointerType" in event) return event.pointerType;
  return "mouse";
}
function getCurrentTargetTouchList(event) {
  return Array.from(event.touches).filter((e) => {
    var _event$currentTarget, _event$currentTarget$;
    return e.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e.target));
  });
}
function getTouchList(event) {
  return event.type === "touchend" || event.type === "touchcancel" ? event.changedTouches : event.targetTouches;
}
function getValueEvent(event) {
  return isTouch(event) ? getTouchList(event)[0] : event;
}
function distanceAngle(P1, P2) {
  try {
    const dx = P2.clientX - P1.clientX;
    const dy = P2.clientY - P1.clientY;
    const cx = (P2.clientX + P1.clientX) / 2;
    const cy = (P2.clientY + P1.clientY) / 2;
    const distance = Math.hypot(dx, dy);
    const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
    const origin = [cx, cy];
    return {
      angle,
      distance,
      origin
    };
  } catch (_unused) {
  }
  return null;
}
function touchIds(event) {
  return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
}
function touchDistanceAngle(event, ids) {
  const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
  return distanceAngle(P1, P2);
}
function pointerId(event) {
  const valueEvent = getValueEvent(event);
  return isTouch(event) ? valueEvent.identifier : valueEvent.pointerId;
}
function pointerValues(event) {
  const valueEvent = getValueEvent(event);
  return [valueEvent.clientX, valueEvent.clientY];
}
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
function wheelValues(event) {
  let {
    deltaX,
    deltaY,
    deltaMode
  } = event;
  if (deltaMode === 1) {
    deltaX *= LINE_HEIGHT;
    deltaY *= LINE_HEIGHT;
  } else if (deltaMode === 2) {
    deltaX *= PAGE_HEIGHT;
    deltaY *= PAGE_HEIGHT;
  }
  return [deltaX, deltaY];
}
function scrollValues(event) {
  var _ref, _ref2;
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return [(_ref = scrollX !== null && scrollX !== void 0 ? scrollX : scrollLeft) !== null && _ref !== void 0 ? _ref : 0, (_ref2 = scrollY !== null && scrollY !== void 0 ? scrollY : scrollTop) !== null && _ref2 !== void 0 ? _ref2 : 0];
}
function getEventDetails(event) {
  const payload = {};
  if ("buttons" in event) payload.buttons = event.buttons;
  if ("shiftKey" in event) {
    const {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    } = event;
    Object.assign(payload, {
      shiftKey,
      altKey,
      metaKey,
      ctrlKey
    });
  }
  return payload;
}
function call(v, ...args) {
  if (typeof v === "function") {
    return v(...args);
  } else {
    return v;
  }
}
function noop2() {
}
function chain(...fns) {
  if (fns.length === 0) return noop2;
  if (fns.length === 1) return fns[0];
  return function() {
    let result;
    for (const fn of fns) {
      result = fn.apply(this, arguments) || result;
    }
    return result;
  };
}
function assignDefault(value, fallback) {
  return Object.assign({}, fallback, value || {});
}
var BEFORE_LAST_KINEMATICS_DELAY = 32;
var Engine = class {
  constructor(ctrl, args, key) {
    this.ctrl = ctrl;
    this.args = args;
    this.key = key;
    if (!this.state) {
      this.state = {};
      this.computeValues([0, 0]);
      this.computeInitial();
      if (this.init) this.init();
      this.reset();
    }
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(state) {
    this.ctrl.state[this.key] = state;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state,
      shared,
      ingKey,
      args
    } = this;
    shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
    state._step = [false, false];
    state.intentional = false;
    state._movement = [0, 0];
    state._distance = [0, 0];
    state._direction = [0, 0];
    state._delta = [0, 0];
    state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
    state.args = args;
    state.axis = void 0;
    state.memo = void 0;
    state.elapsedTime = state.timeDelta = 0;
    state.direction = [0, 0];
    state.distance = [0, 0];
    state.overflow = [0, 0];
    state._movementBound = [false, false];
    state.velocity = [0, 0];
    state.movement = [0, 0];
    state.delta = [0, 0];
    state.timeStamp = 0;
  }
  start(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state._active) {
      this.reset();
      this.computeInitial();
      state._active = true;
      state.target = event.target;
      state.currentTarget = event.currentTarget;
      state.lastOffset = config2.from ? call(config2.from, state) : state.offset;
      state.offset = state.lastOffset;
      state.startTime = state.timeStamp = event.timeStamp;
    }
  }
  computeValues(values2) {
    const state = this.state;
    state._values = values2;
    state.values = this.config.transform(values2);
  }
  computeInitial() {
    const state = this.state;
    state._initial = state._values;
    state.initial = state.values;
  }
  compute(event) {
    const {
      state,
      config: config2,
      shared
    } = this;
    state.args = this.args;
    let dt = 0;
    if (event) {
      state.event = event;
      if (config2.preventDefault && event.cancelable) state.event.preventDefault();
      state.type = event.type;
      shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
      shared.locked = !!document.pointerLockElement;
      Object.assign(shared, getEventDetails(event));
      shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
      dt = event.timeStamp - state.timeStamp;
      state.timeStamp = event.timeStamp;
      state.elapsedTime = state.timeStamp - state.startTime;
    }
    if (state._active) {
      const _absoluteDelta = state._delta.map(Math.abs);
      V.addTo(state._distance, _absoluteDelta);
    }
    if (this.axisIntent) this.axisIntent(event);
    const [_m0, _m1] = state._movement;
    const [t0, t1] = config2.threshold;
    const {
      _step,
      values: values2
    } = state;
    if (config2.hasCustomTransform) {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && values2[0];
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && values2[1];
    } else {
      if (_step[0] === false) _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
      if (_step[1] === false) _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
    }
    state.intentional = _step[0] !== false || _step[1] !== false;
    if (!state.intentional) return;
    const movement = [0, 0];
    if (config2.hasCustomTransform) {
      const [v0, v1] = values2;
      movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
    } else {
      movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
      movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
    }
    if (this.restrictToAxis && !state._blocked) this.restrictToAxis(movement);
    const previousOffset = state.offset;
    const gestureIsActive = state._active && !state._blocked || state.active;
    if (gestureIsActive) {
      state.first = state._active && !state.active;
      state.last = !state._active && state.active;
      state.active = shared[this.ingKey] = state._active;
      if (event) {
        if (state.first) {
          if ("bounds" in config2) state._bounds = call(config2.bounds, state);
          if (this.setup) this.setup();
        }
        state.movement = movement;
        this.computeOffset();
      }
    }
    const [ox, oy] = state.offset;
    const [[x0, x1], [y0, y1]] = state._bounds;
    state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
    state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
    state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
    const rubberband2 = state._active ? config2.rubberband || [0, 0] : [0, 0];
    state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
    state.delta = V.sub(state.offset, previousOffset);
    this.computeMovement();
    if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
      state.delta = V.sub(state.offset, previousOffset);
      const absoluteDelta = state.delta.map(Math.abs);
      V.addTo(state.distance, absoluteDelta);
      state.direction = state.delta.map(Math.sign);
      state._direction = state._delta.map(Math.sign);
      if (!state.first && dt > 0) {
        state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
        state.timeDelta = dt;
      }
    }
  }
  emit() {
    const state = this.state;
    const shared = this.shared;
    const config2 = this.config;
    if (!state._active) this.clean();
    if ((state._blocked || !state.intentional) && !state._force && !config2.triggerAllEvents) return;
    const memo = this.handler(_objectSpread22(_objectSpread22(_objectSpread22({}, shared), state), {}, {
      [this.aliasKey]: state.values
    }));
    if (memo !== void 0) state.memo = memo;
  }
  clean() {
    this.eventStore.clean();
    this.timeoutStore.clean();
  }
};
function selectAxis([dx, dy], threshold) {
  const absDx = Math.abs(dx);
  const absDy = Math.abs(dy);
  if (absDx > absDy && absDx > threshold) {
    return "x";
  }
  if (absDy > absDx && absDy > threshold) {
    return "y";
  }
  return void 0;
}
var CoordinatesEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty2(this, "aliasKey", "xy");
  }
  reset() {
    super.reset();
    this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0];
    this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = V.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state.axis && event) {
      const threshold = typeof config2.axisThreshold === "object" ? config2.axisThreshold[getPointerType(event)] : config2.axisThreshold;
      state.axis = selectAxis(state._movement, threshold);
    }
    state._blocked = (config2.lockDirection || !!config2.axis) && !state.axis || !!config2.axis && config2.axis !== state.axis;
  }
  restrictToAxis(v) {
    if (this.config.axis || this.config.lockDirection) {
      switch (this.state.axis) {
        case "x":
          v[1] = 0;
          break;
        case "y":
          v[0] = 0;
          break;
      }
    }
  }
};
var identity = (v) => v;
var DEFAULT_RUBBERBAND = 0.15;
var commonConfigResolver = {
  enabled(value = true) {
    return value;
  },
  eventOptions(value, _k, config2) {
    return _objectSpread22(_objectSpread22({}, config2.shared.eventOptions), value);
  },
  preventDefault(value = false) {
    return value;
  },
  triggerAllEvents(value = false) {
    return value;
  },
  rubberband(value = 0) {
    switch (value) {
      case true:
        return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
      case false:
        return [0, 0];
      default:
        return V.toVector(value);
    }
  },
  from(value) {
    if (typeof value === "function") return value;
    if (value != null) return V.toVector(value);
  },
  transform(value, _k, config2) {
    const transform = value || config2.shared.transform;
    this.hasCustomTransform = !!transform;
    if (true) {
      const originalTransform = transform || identity;
      return (v) => {
        const r2 = originalTransform(v);
        if (!isFinite(r2[0]) || !isFinite(r2[1])) {
          console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r2[0]},${[1]}]`);
        }
        return r2;
      };
    }
    return transform || identity;
  },
  threshold(value) {
    return V.toVector(value, 0);
  }
};
if (true) {
  Object.assign(commonConfigResolver, {
    domTarget(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
      }
      return NaN;
    },
    lockDirection(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
      }
      return NaN;
    },
    initial(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
      }
      return NaN;
    }
  });
}
var DEFAULT_AXIS_THRESHOLD = 0;
var coordinatesConfigResolver = _objectSpread22(_objectSpread22({}, commonConfigResolver), {}, {
  axis(_v, _k, {
    axis
  }) {
    this.lockDirection = axis === "lock";
    if (!this.lockDirection) return axis;
  },
  axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
    return value;
  },
  bounds(value = {}) {
    if (typeof value === "function") {
      return (state) => coordinatesConfigResolver.bounds(value(state));
    }
    if ("current" in value) {
      return () => value.current;
    }
    if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
      return value;
    }
    const {
      left = -Infinity,
      right = Infinity,
      top = -Infinity,
      bottom = Infinity
    } = value;
    return [[left, right], [top, bottom]];
  }
});
var KEYS_DELTA_MAP = {
  ArrowRight: (displacement, factor = 1) => [displacement * factor, 0],
  ArrowLeft: (displacement, factor = 1) => [-1 * displacement * factor, 0],
  ArrowUp: (displacement, factor = 1) => [0, -1 * displacement * factor],
  ArrowDown: (displacement, factor = 1) => [0, displacement * factor]
};
var DragEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty2(this, "ingKey", "dragging");
  }
  reset() {
    super.reset();
    const state = this.state;
    state._pointerId = void 0;
    state._pointerActive = false;
    state._keyboardActive = false;
    state._preventScroll = false;
    state._delayed = false;
    state.swipe = [0, 0];
    state.tap = false;
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
  }
  setup() {
    const state = this.state;
    if (state._bounds instanceof HTMLElement) {
      const boundRect = state._bounds.getBoundingClientRect();
      const targetRect = state.currentTarget.getBoundingClientRect();
      const _bounds = {
        left: boundRect.left - targetRect.left + state.offset[0],
        right: boundRect.right - targetRect.right + state.offset[0],
        top: boundRect.top - targetRect.top + state.offset[1],
        bottom: boundRect.bottom - targetRect.bottom + state.offset[1]
      };
      state._bounds = coordinatesConfigResolver.bounds(_bounds);
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    state.canceled = true;
    state._active = false;
    setTimeout(() => {
      this.compute();
      this.emit();
    }, 0);
  }
  setActive() {
    this.state._active = this.state._pointerActive || this.state._keyboardActive;
  }
  clean() {
    this.pointerClean();
    this.state._pointerActive = false;
    this.state._keyboardActive = false;
    super.clean();
  }
  pointerDown(event) {
    const config2 = this.config;
    const state = this.state;
    if (event.buttons != null && (Array.isArray(config2.pointerButtons) ? !config2.pointerButtons.includes(event.buttons) : config2.pointerButtons !== -1 && config2.pointerButtons !== event.buttons)) return;
    const ctrlIds = this.ctrl.setEventIds(event);
    if (config2.pointerCapture) {
      event.target.setPointerCapture(event.pointerId);
    }
    if (ctrlIds && ctrlIds.size > 1 && state._pointerActive) return;
    this.start(event);
    this.setupPointer(event);
    state._pointerId = pointerId(event);
    state._pointerActive = true;
    this.computeValues(pointerValues(event));
    this.computeInitial();
    if (config2.preventScrollAxis && getPointerType(event) !== "mouse") {
      state._active = false;
      this.setupScrollPrevention(event);
    } else if (config2.delay > 0) {
      this.setupDelayTrigger(event);
      if (config2.triggerAllEvents) {
        this.compute(event);
        this.emit();
      }
    } else {
      this.startPointerDrag(event);
    }
  }
  startPointerDrag(event) {
    const state = this.state;
    state._active = true;
    state._preventScroll = true;
    state._delayed = false;
    this.compute(event);
    this.emit();
  }
  pointerMove(event) {
    const state = this.state;
    const config2 = this.config;
    if (!state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    const _values = pointerValues(event);
    if (document.pointerLockElement === event.target) {
      state._delta = [event.movementX, event.movementY];
    } else {
      state._delta = V.sub(_values, state._values);
      this.computeValues(_values);
    }
    V.addTo(state._movement, state._delta);
    this.compute(event);
    if (state._delayed && state.intentional) {
      this.timeoutStore.remove("dragDelay");
      state.active = false;
      this.startPointerDrag(event);
      return;
    }
    if (config2.preventScrollAxis && !state._preventScroll) {
      if (state.axis) {
        if (state.axis === config2.preventScrollAxis || config2.preventScrollAxis === "xy") {
          state._active = false;
          this.clean();
          return;
        } else {
          this.timeoutStore.remove("startPointerDrag");
          this.startPointerDrag(event);
          return;
        }
      } else {
        return;
      }
    }
    this.emit();
  }
  pointerUp(event) {
    this.ctrl.setEventIds(event);
    try {
      if (this.config.pointerCapture && event.target.hasPointerCapture(event.pointerId)) {
        ;
        event.target.releasePointerCapture(event.pointerId);
      }
    } catch (_unused) {
      if (true) {
        console.warn(`[@use-gesture]: If you see this message, it's likely that you're using an outdated version of \`@react-three/fiber\`. 

Please upgrade to the latest version.`);
      }
    }
    const state = this.state;
    const config2 = this.config;
    if (!state._active || !state._pointerActive) return;
    const id = pointerId(event);
    if (state._pointerId !== void 0 && id !== state._pointerId) return;
    this.state._pointerActive = false;
    this.setActive();
    this.compute(event);
    const [dx, dy] = state._distance;
    state.tap = dx <= config2.tapsThreshold && dy <= config2.tapsThreshold;
    if (state.tap && config2.filterTaps) {
      state._force = true;
    } else {
      const [_dx, _dy] = state._delta;
      const [_mx, _my] = state._movement;
      const [svx, svy] = config2.swipe.velocity;
      const [sx, sy] = config2.swipe.distance;
      const sdt = config2.swipe.duration;
      if (state.elapsedTime < sdt) {
        const _vx = Math.abs(_dx / state.timeDelta);
        const _vy = Math.abs(_dy / state.timeDelta);
        if (_vx > svx && Math.abs(_mx) > sx) state.swipe[0] = Math.sign(_dx);
        if (_vy > svy && Math.abs(_my) > sy) state.swipe[1] = Math.sign(_dy);
      }
    }
    this.emit();
  }
  pointerClick(event) {
    if (!this.state.tap && event.detail > 0) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  setupPointer(event) {
    const config2 = this.config;
    const device = config2.device;
    if (true) {
      try {
        if (device === "pointer" && config2.preventScrollDelay === void 0) {
          const currentTarget = "uv" in event ? event.sourceEvent.currentTarget : event.currentTarget;
          const style = window.getComputedStyle(currentTarget);
          if (style.touchAction === "auto") {
            console.warn(`[@use-gesture]: The drag target has its \`touch-action\` style property set to \`auto\`. It is recommended to add \`touch-action: 'none'\` so that the drag gesture behaves correctly on touch-enabled devices. For more information read this: https://use-gesture.netlify.app/docs/extras/#touch-action.

This message will only show in development mode. It won't appear in production. If this is intended, you can ignore it.`, currentTarget);
          }
        }
      } catch (_unused2) {
      }
    }
    if (config2.pointerLock) {
      event.currentTarget.requestPointerLock();
    }
    if (!config2.pointerCapture) {
      this.eventStore.add(this.sharedConfig.window, device, "change", this.pointerMove.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "end", this.pointerUp.bind(this));
      this.eventStore.add(this.sharedConfig.window, device, "cancel", this.pointerUp.bind(this));
    }
  }
  pointerClean() {
    if (this.config.pointerLock && document.pointerLockElement === this.state.currentTarget) {
      document.exitPointerLock();
    }
  }
  preventScroll(event) {
    if (this.state._preventScroll && event.cancelable) {
      event.preventDefault();
    }
  }
  setupScrollPrevention(event) {
    this.state._preventScroll = false;
    persistEvent(event);
    const remove = this.eventStore.add(this.sharedConfig.window, "touch", "change", this.preventScroll.bind(this), {
      passive: false
    });
    this.eventStore.add(this.sharedConfig.window, "touch", "end", remove);
    this.eventStore.add(this.sharedConfig.window, "touch", "cancel", remove);
    this.timeoutStore.add("startPointerDrag", this.startPointerDrag.bind(this), this.config.preventScrollDelay, event);
  }
  setupDelayTrigger(event) {
    this.state._delayed = true;
    this.timeoutStore.add("dragDelay", () => {
      this.state._step = [0, 0];
      this.startPointerDrag(event);
    }, this.config.delay);
  }
  keyDown(event) {
    const deltaFn = KEYS_DELTA_MAP[event.key];
    if (deltaFn) {
      const state = this.state;
      const factor = event.shiftKey ? 10 : event.altKey ? 0.1 : 1;
      this.start(event);
      state._delta = deltaFn(this.config.keyboardDisplacement, factor);
      state._keyboardActive = true;
      V.addTo(state._movement, state._delta);
      this.compute(event);
      this.emit();
    }
  }
  keyUp(event) {
    if (!(event.key in KEYS_DELTA_MAP)) return;
    this.state._keyboardActive = false;
    this.setActive();
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    bindFunction(device, "start", this.pointerDown.bind(this));
    if (this.config.pointerCapture) {
      bindFunction(device, "change", this.pointerMove.bind(this));
      bindFunction(device, "end", this.pointerUp.bind(this));
      bindFunction(device, "cancel", this.pointerUp.bind(this));
      bindFunction("lostPointerCapture", "", this.pointerUp.bind(this));
    }
    if (this.config.keys) {
      bindFunction("key", "down", this.keyDown.bind(this));
      bindFunction("key", "up", this.keyUp.bind(this));
    }
    if (this.config.filterTaps) {
      bindFunction("click", "", this.pointerClick.bind(this), {
        capture: true,
        passive: false
      });
    }
  }
};
function persistEvent(event) {
  "persist" in event && typeof event.persist === "function" && event.persist();
}
var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
function supportsTouchEvents() {
  return isBrowser && "ontouchstart" in window;
}
function isTouchScreen() {
  return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
}
function supportsPointerEvents() {
  return isBrowser && "onpointerdown" in window;
}
function supportsPointerLock() {
  return isBrowser && "exitPointerLock" in window.document;
}
function supportsGestureEvents() {
  try {
    return "constructor" in GestureEvent;
  } catch (e) {
    return false;
  }
}
var SUPPORT = {
  isBrowser,
  gesture: supportsGestureEvents(),
  touch: supportsTouchEvents(),
  touchscreen: isTouchScreen(),
  pointer: supportsPointerEvents(),
  pointerLock: supportsPointerLock()
};
var DEFAULT_PREVENT_SCROLL_DELAY = 250;
var DEFAULT_DRAG_DELAY = 180;
var DEFAULT_SWIPE_VELOCITY = 0.5;
var DEFAULT_SWIPE_DISTANCE = 50;
var DEFAULT_SWIPE_DURATION = 250;
var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
var DEFAULT_DRAG_AXIS_THRESHOLD = {
  mouse: 0,
  touch: 0,
  pen: 8
};
var dragConfigResolver = _objectSpread22(_objectSpread22({}, coordinatesConfigResolver), {}, {
  device(_v, _k, {
    pointer: {
      touch = false,
      lock = false,
      mouse = false
    } = {}
  }) {
    this.pointerLock = lock && SUPPORT.pointerLock;
    if (SUPPORT.touch && touch) return "touch";
    if (this.pointerLock) return "mouse";
    if (SUPPORT.pointer && !mouse) return "pointer";
    if (SUPPORT.touch) return "touch";
    return "mouse";
  },
  preventScrollAxis(value, _k, {
    preventScroll
  }) {
    this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
    if (!SUPPORT.touchscreen || preventScroll === false) return void 0;
    return value ? value : preventScroll !== void 0 ? "y" : void 0;
  },
  pointerCapture(_v, _k, {
    pointer: {
      capture = true,
      buttons = 1,
      keys = true
    } = {}
  }) {
    this.pointerButtons = buttons;
    this.keys = keys;
    return !this.pointerLock && this.device === "pointer" && capture;
  },
  threshold(value, _k, {
    filterTaps = false,
    tapsThreshold = 3,
    axis = void 0
  }) {
    const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
    this.filterTaps = filterTaps;
    this.tapsThreshold = tapsThreshold;
    return threshold;
  },
  swipe({
    velocity = DEFAULT_SWIPE_VELOCITY,
    distance = DEFAULT_SWIPE_DISTANCE,
    duration = DEFAULT_SWIPE_DURATION
  } = {}) {
    return {
      velocity: this.transform(V.toVector(velocity)),
      distance: this.transform(V.toVector(distance)),
      duration
    };
  },
  delay(value = 0) {
    switch (value) {
      case true:
        return DEFAULT_DRAG_DELAY;
      case false:
        return 0;
      default:
        return value;
    }
  },
  axisThreshold(value) {
    if (!value) return DEFAULT_DRAG_AXIS_THRESHOLD;
    return _objectSpread22(_objectSpread22({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
  },
  keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
    return value;
  }
});
if (true) {
  Object.assign(dragConfigResolver, {
    useTouch(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
      }
      return NaN;
    },
    experimental_preventWindowScrollY(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
      }
      return NaN;
    },
    swipeVelocity(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
      }
      return NaN;
    },
    swipeDistance(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
      }
      return NaN;
    },
    swipeDuration(value) {
      if (value !== void 0) {
        throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
      }
      return NaN;
    }
  });
}
function clampStateInternalMovementToBounds(state) {
  const [ox, oy] = state.overflow;
  const [dx, dy] = state._delta;
  const [dirx, diry] = state._direction;
  if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
    state._movement[0] = state._movementBound[0];
  }
  if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
    state._movement[1] = state._movementBound[1];
  }
}
var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
var PINCH_WHEEL_RATIO = 100;
var PinchEngine = class extends Engine {
  constructor(...args) {
    super(...args);
    _defineProperty2(this, "ingKey", "pinching");
    _defineProperty2(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0];
    this.state.lastOffset = [1, 0];
    this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const state = this.state;
    state._touchIds = [];
    state.canceled = false;
    state.cancel = this.cancel.bind(this);
    state.turns = 0;
  }
  computeOffset() {
    const {
      type,
      movement,
      lastOffset
    } = this.state;
    if (type === "wheel") {
      this.state.offset = V.add(movement, lastOffset);
    } else {
      this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
    }
  }
  computeMovement() {
    const {
      offset,
      lastOffset
    } = this.state;
    this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
  }
  axisIntent() {
    const state = this.state;
    const [_m0, _m1] = state._movement;
    if (!state.axis) {
      const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
      if (axisMovementDifference < 0) state.axis = "angle";
      else if (axisMovementDifference > 0) state.axis = "scale";
    }
  }
  restrictToAxis(v) {
    if (this.config.lockDirection) {
      if (this.state.axis === "scale") v[1] = 0;
      else if (this.state.axis === "angle") v[0] = 0;
    }
  }
  cancel() {
    const state = this.state;
    if (state.canceled) return;
    setTimeout(() => {
      state.canceled = true;
      state._active = false;
      this.compute();
      this.emit();
    }, 0);
  }
  touchStart(event) {
    this.ctrl.setEventIds(event);
    const state = this.state;
    const ctrlTouchIds = this.ctrl.touchIds;
    if (state._active) {
      if (state._touchIds.every((id) => ctrlTouchIds.has(id))) return;
    }
    if (ctrlTouchIds.size < 2) return;
    this.start(event);
    state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
    const payload = touchDistanceAngle(event, state._touchIds);
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pointerStart(event) {
    if (event.buttons != null && event.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(event);
    event.target.setPointerCapture(event.pointerId);
    const state = this.state;
    const _pointerEvents = state._pointerEvents;
    const ctrlPointerIds = this.ctrl.pointerIds;
    if (state._active) {
      if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id))) return;
    }
    if (_pointerEvents.size < 2) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (state._pointerEvents.size < 2) return;
    this.start(event);
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchStart(event, payload);
  }
  pinchStart(event, payload) {
    const state = this.state;
    state.origin = payload.origin;
    this.computeValues([payload.distance, payload.angle]);
    this.computeInitial();
    this.compute(event);
    this.emit();
  }
  touchMove(event) {
    if (!this.state._active) return;
    const payload = touchDistanceAngle(event, this.state._touchIds);
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pointerMove(event) {
    const _pointerEvents = this.state._pointerEvents;
    if (_pointerEvents.has(event.pointerId)) {
      _pointerEvents.set(event.pointerId, event);
    }
    if (!this.state._active) return;
    const payload = distanceAngle(...Array.from(_pointerEvents.values()));
    if (!payload) return;
    this.pinchMove(event, payload);
  }
  pinchMove(event, payload) {
    const state = this.state;
    const prev_a = state._values[1];
    const delta_a = payload.angle - prev_a;
    let delta_turns = 0;
    if (Math.abs(delta_a) > 270) delta_turns += Math.sign(delta_a);
    this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
    state.origin = payload.origin;
    state.turns = delta_turns;
    state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
    this.compute(event);
    this.emit();
  }
  touchEnd(event) {
    this.ctrl.setEventIds(event);
    if (!this.state._active) return;
    if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  pointerEnd(event) {
    const state = this.state;
    this.ctrl.setEventIds(event);
    try {
      event.target.releasePointerCapture(event.pointerId);
    } catch (_unused) {
    }
    if (state._pointerEvents.has(event.pointerId)) {
      state._pointerEvents.delete(event.pointerId);
    }
    if (!state._active) return;
    if (state._pointerEvents.size < 2) {
      state._active = false;
      this.compute(event);
      this.emit();
    }
  }
  gestureStart(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    if (state._active) return;
    this.start(event);
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  gestureMove(event) {
    if (event.cancelable) event.preventDefault();
    if (!this.state._active) return;
    const state = this.state;
    this.computeValues([event.scale, event.rotation]);
    state.origin = [event.clientX, event.clientY];
    const _previousMovement = state._movement;
    state._movement = [event.scale - 1, event.rotation];
    state._delta = V.sub(state._movement, _previousMovement);
    this.compute(event);
    this.emit();
  }
  gestureEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  wheel(event) {
    const modifierKey = this.config.modifierKey;
    if (modifierKey && (Array.isArray(modifierKey) ? !modifierKey.find((k) => event[k]) : !event[modifierKey])) return;
    if (!this.state._active) this.wheelStart(event);
    else this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelStart(event) {
    this.start(event);
    this.wheelChange(event);
  }
  wheelChange(event) {
    const isR3f = "uv" in event;
    if (!isR3f) {
      if (event.cancelable) {
        event.preventDefault();
      }
      if (!event.defaultPrevented) {
        console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
      }
    }
    const state = this.state;
    state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.state.origin = [event.clientX, event.clientY];
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    const device = this.config.device;
    if (!!device) {
      bindFunction(device, "start", this[device + "Start"].bind(this));
      bindFunction(device, "change", this[device + "Move"].bind(this));
      bindFunction(device, "end", this[device + "End"].bind(this));
      bindFunction(device, "cancel", this[device + "End"].bind(this));
      bindFunction("lostPointerCapture", "", this[device + "End"].bind(this));
    }
    if (this.config.pinchOnWheel) {
      bindFunction("wheel", "", this.wheel.bind(this), {
        passive: false
      });
    }
  }
};
var pinchConfigResolver = _objectSpread22(_objectSpread22({}, commonConfigResolver), {}, {
  device(_v, _k, {
    shared,
    pointer: {
      touch = false
    } = {}
  }) {
    const sharedConfig = shared;
    if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture) return "gesture";
    if (SUPPORT.touch && touch) return "touch";
    if (SUPPORT.touchscreen) {
      if (SUPPORT.pointer) return "pointer";
      if (SUPPORT.touch) return "touch";
    }
  },
  bounds(_v, _k, {
    scaleBounds = {},
    angleBounds = {}
  }) {
    const _scaleBounds = (state) => {
      const D = assignDefault(call(scaleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [D.min, D.max];
    };
    const _angleBounds = (state) => {
      const A = assignDefault(call(angleBounds, state), {
        min: -Infinity,
        max: Infinity
      });
      return [A.min, A.max];
    };
    if (typeof scaleBounds !== "function" && typeof angleBounds !== "function") return [_scaleBounds(), _angleBounds()];
    return (state) => [_scaleBounds(state), _angleBounds(state)];
  },
  threshold(value, _k, config2) {
    this.lockDirection = config2.axis === "lock";
    const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
    return threshold;
  },
  modifierKey(value) {
    if (value === void 0) return "ctrlKey";
    return value;
  },
  pinchOnWheel(value = true) {
    return value;
  }
});
var MoveEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty2(this, "ingKey", "moving");
  }
  move(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    if (!this.state._active) this.moveStart(event);
    else this.moveChange(event);
    this.timeoutStore.add("moveEnd", this.moveEnd.bind(this));
  }
  moveStart(event) {
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.computeInitial();
    this.emit();
  }
  moveChange(event) {
    if (!this.state._active) return;
    const values2 = pointerValues(event);
    const state = this.state;
    state._delta = V.sub(values2, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values2);
    this.compute(event);
    this.emit();
  }
  moveEnd(event) {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute(event);
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "change", this.move.bind(this));
    bindFunction("pointer", "leave", this.moveEnd.bind(this));
  }
};
var moveConfigResolver = _objectSpread22(_objectSpread22({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var ScrollEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty2(this, "ingKey", "scrolling");
  }
  scroll(event) {
    if (!this.state._active) this.start(event);
    this.scrollChange(event);
    this.timeoutStore.add("scrollEnd", this.scrollEnd.bind(this));
  }
  scrollChange(event) {
    if (event.cancelable) event.preventDefault();
    const state = this.state;
    const values2 = scrollValues(event);
    state._delta = V.sub(values2, state._values);
    V.addTo(state._movement, state._delta);
    this.computeValues(values2);
    this.compute(event);
    this.emit();
  }
  scrollEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("scroll", "", this.scroll.bind(this));
  }
};
var scrollConfigResolver = coordinatesConfigResolver;
var WheelEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty2(this, "ingKey", "wheeling");
  }
  wheel(event) {
    if (!this.state._active) this.start(event);
    this.wheelChange(event);
    this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(event) {
    const state = this.state;
    state._delta = wheelValues(event);
    V.addTo(state._movement, state._delta);
    clampStateInternalMovementToBounds(state);
    this.compute(event);
    this.emit();
  }
  wheelEnd() {
    if (!this.state._active) return;
    this.state._active = false;
    this.compute();
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("wheel", "", this.wheel.bind(this));
  }
};
var wheelConfigResolver = coordinatesConfigResolver;
var HoverEngine = class extends CoordinatesEngine {
  constructor(...args) {
    super(...args);
    _defineProperty2(this, "ingKey", "hovering");
  }
  enter(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    this.start(event);
    this.computeValues(pointerValues(event));
    this.compute(event);
    this.emit();
  }
  leave(event) {
    if (this.config.mouseOnly && event.pointerType !== "mouse") return;
    const state = this.state;
    if (!state._active) return;
    state._active = false;
    const values2 = pointerValues(event);
    state._movement = state._delta = V.sub(values2, state._values);
    this.computeValues(values2);
    this.compute(event);
    state.delta = state.movement;
    this.emit();
  }
  bind(bindFunction) {
    bindFunction("pointer", "enter", this.enter.bind(this));
    bindFunction("pointer", "leave", this.leave.bind(this));
  }
};
var hoverConfigResolver = _objectSpread22(_objectSpread22({}, coordinatesConfigResolver), {}, {
  mouseOnly: (value = true) => value
});
var EngineMap = /* @__PURE__ */ new Map();
var ConfigResolverMap = /* @__PURE__ */ new Map();
function registerAction(action) {
  EngineMap.set(action.key, action.engine);
  ConfigResolverMap.set(action.key, action.resolver);
}
var dragAction = {
  key: "drag",
  engine: DragEngine,
  resolver: dragConfigResolver
};
var hoverAction = {
  key: "hover",
  engine: HoverEngine,
  resolver: hoverConfigResolver
};
var moveAction = {
  key: "move",
  engine: MoveEngine,
  resolver: moveConfigResolver
};
var pinchAction = {
  key: "pinch",
  engine: PinchEngine,
  resolver: pinchConfigResolver
};
var scrollAction = {
  key: "scroll",
  engine: ScrollEngine,
  resolver: scrollConfigResolver
};
var wheelAction = {
  key: "wheel",
  engine: WheelEngine,
  resolver: wheelConfigResolver
};

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
var import_react38 = __toESM(require_react());

// node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var sharedConfigResolver = {
  target(value) {
    if (value) {
      return () => "current" in value ? value.current : value;
    }
    return void 0;
  },
  enabled(value = true) {
    return value;
  },
  window(value = SUPPORT.isBrowser ? window : void 0) {
    return value;
  },
  eventOptions({
    passive = true,
    capture = false
  } = {}) {
    return {
      passive,
      capture
    };
  },
  transform(value) {
    return value;
  }
};
var _excluded15 = ["target", "eventOptions", "window", "enabled", "transform"];
function resolveWith(config2 = {}, resolvers) {
  const result = {};
  for (const [key, resolver] of Object.entries(resolvers)) {
    switch (typeof resolver) {
      case "function":
        if (true) {
          const r2 = resolver.call(result, config2[key], key, config2);
          if (!Number.isNaN(r2)) result[key] = r2;
        } else {
          result[key] = resolver.call(result, config2[key], key, config2);
        }
        break;
      case "object":
        result[key] = resolveWith(config2[key], resolver);
        break;
      case "boolean":
        if (resolver) result[key] = config2[key];
        break;
    }
  }
  return result;
}
function parse(newConfig, gestureKey, _config = {}) {
  const _ref = newConfig, {
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  } = _ref, rest = _objectWithoutProperties(_ref, _excluded15);
  _config.shared = resolveWith({
    target,
    eventOptions,
    window: window2,
    enabled,
    transform
  }, sharedConfigResolver);
  if (gestureKey) {
    const resolver = ConfigResolverMap.get(gestureKey);
    _config[gestureKey] = resolveWith(_objectSpread22({
      shared: _config.shared
    }, rest), resolver);
  } else {
    for (const key in rest) {
      const resolver = ConfigResolverMap.get(key);
      if (resolver) {
        _config[key] = resolveWith(_objectSpread22({
          shared: _config.shared
        }, rest[key]), resolver);
      } else if (true) {
        if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
          if (key === "domTarget") {
            throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
          }
          console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
        }
      }
    }
  }
  return _config;
}
var EventStore = class {
  constructor(ctrl, gestureKey) {
    _defineProperty2(this, "_listeners", /* @__PURE__ */ new Set());
    this._ctrl = ctrl;
    this._gestureKey = gestureKey;
  }
  add(element, device, action, handler, options) {
    const listeners = this._listeners;
    const type = toDomEventType(device, action);
    const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
    const eventOptions = _objectSpread22(_objectSpread22({}, _options), options);
    element.addEventListener(type, handler, eventOptions);
    const remove = () => {
      element.removeEventListener(type, handler, eventOptions);
      listeners.delete(remove);
    };
    listeners.add(remove);
    return remove;
  }
  clean() {
    this._listeners.forEach((remove) => remove());
    this._listeners.clear();
  }
};
var TimeoutStore = class {
  constructor() {
    _defineProperty2(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(key, callback, ms = 140, ...args) {
    this.remove(key);
    this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
  }
  remove(key) {
    const timeout2 = this._timeouts.get(key);
    if (timeout2) window.clearTimeout(timeout2);
  }
  clean() {
    this._timeouts.forEach((timeout2) => void window.clearTimeout(timeout2));
    this._timeouts.clear();
  }
};
var Controller = class {
  constructor(handlers) {
    _defineProperty2(this, "gestures", /* @__PURE__ */ new Set());
    _defineProperty2(this, "_targetEventStore", new EventStore(this));
    _defineProperty2(this, "gestureEventStores", {});
    _defineProperty2(this, "gestureTimeoutStores", {});
    _defineProperty2(this, "handlers", {});
    _defineProperty2(this, "config", {});
    _defineProperty2(this, "pointerIds", /* @__PURE__ */ new Set());
    _defineProperty2(this, "touchIds", /* @__PURE__ */ new Set());
    _defineProperty2(this, "state", {
      shared: {
        shiftKey: false,
        metaKey: false,
        ctrlKey: false,
        altKey: false
      }
    });
    resolveGestures(this, handlers);
  }
  setEventIds(event) {
    if (isTouch(event)) {
      this.touchIds = new Set(touchIds(event));
      return this.touchIds;
    } else if ("pointerId" in event) {
      if (event.type === "pointerup" || event.type === "pointercancel") this.pointerIds.delete(event.pointerId);
      else if (event.type === "pointerdown") this.pointerIds.add(event.pointerId);
      return this.pointerIds;
    }
  }
  applyHandlers(handlers, nativeHandlers) {
    this.handlers = handlers;
    this.nativeHandlers = nativeHandlers;
  }
  applyConfig(config2, gestureKey) {
    this.config = parse(config2, gestureKey, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const key of this.gestures) {
      this.gestureEventStores[key].clean();
      this.gestureTimeoutStores[key].clean();
    }
  }
  effect() {
    if (this.config.shared.target) this.bind();
    return () => this._targetEventStore.clean();
  }
  bind(...args) {
    const sharedConfig = this.config.shared;
    const props = {};
    let target;
    if (sharedConfig.target) {
      target = sharedConfig.target();
      if (!target) return;
    }
    if (sharedConfig.enabled) {
      for (const gestureKey of this.gestures) {
        const gestureConfig = this.config[gestureKey];
        const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
        if (gestureConfig.enabled) {
          const Engine2 = EngineMap.get(gestureKey);
          new Engine2(this, args, gestureKey).bind(bindFunction);
        }
      }
      const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
      for (const eventKey in this.nativeHandlers) {
        nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread22(_objectSpread22({}, this.state.shared), {}, {
          event,
          args
        })), void 0, true);
      }
    }
    for (const handlerProp in props) {
      props[handlerProp] = chain(...props[handlerProp]);
    }
    if (!target) return props;
    for (const handlerProp in props) {
      const {
        device,
        capture,
        passive
      } = parseProp(handlerProp);
      this._targetEventStore.add(target, device, "", props[handlerProp], {
        capture,
        passive
      });
    }
  }
};
function setupGesture(ctrl, gestureKey) {
  ctrl.gestures.add(gestureKey);
  ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
  ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
}
function resolveGestures(ctrl, internalHandlers) {
  if (internalHandlers.drag) setupGesture(ctrl, "drag");
  if (internalHandlers.wheel) setupGesture(ctrl, "wheel");
  if (internalHandlers.scroll) setupGesture(ctrl, "scroll");
  if (internalHandlers.move) setupGesture(ctrl, "move");
  if (internalHandlers.pinch) setupGesture(ctrl, "pinch");
  if (internalHandlers.hover) setupGesture(ctrl, "hover");
}
var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
  var _options$capture, _options$passive;
  const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
  const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
  let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
  if (withPassiveOption && passive) handlerProp += "Passive";
  props[handlerProp] = props[handlerProp] || [];
  props[handlerProp].push(handler);
};
var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function sortHandlers(_handlers) {
  const native = {};
  const handlers = {};
  const actions = /* @__PURE__ */ new Set();
  for (let key in _handlers) {
    if (RE_NOT_NATIVE.test(key)) {
      actions.add(RegExp.lastMatch);
      handlers[key] = _handlers[key];
    } else {
      native[key] = _handlers[key];
    }
  }
  return [handlers, native, actions];
}
function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config2) {
  if (!actions.has(handlerKey)) return;
  if (!EngineMap.has(key)) {
    if (true) {
      console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
    }
    return;
  }
  const startKey = handlerKey + "Start";
  const endKey = handlerKey + "End";
  const fn = (state) => {
    let memo = void 0;
    if (state.first && startKey in handlers) handlers[startKey](state);
    if (handlerKey in handlers) memo = handlers[handlerKey](state);
    if (state.last && endKey in handlers) handlers[endKey](state);
    return memo;
  };
  internalHandlers[key] = fn;
  config2[key] = config2[key] || {};
}
function parseMergedHandlers(mergedHandlers, mergedConfig) {
  const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
  const internalHandlers = {};
  registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
  registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
  return {
    handlers: internalHandlers,
    config: mergedConfig,
    nativeHandlers
  };
}

// node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
function useRecognizers(handlers, config2 = {}, gestureKey, nativeHandlers) {
  const ctrl = import_react38.default.useMemo(() => new Controller(handlers), []);
  ctrl.applyHandlers(handlers, nativeHandlers);
  ctrl.applyConfig(config2, gestureKey);
  import_react38.default.useEffect(ctrl.effect.bind(ctrl));
  import_react38.default.useEffect(() => {
    return ctrl.clean.bind(ctrl);
  }, []);
  if (config2.target === void 0) {
    return ctrl.bind.bind(ctrl);
  }
  return void 0;
}
function useDrag(handler, config2) {
  registerAction(dragAction);
  return useRecognizers({
    drag: handler
  }, config2 || {}, "drag");
}
function createUseGesture(actions) {
  actions.forEach(registerAction);
  return function useGesture2(_handlers, _config) {
    const {
      handlers,
      nativeHandlers,
      config: config2
    } = parseMergedHandlers(_handlers, _config || {});
    return useRecognizers(handlers, config2, void 0, nativeHandlers);
  };
}
function useGesture(handlers, config2) {
  const hook = createUseGesture([dragAction, pinchAction, scrollAction, wheelAction, moveAction, hoverAction]);
  return hook(handlers, config2 || {});
}

// node_modules/@react-spring/rafz/dist/react-spring-rafz.esm.js
var updateQueue = makeQueue();
var raf = (fn) => schedule(fn, updateQueue);
var writeQueue = makeQueue();
raf.write = (fn) => schedule(fn, writeQueue);
var onStartQueue = makeQueue();
raf.onStart = (fn) => schedule(fn, onStartQueue);
var onFrameQueue = makeQueue();
raf.onFrame = (fn) => schedule(fn, onFrameQueue);
var onFinishQueue = makeQueue();
raf.onFinish = (fn) => schedule(fn, onFinishQueue);
var timeouts = [];
raf.setTimeout = (handler, ms) => {
  let time = raf.now() + ms;
  let cancel = () => {
    let i = timeouts.findIndex((t) => t.cancel == cancel);
    if (~i) timeouts.splice(i, 1);
    pendingCount -= ~i ? 1 : 0;
  };
  let timeout2 = {
    time,
    handler,
    cancel
  };
  timeouts.splice(findTimeout(time), 0, timeout2);
  pendingCount += 1;
  start();
  return timeout2;
};
var findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);
raf.cancel = (fn) => {
  onStartQueue.delete(fn);
  onFrameQueue.delete(fn);
  onFinishQueue.delete(fn);
  updateQueue.delete(fn);
  writeQueue.delete(fn);
};
raf.sync = (fn) => {
  sync = true;
  raf.batchedUpdates(fn);
  sync = false;
};
raf.throttle = (fn) => {
  let lastArgs;
  function queuedFn() {
    try {
      fn(...lastArgs);
    } finally {
      lastArgs = null;
    }
  }
  function throttled(...args) {
    lastArgs = args;
    raf.onStart(queuedFn);
  }
  throttled.handler = fn;
  throttled.cancel = () => {
    onStartQueue.delete(queuedFn);
    lastArgs = null;
  };
  return throttled;
};
var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : () => {
};
raf.use = (impl) => nativeRaf = impl;
raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
raf.batchedUpdates = (fn) => fn();
raf.catch = console.error;
raf.frameLoop = "always";
raf.advance = () => {
  if (raf.frameLoop !== "demand") {
    console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand");
  } else {
    update();
  }
};
var ts = -1;
var pendingCount = 0;
var sync = false;
function schedule(fn, queue) {
  if (sync) {
    queue.delete(fn);
    fn(0);
  } else {
    queue.add(fn);
    start();
  }
}
function start() {
  if (ts < 0) {
    ts = 0;
    if (raf.frameLoop !== "demand") {
      nativeRaf(loop);
    }
  }
}
function stop() {
  ts = -1;
}
function loop() {
  if (~ts) {
    nativeRaf(loop);
    raf.batchedUpdates(update);
  }
}
function update() {
  let prevTs = ts;
  ts = raf.now();
  let count = findTimeout(ts);
  if (count) {
    eachSafely(timeouts.splice(0, count), (t) => t.handler());
    pendingCount -= count;
  }
  if (!pendingCount) {
    stop();
    return;
  }
  onStartQueue.flush();
  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
  onFrameQueue.flush();
  writeQueue.flush();
  onFinishQueue.flush();
}
function makeQueue() {
  let next = /* @__PURE__ */ new Set();
  let current = next;
  return {
    add(fn) {
      pendingCount += current == next && !next.has(fn) ? 1 : 0;
      next.add(fn);
    },
    delete(fn) {
      pendingCount -= current == next && next.has(fn) ? 1 : 0;
      return next.delete(fn);
    },
    flush(arg) {
      if (current.size) {
        next = /* @__PURE__ */ new Set();
        pendingCount -= current.size;
        eachSafely(current, (fn) => fn(arg) && next.add(fn));
        pendingCount += next.size;
        current = next;
      }
    }
  };
}
function eachSafely(values2, each2) {
  values2.forEach((value) => {
    try {
      each2(value);
    } catch (e) {
      raf.catch(e);
    }
  });
}

// node_modules/@react-spring/shared/dist/react-spring-shared.esm.js
var import_react39 = __toESM(require_react());
function noop3() {
}
var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, {
  value,
  writable: true,
  configurable: true
});
var is = {
  arr: Array.isArray,
  obj: (a) => !!a && a.constructor.name === "Object",
  fun: (a) => typeof a === "function",
  str: (a) => typeof a === "string",
  num: (a) => typeof a === "number",
  und: (a) => a === void 0
};
function isEqual(a, b) {
  if (is.arr(a)) {
    if (!is.arr(b) || a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  return a === b;
}
var each = (obj, fn) => obj.forEach(fn);
function eachProp(obj, fn, ctx2) {
  if (is.arr(obj)) {
    for (let i = 0; i < obj.length; i++) {
      fn.call(ctx2, obj[i], `${i}`);
    }
    return;
  }
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn.call(ctx2, obj[key], key);
    }
  }
}
var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
function flush(queue, iterator) {
  if (queue.size) {
    const items = Array.from(queue);
    queue.clear();
    each(items, iterator);
  }
}
var flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));
var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var createStringInterpolator$1;
var to;
var colors$1 = null;
var skipAnimation = false;
var willAdvance = noop3;
var assign = (globals2) => {
  if (globals2.to) to = globals2.to;
  if (globals2.now) raf.now = globals2.now;
  if (globals2.colors !== void 0) colors$1 = globals2.colors;
  if (globals2.skipAnimation != null) skipAnimation = globals2.skipAnimation;
  if (globals2.createStringInterpolator) createStringInterpolator$1 = globals2.createStringInterpolator;
  if (globals2.requestAnimationFrame) raf.use(globals2.requestAnimationFrame);
  if (globals2.batchedUpdates) raf.batchedUpdates = globals2.batchedUpdates;
  if (globals2.willAdvance) willAdvance = globals2.willAdvance;
  if (globals2.frameLoop) raf.frameLoop = globals2.frameLoop;
};
var globals = Object.freeze({
  __proto__: null,
  get createStringInterpolator() {
    return createStringInterpolator$1;
  },
  get to() {
    return to;
  },
  get colors() {
    return colors$1;
  },
  get skipAnimation() {
    return skipAnimation;
  },
  get willAdvance() {
    return willAdvance;
  },
  assign
});
var startQueue = /* @__PURE__ */ new Set();
var currentFrame = [];
var prevFrame = [];
var priority = 0;
var frameLoop = {
  get idle() {
    return !startQueue.size && !currentFrame.length;
  },
  start(animation) {
    if (priority > animation.priority) {
      startQueue.add(animation);
      raf.onStart(flushStartQueue);
    } else {
      startSafely(animation);
      raf(advance);
    }
  },
  advance,
  sort(animation) {
    if (priority) {
      raf.onFrame(() => frameLoop.sort(animation));
    } else {
      const prevIndex = currentFrame.indexOf(animation);
      if (~prevIndex) {
        currentFrame.splice(prevIndex, 1);
        startUnsafely(animation);
      }
    }
  },
  clear() {
    currentFrame = [];
    startQueue.clear();
  }
};
function flushStartQueue() {
  startQueue.forEach(startSafely);
  startQueue.clear();
  raf(advance);
}
function startSafely(animation) {
  if (!currentFrame.includes(animation)) startUnsafely(animation);
}
function startUnsafely(animation) {
  currentFrame.splice(findIndex(currentFrame, (other) => other.priority > animation.priority), 0, animation);
}
function advance(dt) {
  const nextFrame = prevFrame;
  for (let i = 0; i < currentFrame.length; i++) {
    const animation = currentFrame[i];
    priority = animation.priority;
    if (!animation.idle) {
      willAdvance(animation);
      animation.advance(dt);
      if (!animation.idle) {
        nextFrame.push(animation);
      }
    }
  }
  priority = 0;
  prevFrame = currentFrame;
  prevFrame.length = 0;
  currentFrame = nextFrame;
  return currentFrame.length > 0;
}
function findIndex(arr, test) {
  const index2 = arr.findIndex(test);
  return index2 < 0 ? arr.length : index2;
}
var colors = {
  transparent: 0,
  aliceblue: 4042850303,
  antiquewhite: 4209760255,
  aqua: 16777215,
  aquamarine: 2147472639,
  azure: 4043309055,
  beige: 4126530815,
  bisque: 4293182719,
  black: 255,
  blanchedalmond: 4293643775,
  blue: 65535,
  blueviolet: 2318131967,
  brown: 2771004159,
  burlywood: 3736635391,
  burntsienna: 3934150143,
  cadetblue: 1604231423,
  chartreuse: 2147418367,
  chocolate: 3530104575,
  coral: 4286533887,
  cornflowerblue: 1687547391,
  cornsilk: 4294499583,
  crimson: 3692313855,
  cyan: 16777215,
  darkblue: 35839,
  darkcyan: 9145343,
  darkgoldenrod: 3095792639,
  darkgray: 2846468607,
  darkgreen: 6553855,
  darkgrey: 2846468607,
  darkkhaki: 3182914559,
  darkmagenta: 2332068863,
  darkolivegreen: 1433087999,
  darkorange: 4287365375,
  darkorchid: 2570243327,
  darkred: 2332033279,
  darksalmon: 3918953215,
  darkseagreen: 2411499519,
  darkslateblue: 1211993087,
  darkslategray: 793726975,
  darkslategrey: 793726975,
  darkturquoise: 13554175,
  darkviolet: 2483082239,
  deeppink: 4279538687,
  deepskyblue: 12582911,
  dimgray: 1768516095,
  dimgrey: 1768516095,
  dodgerblue: 512819199,
  firebrick: 2988581631,
  floralwhite: 4294635775,
  forestgreen: 579543807,
  fuchsia: 4278255615,
  gainsboro: 3705462015,
  ghostwhite: 4177068031,
  gold: 4292280575,
  goldenrod: 3668254975,
  gray: 2155905279,
  green: 8388863,
  greenyellow: 2919182335,
  grey: 2155905279,
  honeydew: 4043305215,
  hotpink: 4285117695,
  indianred: 3445382399,
  indigo: 1258324735,
  ivory: 4294963455,
  khaki: 4041641215,
  lavender: 3873897215,
  lavenderblush: 4293981695,
  lawngreen: 2096890111,
  lemonchiffon: 4294626815,
  lightblue: 2916673279,
  lightcoral: 4034953471,
  lightcyan: 3774873599,
  lightgoldenrodyellow: 4210742015,
  lightgray: 3553874943,
  lightgreen: 2431553791,
  lightgrey: 3553874943,
  lightpink: 4290167295,
  lightsalmon: 4288707327,
  lightseagreen: 548580095,
  lightskyblue: 2278488831,
  lightslategray: 2005441023,
  lightslategrey: 2005441023,
  lightsteelblue: 2965692159,
  lightyellow: 4294959359,
  lime: 16711935,
  limegreen: 852308735,
  linen: 4210091775,
  magenta: 4278255615,
  maroon: 2147483903,
  mediumaquamarine: 1724754687,
  mediumblue: 52735,
  mediumorchid: 3126187007,
  mediumpurple: 2473647103,
  mediumseagreen: 1018393087,
  mediumslateblue: 2070474495,
  mediumspringgreen: 16423679,
  mediumturquoise: 1221709055,
  mediumvioletred: 3340076543,
  midnightblue: 421097727,
  mintcream: 4127193855,
  mistyrose: 4293190143,
  moccasin: 4293178879,
  navajowhite: 4292783615,
  navy: 33023,
  oldlace: 4260751103,
  olive: 2155872511,
  olivedrab: 1804477439,
  orange: 4289003775,
  orangered: 4282712319,
  orchid: 3664828159,
  palegoldenrod: 4008225535,
  palegreen: 2566625535,
  paleturquoise: 2951671551,
  palevioletred: 3681588223,
  papayawhip: 4293907967,
  peachpuff: 4292524543,
  peru: 3448061951,
  pink: 4290825215,
  plum: 3718307327,
  powderblue: 2967529215,
  purple: 2147516671,
  rebeccapurple: 1714657791,
  red: 4278190335,
  rosybrown: 3163525119,
  royalblue: 1097458175,
  saddlebrown: 2336560127,
  salmon: 4202722047,
  sandybrown: 4104413439,
  seagreen: 780883967,
  seashell: 4294307583,
  sienna: 2689740287,
  silver: 3233857791,
  skyblue: 2278484991,
  slateblue: 1784335871,
  slategray: 1887473919,
  slategrey: 1887473919,
  snow: 4294638335,
  springgreen: 16744447,
  steelblue: 1182971135,
  tan: 3535047935,
  teal: 8421631,
  thistle: 3636451583,
  tomato: 4284696575,
  turquoise: 1088475391,
  violet: 4001558271,
  wheat: 4125012991,
  white: 4294967295,
  whitesmoke: 4126537215,
  yellow: 4294902015,
  yellowgreen: 2597139199
};
var NUMBER = "[-+]?\\d*\\.?\\d+";
var PERCENTAGE = NUMBER + "%";
function call2(...parts) {
  return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
}
var rgb = new RegExp("rgb" + call2(NUMBER, NUMBER, NUMBER));
var rgba = new RegExp("rgba" + call2(NUMBER, NUMBER, NUMBER, NUMBER));
var hsl = new RegExp("hsl" + call2(NUMBER, PERCENTAGE, PERCENTAGE));
var hsla = new RegExp("hsla" + call2(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));
var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
var hex6 = /^#([0-9a-fA-F]{6})$/;
var hex8 = /^#([0-9a-fA-F]{8})$/;
function normalizeColor(color) {
  let match;
  if (typeof color === "number") {
    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;
  }
  if (match = hex6.exec(color)) return parseInt(match[1] + "ff", 16) >>> 0;
  if (colors$1 && colors$1[color] !== void 0) {
    return colors$1[color];
  }
  if (match = rgb.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | 255) >>> 0;
  }
  if (match = rgba.exec(color)) {
    return (parse255(match[1]) << 24 | parse255(match[2]) << 16 | parse255(match[3]) << 8 | parse1(match[4])) >>> 0;
  }
  if (match = hex3.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + "ff", 16) >>> 0;
  }
  if (match = hex8.exec(color)) return parseInt(match[1], 16) >>> 0;
  if (match = hex4.exec(color)) {
    return parseInt(match[1] + match[1] + match[2] + match[2] + match[3] + match[3] + match[4] + match[4], 16) >>> 0;
  }
  if (match = hsl.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | 255) >>> 0;
  }
  if (match = hsla.exec(color)) {
    return (hslToRgb(parse360(match[1]), parsePercentage(match[2]), parsePercentage(match[3])) | parse1(match[4])) >>> 0;
  }
  return null;
}
function hue2rgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslToRgb(h, s, l) {
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r2 = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return Math.round(r2 * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
}
function parse255(str) {
  const int = parseInt(str, 10);
  if (int < 0) return 0;
  if (int > 255) return 255;
  return int;
}
function parse360(str) {
  const int = parseFloat(str);
  return (int % 360 + 360) % 360 / 360;
}
function parse1(str) {
  const num = parseFloat(str);
  if (num < 0) return 0;
  if (num > 1) return 255;
  return Math.round(num * 255);
}
function parsePercentage(str) {
  const int = parseFloat(str);
  if (int < 0) return 0;
  if (int > 100) return 1;
  return int / 100;
}
function colorToRgba(input) {
  let int32Color = normalizeColor(input);
  if (int32Color === null) return input;
  int32Color = int32Color || 0;
  let r2 = (int32Color & 4278190080) >>> 24;
  let g = (int32Color & 16711680) >>> 16;
  let b = (int32Color & 65280) >>> 8;
  let a = (int32Color & 255) / 255;
  return `rgba(${r2}, ${g}, ${b}, ${a})`;
}
var createInterpolator = (range, output, extrapolate) => {
  if (is.fun(range)) {
    return range;
  }
  if (is.arr(range)) {
    return createInterpolator({
      range,
      output,
      extrapolate
    });
  }
  if (is.str(range.output[0])) {
    return createStringInterpolator$1(range);
  }
  const config2 = range;
  const outputRange = config2.output;
  const inputRange = config2.range || [0, 1];
  const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
  const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
  const easing = config2.easing || ((t) => t);
  return (input) => {
    const range2 = findRange(input, inputRange);
    return interpolate(input, inputRange[range2], inputRange[range2 + 1], outputRange[range2], outputRange[range2 + 1], easing, extrapolateLeft, extrapolateRight, config2.map);
  };
};
function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {
  let result = map ? map(input) : input;
  if (result < inputMin) {
    if (extrapolateLeft === "identity") return result;
    else if (extrapolateLeft === "clamp") result = inputMin;
  }
  if (result > inputMax) {
    if (extrapolateRight === "identity") return result;
    else if (extrapolateRight === "clamp") result = inputMax;
  }
  if (outputMin === outputMax) return outputMin;
  if (inputMin === inputMax) return input <= inputMin ? outputMin : outputMax;
  if (inputMin === -Infinity) result = -result;
  else if (inputMax === Infinity) result = result - inputMin;
  else result = (result - inputMin) / (inputMax - inputMin);
  result = easing(result);
  if (outputMin === -Infinity) result = -result;
  else if (outputMax === Infinity) result = result + outputMin;
  else result = result * (outputMax - outputMin) + outputMin;
  return result;
}
function findRange(input, inputRange) {
  for (var i = 1; i < inputRange.length - 1; ++i) if (inputRange[i] >= input) break;
  return i - 1;
}
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var $get = Symbol.for("FluidValue.get");
var $observers = Symbol.for("FluidValue.observers");
var hasFluidValue = (arg) => Boolean(arg && arg[$get]);
var getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;
var getFluidObservers = (target) => target[$observers] || null;
function callFluidObserver(observer, event) {
  if (observer.eventObserved) {
    observer.eventObserved(event);
  } else {
    observer(event);
  }
}
function callFluidObservers(target, event) {
  let observers2 = target[$observers];
  if (observers2) {
    observers2.forEach((observer) => {
      callFluidObserver(observer, event);
    });
  }
}
var FluidValue = class {
  constructor(get) {
    this[$get] = void 0;
    this[$observers] = void 0;
    if (!get && !(get = this.get)) {
      throw Error("Unknown getter");
    }
    setFluidGetter(this, get);
  }
};
var setFluidGetter = (target, get) => setHidden(target, $get, get);
function addFluidObserver(target, observer) {
  if (target[$get]) {
    let observers2 = target[$observers];
    if (!observers2) {
      setHidden(target, $observers, observers2 = /* @__PURE__ */ new Set());
    }
    if (!observers2.has(observer)) {
      observers2.add(observer);
      if (target.observerAdded) {
        target.observerAdded(observers2.size, observer);
      }
    }
  }
  return observer;
}
function removeFluidObserver(target, observer) {
  let observers2 = target[$observers];
  if (observers2 && observers2.has(observer)) {
    const count = observers2.size - 1;
    if (count) {
      observers2.delete(observer);
    } else {
      target[$observers] = null;
    }
    if (target.observerRemoved) {
      target.observerRemoved(count, observer);
    }
  }
}
var setHidden = (target, key, value) => Object.defineProperty(target, key, {
  value,
  writable: true,
  configurable: true
});
var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
var variableToRgba = (input) => {
  const [token, fallback] = parseCSSVariable(input);
  if (!token || isSSR()) {
    return input;
  }
  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);
  if (value) {
    return value.trim();
  } else if (fallback && fallback.startsWith("--")) {
    const _value = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
    if (_value) {
      return _value;
    } else {
      return input;
    }
  } else if (fallback && cssVariableRegex.test(fallback)) {
    return variableToRgba(fallback);
  } else if (fallback) {
    return fallback;
  }
  return input;
};
var parseCSSVariable = (current) => {
  const match = cssVariableRegex.exec(current);
  if (!match) return [,];
  const [, token, fallback] = match;
  return [token, fallback];
};
var namedColorRegex;
var rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
var createStringInterpolator = (config2) => {
  if (!namedColorRegex) namedColorRegex = colors$1 ? new RegExp(`(${Object.keys(colors$1).join("|")})(?!\\w)`, "g") : /^\b$/;
  const output = config2.output.map((value) => {
    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
  });
  const keyframes = output.map((value) => value.match(numberRegex).map(Number));
  const outputRanges = keyframes[0].map((_, i) => keyframes.map((values2) => {
    if (!(i in values2)) {
      throw Error('The arity of each "output" value must be equal');
    }
    return values2[i];
  }));
  const interpolators = outputRanges.map((output2) => createInterpolator(_extends2({}, config2, {
    output: output2
  })));
  return (input) => {
    var _output$find;
    const missingUnit = !unitRegex.test(output[0]) && ((_output$find = output.find((value) => unitRegex.test(value))) == null ? void 0 : _output$find.replace(numberRegex, ""));
    let i = 0;
    return output[0].replace(numberRegex, () => `${interpolators[i++](input)}${missingUnit || ""}`).replace(rgbaRegex, rgbaRound);
  };
};
var prefix = "react-spring: ";
var once = (fn) => {
  const func = fn;
  let called = false;
  if (typeof func != "function") {
    throw new TypeError(`${prefix}once requires a function parameter`);
  }
  return (...args) => {
    if (!called) {
      func(...args);
      called = true;
    }
  };
};
var warnInterpolate = once(console.warn);
function deprecateInterpolate() {
  warnInterpolate(`${prefix}The "interpolate" function is deprecated in v9 (use "to" instead)`);
}
var warnDirectCall = once(console.warn);
function deprecateDirectCall() {
  warnDirectCall(`${prefix}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`);
}
function isAnimatedString(value) {
  return is.str(value) && (value[0] == "#" || /\d/.test(value) || !isSSR() && cssVariableRegex.test(value) || value in (colors$1 || {}));
}
var useIsomorphicLayoutEffect = isSSR() ? import_react39.useEffect : import_react39.useLayoutEffect;
var useIsMounted = () => {
  const isMounted = (0, import_react39.useRef)(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
};
function useForceUpdate() {
  const update3 = (0, import_react39.useState)()[1];
  const isMounted = useIsMounted();
  return () => {
    if (isMounted.current) {
      update3(Math.random());
    }
  };
}
function useMemoOne(getResult, inputs) {
  const [initial] = (0, import_react39.useState)(() => ({
    inputs,
    result: getResult()
  }));
  const committed = (0, import_react39.useRef)();
  const prevCache = committed.current;
  let cache = prevCache;
  if (cache) {
    const useCache = Boolean(inputs && cache.inputs && areInputsEqual(inputs, cache.inputs));
    if (!useCache) {
      cache = {
        inputs,
        result: getResult()
      };
    }
  } else {
    cache = initial;
  }
  (0, import_react39.useEffect)(() => {
    committed.current = cache;
    if (prevCache == initial) {
      initial.inputs = initial.result = void 0;
    }
  }, [cache]);
  return cache.result;
}
function areInputsEqual(next, prev) {
  if (next.length !== prev.length) {
    return false;
  }
  for (let i = 0; i < next.length; i++) {
    if (next[i] !== prev[i]) {
      return false;
    }
  }
  return true;
}
var useOnce = (effect) => (0, import_react39.useEffect)(effect, emptyDeps);
var emptyDeps = [];
function usePrev(value) {
  const prevRef = (0, import_react39.useRef)();
  (0, import_react39.useEffect)(() => {
    prevRef.current = value;
  });
  return prevRef.current;
}

// node_modules/@react-spring/core/dist/react-spring-core.esm.js
var React42 = __toESM(require_react());
var import_react41 = __toESM(require_react());

// node_modules/@react-spring/animated/dist/react-spring-animated.esm.js
var React41 = __toESM(require_react());
var import_react40 = __toESM(require_react());
var $node = Symbol.for("Animated:node");
var isAnimated = (value) => !!value && value[$node] === value;
var getAnimated = (owner) => owner && owner[$node];
var setAnimated = (owner, node) => defineHidden(owner, $node, node);
var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
var Animated = class {
  constructor() {
    this.payload = void 0;
    setAnimated(this, this);
  }
  getPayload() {
    return this.payload || [];
  }
};
var AnimatedValue = class _AnimatedValue extends Animated {
  constructor(_value) {
    super();
    this.done = true;
    this.elapsedTime = void 0;
    this.lastPosition = void 0;
    this.lastVelocity = void 0;
    this.v0 = void 0;
    this.durationProgress = 0;
    this._value = _value;
    if (is.num(this._value)) {
      this.lastPosition = this._value;
    }
  }
  static create(value) {
    return new _AnimatedValue(value);
  }
  getPayload() {
    return [this];
  }
  getValue() {
    return this._value;
  }
  setValue(value, step) {
    if (is.num(value)) {
      this.lastPosition = value;
      if (step) {
        value = Math.round(value / step) * step;
        if (this.done) {
          this.lastPosition = value;
        }
      }
    }
    if (this._value === value) {
      return false;
    }
    this._value = value;
    return true;
  }
  reset() {
    const {
      done
    } = this;
    this.done = false;
    if (is.num(this._value)) {
      this.elapsedTime = 0;
      this.durationProgress = 0;
      this.lastPosition = this._value;
      if (done) this.lastVelocity = null;
      this.v0 = null;
    }
  }
};
var AnimatedString = class _AnimatedString extends AnimatedValue {
  constructor(value) {
    super(0);
    this._string = null;
    this._toString = void 0;
    this._toString = createInterpolator({
      output: [value, value]
    });
  }
  static create(value) {
    return new _AnimatedString(value);
  }
  getValue() {
    let value = this._string;
    return value == null ? this._string = this._toString(this._value) : value;
  }
  setValue(value) {
    if (is.str(value)) {
      if (value == this._string) {
        return false;
      }
      this._string = value;
      this._value = 1;
    } else if (super.setValue(value)) {
      this._string = null;
    } else {
      return false;
    }
    return true;
  }
  reset(goal) {
    if (goal) {
      this._toString = createInterpolator({
        output: [this.getValue(), goal]
      });
    }
    this._value = 0;
    super.reset();
  }
};
var TreeContext = {
  dependencies: null
};
var AnimatedObject = class extends Animated {
  constructor(source) {
    super();
    this.source = source;
    this.setValue(source);
  }
  getValue(animated2) {
    const values2 = {};
    eachProp(this.source, (source, key) => {
      if (isAnimated(source)) {
        values2[key] = source.getValue(animated2);
      } else if (hasFluidValue(source)) {
        values2[key] = getFluidValue(source);
      } else if (!animated2) {
        values2[key] = source;
      }
    });
    return values2;
  }
  setValue(source) {
    this.source = source;
    this.payload = this._makePayload(source);
  }
  reset() {
    if (this.payload) {
      each(this.payload, (node) => node.reset());
    }
  }
  _makePayload(source) {
    if (source) {
      const payload = /* @__PURE__ */ new Set();
      eachProp(source, this._addToPayload, payload);
      return Array.from(payload);
    }
  }
  _addToPayload(source) {
    if (TreeContext.dependencies && hasFluidValue(source)) {
      TreeContext.dependencies.add(source);
    }
    const payload = getPayload(source);
    if (payload) {
      each(payload, (node) => this.add(node));
    }
  }
};
var AnimatedArray = class _AnimatedArray extends AnimatedObject {
  constructor(source) {
    super(source);
  }
  static create(source) {
    return new _AnimatedArray(source);
  }
  getValue() {
    return this.source.map((node) => node.getValue());
  }
  setValue(source) {
    const payload = this.getPayload();
    if (source.length == payload.length) {
      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);
    }
    super.setValue(source.map(makeAnimated));
    return true;
  }
};
function makeAnimated(value) {
  const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
  return nodeType.create(value);
}
function getAnimatedType(value) {
  const parentNode = getAnimated(value);
  return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
}
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var withAnimated = (Component, host2) => {
  const hasInstance = !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent;
  return (0, import_react40.forwardRef)((givenProps, givenRef) => {
    const instanceRef = (0, import_react40.useRef)(null);
    const ref = hasInstance && (0, import_react40.useCallback)((value) => {
      instanceRef.current = updateRef(givenRef, value);
    }, [givenRef]);
    const [props, deps] = getAnimatedState(givenProps, host2);
    const forceUpdate = useForceUpdate();
    const callback = () => {
      const instance = instanceRef.current;
      if (hasInstance && !instance) {
        return;
      }
      const didUpdate = instance ? host2.applyAnimatedValues(instance, props.getValue(true)) : false;
      if (didUpdate === false) {
        forceUpdate();
      }
    };
    const observer = new PropsObserver(callback, deps);
    const observerRef = (0, import_react40.useRef)();
    useIsomorphicLayoutEffect(() => {
      observerRef.current = observer;
      each(deps, (dep) => addFluidObserver(dep, observer));
      return () => {
        if (observerRef.current) {
          each(observerRef.current.deps, (dep) => removeFluidObserver(dep, observerRef.current));
          raf.cancel(observerRef.current.update);
        }
      };
    });
    (0, import_react40.useEffect)(callback, []);
    useOnce(() => () => {
      const observer2 = observerRef.current;
      each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
    });
    const usedProps = host2.getComponentProps(props.getValue());
    return React41.createElement(Component, _extends3({}, usedProps, {
      ref
    }));
  });
};
var PropsObserver = class {
  constructor(update3, deps) {
    this.update = update3;
    this.deps = deps;
  }
  eventObserved(event) {
    if (event.type == "change") {
      raf.write(this.update);
    }
  }
};
function getAnimatedState(props, host2) {
  const dependencies = /* @__PURE__ */ new Set();
  TreeContext.dependencies = dependencies;
  if (props.style) props = _extends3({}, props, {
    style: host2.createAnimatedStyle(props.style)
  });
  props = new AnimatedObject(props);
  TreeContext.dependencies = null;
  return [props, dependencies];
}
function updateRef(ref, value) {
  if (ref) {
    if (is.fun(ref)) ref(value);
    else ref.current = value;
  }
  return value;
}
var cacheKey = Symbol.for("AnimatedComponent");
var createHost = (components, {
  applyAnimatedValues: _applyAnimatedValues = () => false,
  createAnimatedStyle: _createAnimatedStyle = (style) => new AnimatedObject(style),
  getComponentProps: _getComponentProps = (props) => props
} = {}) => {
  const hostConfig = {
    applyAnimatedValues: _applyAnimatedValues,
    createAnimatedStyle: _createAnimatedStyle,
    getComponentProps: _getComponentProps
  };
  const animated2 = (Component) => {
    const displayName = getDisplayName(Component) || "Anonymous";
    if (is.str(Component)) {
      Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
    } else {
      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
    }
    Component.displayName = `Animated(${displayName})`;
    return Component;
  };
  eachProp(components, (Component, key) => {
    if (is.arr(components)) {
      key = getDisplayName(Component);
    }
    animated2[key] = animated2(Component);
  });
  return {
    animated: animated2
  };
};
var getDisplayName = (arg) => is.str(arg) ? arg : arg && is.str(arg.displayName) ? arg.displayName : is.fun(arg) && arg.name || null;

// node_modules/@react-spring/core/dist/react-spring-core.esm.js
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
function callProp(value, ...args) {
  return is.fun(value) ? value(...args) : value;
}
var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
var noopTransform = (value) => value;
var getDefaultProps = (props, transform = noopTransform) => {
  let keys = DEFAULT_PROPS;
  if (props.default && props.default !== true) {
    props = props.default;
    keys = Object.keys(props);
  }
  const defaults2 = {};
  for (const key of keys) {
    const value = transform(props[key], key);
    if (!is.und(value)) {
      defaults2[key] = value;
    }
  }
  return defaults2;
};
var DEFAULT_PROPS = ["config", "onProps", "onStart", "onChange", "onPause", "onResume", "onRest"];
var RESERVED_PROPS = {
  config: 1,
  from: 1,
  to: 1,
  ref: 1,
  loop: 1,
  reset: 1,
  pause: 1,
  cancel: 1,
  reverse: 1,
  immediate: 1,
  default: 1,
  delay: 1,
  onProps: 1,
  onStart: 1,
  onChange: 1,
  onPause: 1,
  onResume: 1,
  onRest: 1,
  onResolve: 1,
  items: 1,
  trail: 1,
  sort: 1,
  expires: 1,
  initial: 1,
  enter: 1,
  update: 1,
  leave: 1,
  children: 1,
  onDestroyed: 1,
  keys: 1,
  callId: 1,
  parentId: 1
};
function getForwardProps(props) {
  const forward = {};
  let count = 0;
  eachProp(props, (value, prop) => {
    if (!RESERVED_PROPS[prop]) {
      forward[prop] = value;
      count++;
    }
  });
  if (count) {
    return forward;
  }
}
function inferTo(props) {
  const to3 = getForwardProps(props);
  if (to3) {
    const out = {
      to: to3
    };
    eachProp(props, (val, key) => key in to3 || (out[key] = val));
    return out;
  }
  return _extends4({}, props);
}
function computeGoal(value) {
  value = getFluidValue(value);
  return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals.createStringInterpolator({
    range: [0, 1],
    output: [value, value]
  })(1) : value;
}
function hasProps(props) {
  for (const _ in props) return true;
  return false;
}
function isAsyncTo(to3) {
  return is.fun(to3) || is.arr(to3) && is.obj(to3[0]);
}
function detachRefs(ctrl, ref) {
  var _ctrl$ref;
  (_ctrl$ref = ctrl.ref) == null ? void 0 : _ctrl$ref.delete(ctrl);
  ref == null ? void 0 : ref.delete(ctrl);
}
function replaceRef(ctrl, ref) {
  if (ref && ctrl.ref !== ref) {
    var _ctrl$ref2;
    (_ctrl$ref2 = ctrl.ref) == null ? void 0 : _ctrl$ref2.delete(ctrl);
    ref.add(ctrl);
    ctrl.ref = ref;
  }
}
var config = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
};
var c1 = 1.70158;
var c2 = c1 * 1.525;
var c3 = c1 + 1;
var c4 = 2 * Math.PI / 3;
var c5 = 2 * Math.PI / 4.5;
var bounceOut = (x) => {
  const n1 = 7.5625;
  const d1 = 2.75;
  if (x < 1 / d1) {
    return n1 * x * x;
  } else if (x < 2 / d1) {
    return n1 * (x -= 1.5 / d1) * x + 0.75;
  } else if (x < 2.5 / d1) {
    return n1 * (x -= 2.25 / d1) * x + 0.9375;
  } else {
    return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
};
var easings = {
  linear: (x) => x,
  easeInQuad: (x) => x * x,
  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
  easeInCubic: (x) => x * x * x,
  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
  easeInQuart: (x) => x * x * x * x,
  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
  easeInQuint: (x) => x * x * x * x * x,
  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
  easeOutSine: (x) => Math.sin(x * Math.PI / 2),
  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
  easeInBack: (x) => c3 * x * x * x - c1 * x * x,
  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
  easeInBounce: (x) => 1 - bounceOut(1 - x),
  easeOutBounce: bounceOut,
  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2
};
var defaults = _extends4({}, config.default, {
  mass: 1,
  damping: 1,
  easing: easings.linear,
  clamp: false
});
var AnimationConfig = class {
  constructor() {
    this.tension = void 0;
    this.friction = void 0;
    this.frequency = void 0;
    this.damping = void 0;
    this.mass = void 0;
    this.velocity = 0;
    this.restVelocity = void 0;
    this.precision = void 0;
    this.progress = void 0;
    this.duration = void 0;
    this.easing = void 0;
    this.clamp = void 0;
    this.bounce = void 0;
    this.decay = void 0;
    this.round = void 0;
    Object.assign(this, defaults);
  }
};
function mergeConfig(config2, newConfig, defaultConfig) {
  if (defaultConfig) {
    defaultConfig = _extends4({}, defaultConfig);
    sanitizeConfig(defaultConfig, newConfig);
    newConfig = _extends4({}, defaultConfig, newConfig);
  }
  sanitizeConfig(config2, newConfig);
  Object.assign(config2, newConfig);
  for (const key in defaults) {
    if (config2[key] == null) {
      config2[key] = defaults[key];
    }
  }
  let {
    mass,
    frequency,
    damping
  } = config2;
  if (!is.und(frequency)) {
    if (frequency < 0.01) frequency = 0.01;
    if (damping < 0) damping = 0;
    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
    config2.friction = 4 * Math.PI * damping * mass / frequency;
  }
  return config2;
}
function sanitizeConfig(config2, props) {
  if (!is.und(props.decay)) {
    config2.duration = void 0;
  } else {
    const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
    if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
      config2.duration = void 0;
      config2.decay = void 0;
    }
    if (isTensionConfig) {
      config2.frequency = void 0;
    }
  }
}
var emptyArray = [];
var Animation = class {
  constructor() {
    this.changed = false;
    this.values = emptyArray;
    this.toValues = null;
    this.fromValues = emptyArray;
    this.to = void 0;
    this.from = void 0;
    this.config = new AnimationConfig();
    this.immediate = false;
  }
};
function scheduleProps(callId, {
  key,
  props,
  defaultProps: defaultProps2,
  state,
  actions
}) {
  return new Promise((resolve, reject) => {
    var _props$cancel;
    let delay;
    let timeout2;
    let cancel = matchProp((_props$cancel = props.cancel) != null ? _props$cancel : defaultProps2 == null ? void 0 : defaultProps2.cancel, key);
    if (cancel) {
      onStart();
    } else {
      if (!is.und(props.pause)) {
        state.paused = matchProp(props.pause, key);
      }
      let pause = defaultProps2 == null ? void 0 : defaultProps2.pause;
      if (pause !== true) {
        pause = state.paused || matchProp(pause, key);
      }
      delay = callProp(props.delay || 0, key);
      if (pause) {
        state.resumeQueue.add(onResume);
        actions.pause();
      } else {
        actions.resume();
        onResume();
      }
    }
    function onPause() {
      state.resumeQueue.add(onResume);
      state.timeouts.delete(timeout2);
      timeout2.cancel();
      delay = timeout2.time - raf.now();
    }
    function onResume() {
      if (delay > 0 && !globals.skipAnimation) {
        state.delayed = true;
        timeout2 = raf.setTimeout(onStart, delay);
        state.pauseQueue.add(onPause);
        state.timeouts.add(timeout2);
      } else {
        onStart();
      }
    }
    function onStart() {
      if (state.delayed) {
        state.delayed = false;
      }
      state.pauseQueue.delete(onPause);
      state.timeouts.delete(timeout2);
      if (callId <= (state.cancelId || 0)) {
        cancel = true;
      }
      try {
        actions.start(_extends4({}, props, {
          callId,
          cancel
        }), resolve);
      } catch (err) {
        reject(err);
      }
    }
  });
}
var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(target.get(), results.every((result) => result.finished));
var getNoopResult = (value) => ({
  value,
  noop: true,
  finished: true,
  cancelled: false
});
var getFinishedResult = (value, finished, cancelled = false) => ({
  value,
  finished,
  cancelled
});
var getCancelledResult = (value) => ({
  value,
  cancelled: true,
  finished: false
});
function runAsync(to3, props, state, target) {
  const {
    callId,
    parentId,
    onRest
  } = props;
  const {
    asyncTo: prevTo,
    promise: prevPromise
  } = state;
  if (!parentId && to3 === prevTo && !props.reset) {
    return prevPromise;
  }
  return state.promise = (async () => {
    state.asyncId = callId;
    state.asyncTo = to3;
    const defaultProps2 = getDefaultProps(props, (value, key) => key === "onRest" ? void 0 : value);
    let preventBail;
    let bail;
    const bailPromise = new Promise((resolve, reject) => (preventBail = resolve, bail = reject));
    const bailIfEnded = (bailSignal) => {
      const bailResult = callId <= (state.cancelId || 0) && getCancelledResult(target) || callId !== state.asyncId && getFinishedResult(target, false);
      if (bailResult) {
        bailSignal.result = bailResult;
        bail(bailSignal);
        throw bailSignal;
      }
    };
    const animate = (arg1, arg2) => {
      const bailSignal = new BailSignal();
      const skipAnimationSignal = new SkipAniamtionSignal();
      return (async () => {
        if (globals.skipAnimation) {
          stopAsync(state);
          skipAnimationSignal.result = getFinishedResult(target, false);
          bail(skipAnimationSignal);
          throw skipAnimationSignal;
        }
        bailIfEnded(bailSignal);
        const props2 = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
          to: arg1
        });
        props2.parentId = callId;
        eachProp(defaultProps2, (value, key) => {
          if (is.und(props2[key])) {
            props2[key] = value;
          }
        });
        const result2 = await target.start(props2);
        bailIfEnded(bailSignal);
        if (state.paused) {
          await new Promise((resume) => {
            state.resumeQueue.add(resume);
          });
        }
        return result2;
      })();
    };
    let result;
    if (globals.skipAnimation) {
      stopAsync(state);
      return getFinishedResult(target, false);
    }
    try {
      let animating;
      if (is.arr(to3)) {
        animating = (async (queue) => {
          for (const props2 of queue) {
            await animate(props2);
          }
        })(to3);
      } else {
        animating = Promise.resolve(to3(animate, target.stop.bind(target)));
      }
      await Promise.all([animating.then(preventBail), bailPromise]);
      result = getFinishedResult(target.get(), true, false);
    } catch (err) {
      if (err instanceof BailSignal) {
        result = err.result;
      } else if (err instanceof SkipAniamtionSignal) {
        result = err.result;
      } else {
        throw err;
      }
    } finally {
      if (callId == state.asyncId) {
        state.asyncId = parentId;
        state.asyncTo = parentId ? prevTo : void 0;
        state.promise = parentId ? prevPromise : void 0;
      }
    }
    if (is.fun(onRest)) {
      raf.batchedUpdates(() => {
        onRest(result, target, target.item);
      });
    }
    return result;
  })();
}
function stopAsync(state, cancelId) {
  flush(state.timeouts, (t) => t.cancel());
  state.pauseQueue.clear();
  state.resumeQueue.clear();
  state.asyncId = state.asyncTo = state.promise = void 0;
  if (cancelId) state.cancelId = cancelId;
}
var BailSignal = class extends Error {
  constructor() {
    super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");
    this.result = void 0;
  }
};
var SkipAniamtionSignal = class extends Error {
  constructor() {
    super("SkipAnimationSignal");
    this.result = void 0;
  }
};
var isFrameValue = (value) => value instanceof FrameValue;
var nextId$1 = 1;
var FrameValue = class extends FluidValue {
  constructor(...args) {
    super(...args);
    this.id = nextId$1++;
    this.key = void 0;
    this._priority = 0;
  }
  get priority() {
    return this._priority;
  }
  set priority(priority2) {
    if (this._priority != priority2) {
      this._priority = priority2;
      this._onPriorityChange(priority2);
    }
  }
  get() {
    const node = getAnimated(this);
    return node && node.getValue();
  }
  to(...args) {
    return globals.to(this, args);
  }
  interpolate(...args) {
    deprecateInterpolate();
    return globals.to(this, args);
  }
  toJSON() {
    return this.get();
  }
  observerAdded(count) {
    if (count == 1) this._attach();
  }
  observerRemoved(count) {
    if (count == 0) this._detach();
  }
  _attach() {
  }
  _detach() {
  }
  _onChange(value, idle = false) {
    callFluidObservers(this, {
      type: "change",
      parent: this,
      value,
      idle
    });
  }
  _onPriorityChange(priority2) {
    if (!this.idle) {
      frameLoop.sort(this);
    }
    callFluidObservers(this, {
      type: "priority",
      parent: this,
      priority: priority2
    });
  }
};
var $P = Symbol.for("SpringPhase");
var HAS_ANIMATED = 1;
var IS_ANIMATING = 2;
var IS_PAUSED = 4;
var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
var SpringValue = class extends FrameValue {
  constructor(arg1, arg2) {
    super();
    this.key = void 0;
    this.animation = new Animation();
    this.queue = void 0;
    this.defaultProps = {};
    this._state = {
      paused: false,
      delayed: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._pendingCalls = /* @__PURE__ */ new Set();
    this._lastCallId = 0;
    this._lastToId = 0;
    this._memoizedDuration = 0;
    if (!is.und(arg1) || !is.und(arg2)) {
      const props = is.obj(arg1) ? _extends4({}, arg1) : _extends4({}, arg2, {
        from: arg1
      });
      if (is.und(props.default)) {
        props.default = true;
      }
      this.start(props);
    }
  }
  get idle() {
    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
  }
  get goal() {
    return getFluidValue(this.animation.to);
  }
  get velocity() {
    const node = getAnimated(this);
    return node instanceof AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);
  }
  get hasAnimated() {
    return hasAnimated(this);
  }
  get isAnimating() {
    return isAnimating(this);
  }
  get isPaused() {
    return isPaused(this);
  }
  get isDelayed() {
    return this._state.delayed;
  }
  advance(dt) {
    let idle = true;
    let changed = false;
    const anim = this.animation;
    let {
      config: config2,
      toValues
    } = anim;
    const payload = getPayload(anim.to);
    if (!payload && hasFluidValue(anim.to)) {
      toValues = toArray(getFluidValue(anim.to));
    }
    anim.values.forEach((node2, i) => {
      if (node2.done) return;
      const to3 = node2.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i];
      let finished = anim.immediate;
      let position = to3;
      if (!finished) {
        position = node2.lastPosition;
        if (config2.tension <= 0) {
          node2.done = true;
          return;
        }
        let elapsed = node2.elapsedTime += dt;
        const from = anim.fromValues[i];
        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
        let velocity;
        const precision = config2.precision || (from == to3 ? 5e-3 : Math.min(1, Math.abs(to3 - from) * 1e-3));
        if (!is.und(config2.duration)) {
          let p = 1;
          if (config2.duration > 0) {
            if (this._memoizedDuration !== config2.duration) {
              this._memoizedDuration = config2.duration;
              if (node2.durationProgress > 0) {
                node2.elapsedTime = config2.duration * node2.durationProgress;
                elapsed = node2.elapsedTime += dt;
              }
            }
            p = (config2.progress || 0) + elapsed / this._memoizedDuration;
            p = p > 1 ? 1 : p < 0 ? 0 : p;
            node2.durationProgress = p;
          }
          position = from + config2.easing(p) * (to3 - from);
          velocity = (position - node2.lastPosition) / dt;
          finished = p == 1;
        } else if (config2.decay) {
          const decay = config2.decay === true ? 0.998 : config2.decay;
          const e = Math.exp(-(1 - decay) * elapsed);
          position = from + v0 / (1 - decay) * (1 - e);
          finished = Math.abs(node2.lastPosition - position) <= precision;
          velocity = v0 * e;
        } else {
          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;
          const restVelocity = config2.restVelocity || precision / 10;
          const bounceFactor = config2.clamp ? 0 : config2.bounce;
          const canBounce = !is.und(bounceFactor);
          const isGrowing = from == to3 ? node2.v0 > 0 : from < to3;
          let isMoving;
          let isBouncing = false;
          const step = 1;
          const numSteps = Math.ceil(dt / step);
          for (let n = 0; n < numSteps; ++n) {
            isMoving = Math.abs(velocity) > restVelocity;
            if (!isMoving) {
              finished = Math.abs(to3 - position) <= precision;
              if (finished) {
                break;
              }
            }
            if (canBounce) {
              isBouncing = position == to3 || position > to3 == isGrowing;
              if (isBouncing) {
                velocity = -velocity * bounceFactor;
                position = to3;
              }
            }
            const springForce = -config2.tension * 1e-6 * (position - to3);
            const dampingForce = -config2.friction * 1e-3 * velocity;
            const acceleration = (springForce + dampingForce) / config2.mass;
            velocity = velocity + acceleration * step;
            position = position + velocity * step;
          }
        }
        node2.lastVelocity = velocity;
        if (Number.isNaN(position)) {
          console.warn(`Got NaN while animating:`, this);
          finished = true;
        }
      }
      if (payload && !payload[i].done) {
        finished = false;
      }
      if (finished) {
        node2.done = true;
      } else {
        idle = false;
      }
      if (node2.setValue(position, config2.round)) {
        changed = true;
      }
    });
    const node = getAnimated(this);
    const currVal = node.getValue();
    if (idle) {
      const finalVal = getFluidValue(anim.to);
      if ((currVal !== finalVal || changed) && !config2.decay) {
        node.setValue(finalVal);
        this._onChange(finalVal);
      } else if (changed && config2.decay) {
        this._onChange(currVal);
      }
      this._stop();
    } else if (changed) {
      this._onChange(currVal);
    }
  }
  set(value) {
    raf.batchedUpdates(() => {
      this._stop();
      this._focus(value);
      this._set(value);
    });
    return this;
  }
  pause() {
    this._update({
      pause: true
    });
  }
  resume() {
    this._update({
      pause: false
    });
  }
  finish() {
    if (isAnimating(this)) {
      const {
        to: to3,
        config: config2
      } = this.animation;
      raf.batchedUpdates(() => {
        this._onStart();
        if (!config2.decay) {
          this._set(to3, false);
        }
        this._stop();
      });
    }
    return this;
  }
  update(props) {
    const queue = this.queue || (this.queue = []);
    queue.push(props);
    return this;
  }
  start(to3, arg2) {
    let queue;
    if (!is.und(to3)) {
      queue = [is.obj(to3) ? to3 : _extends4({}, arg2, {
        to: to3
      })];
    } else {
      queue = this.queue || [];
      this.queue = [];
    }
    return Promise.all(queue.map((props) => {
      const up = this._update(props);
      return up;
    })).then((results) => getCombinedResult(this, results));
  }
  stop(cancel) {
    const {
      to: to3
    } = this.animation;
    this._focus(this.get());
    stopAsync(this._state, cancel && this._lastCallId);
    raf.batchedUpdates(() => this._stop(to3, cancel));
    return this;
  }
  reset() {
    this._update({
      reset: true
    });
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._start();
    } else if (event.type == "priority") {
      this.priority = event.priority + 1;
    }
  }
  _prepareNode(props) {
    const key = this.key || "";
    let {
      to: to3,
      from
    } = props;
    to3 = is.obj(to3) ? to3[key] : to3;
    if (to3 == null || isAsyncTo(to3)) {
      to3 = void 0;
    }
    from = is.obj(from) ? from[key] : from;
    if (from == null) {
      from = void 0;
    }
    const range = {
      to: to3,
      from
    };
    if (!hasAnimated(this)) {
      if (props.reverse) [to3, from] = [from, to3];
      from = getFluidValue(from);
      if (!is.und(from)) {
        this._set(from);
      } else if (!getAnimated(this)) {
        this._set(to3);
      }
    }
    return range;
  }
  _update(_ref, isLoop) {
    let props = _extends4({}, _ref);
    const {
      key,
      defaultProps: defaultProps2
    } = this;
    if (props.default) Object.assign(defaultProps2, getDefaultProps(props, (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value));
    mergeActiveFn(this, props, "onProps");
    sendEvent(this, "onProps", props, this);
    const range = this._prepareNode(props);
    if (Object.isFrozen(this)) {
      throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");
    }
    const state = this._state;
    return scheduleProps(++this._lastCallId, {
      key,
      props,
      defaultProps: defaultProps2,
      state,
      actions: {
        pause: () => {
          if (!isPaused(this)) {
            setPausedBit(this, true);
            flushCalls(state.pauseQueue);
            sendEvent(this, "onPause", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        resume: () => {
          if (isPaused(this)) {
            setPausedBit(this, false);
            if (isAnimating(this)) {
              this._resume();
            }
            flushCalls(state.resumeQueue);
            sendEvent(this, "onResume", getFinishedResult(this, checkFinished(this, this.animation.to)), this);
          }
        },
        start: this._merge.bind(this, range)
      }
    }).then((result) => {
      if (props.loop && result.finished && !(isLoop && result.noop)) {
        const nextProps = createLoopUpdate(props);
        if (nextProps) {
          return this._update(nextProps, true);
        }
      }
      return result;
    });
  }
  _merge(range, props, resolve) {
    if (props.cancel) {
      this.stop(true);
      return resolve(getCancelledResult(this));
    }
    const hasToProp = !is.und(range.to);
    const hasFromProp = !is.und(range.from);
    if (hasToProp || hasFromProp) {
      if (props.callId > this._lastToId) {
        this._lastToId = props.callId;
      } else {
        return resolve(getCancelledResult(this));
      }
    }
    const {
      key,
      defaultProps: defaultProps2,
      animation: anim
    } = this;
    const {
      to: prevTo,
      from: prevFrom
    } = anim;
    let {
      to: to3 = prevTo,
      from = prevFrom
    } = range;
    if (hasFromProp && !hasToProp && (!props.default || is.und(to3))) {
      to3 = from;
    }
    if (props.reverse) [to3, from] = [from, to3];
    const hasFromChanged = !isEqual(from, prevFrom);
    if (hasFromChanged) {
      anim.from = from;
    }
    from = getFluidValue(from);
    const hasToChanged = !isEqual(to3, prevTo);
    if (hasToChanged) {
      this._focus(to3);
    }
    const hasAsyncTo = isAsyncTo(props.to);
    const {
      config: config2
    } = anim;
    const {
      decay,
      velocity
    } = config2;
    if (hasToProp || hasFromProp) {
      config2.velocity = 0;
    }
    if (props.config && !hasAsyncTo) {
      mergeConfig(config2, callProp(props.config, key), props.config !== defaultProps2.config ? callProp(defaultProps2.config, key) : void 0);
    }
    let node = getAnimated(this);
    if (!node || is.und(to3)) {
      return resolve(getFinishedResult(this, true));
    }
    const reset = is.und(props.reset) ? hasFromProp && !props.default : !is.und(from) && matchProp(props.reset, key);
    const value = reset ? from : this.get();
    const goal = computeGoal(to3);
    const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps2.immediate || props.immediate, key));
    if (hasToChanged) {
      const nodeType = getAnimatedType(to3);
      if (nodeType !== node.constructor) {
        if (immediate) {
          node = this._set(goal);
        } else throw Error(`Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);
      }
    }
    const goalType = node.constructor;
    let started = hasFluidValue(to3);
    let finished = false;
    if (!started) {
      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
      if (hasToChanged || hasValueChanged) {
        finished = isEqual(computeGoal(value), goal);
        started = !finished;
      }
      if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
        started = true;
      }
    }
    if (finished && isAnimating(this)) {
      if (anim.changed && !reset) {
        started = true;
      } else if (!started) {
        this._stop(prevTo);
      }
    }
    if (!hasAsyncTo) {
      if (started || hasFluidValue(prevTo)) {
        anim.values = node.getPayload();
        anim.toValues = hasFluidValue(to3) ? null : goalType == AnimatedString ? [1] : toArray(goal);
      }
      if (anim.immediate != immediate) {
        anim.immediate = immediate;
        if (!immediate && !reset) {
          this._set(prevTo);
        }
      }
      if (started) {
        const {
          onRest
        } = anim;
        each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
        const result = getFinishedResult(this, checkFinished(this, prevTo));
        flushCalls(this._pendingCalls, result);
        this._pendingCalls.add(resolve);
        if (anim.changed) raf.batchedUpdates(() => {
          anim.changed = !reset;
          onRest == null ? void 0 : onRest(result, this);
          if (reset) {
            callProp(defaultProps2.onRest, result);
          } else {
            anim.onStart == null ? void 0 : anim.onStart(result, this);
          }
        });
      }
    }
    if (reset) {
      this._set(value);
    }
    if (hasAsyncTo) {
      resolve(runAsync(props.to, props, this._state, this));
    } else if (started) {
      this._start();
    } else if (isAnimating(this) && !hasToChanged) {
      this._pendingCalls.add(resolve);
    } else {
      resolve(getNoopResult(value));
    }
  }
  _focus(value) {
    const anim = this.animation;
    if (value !== anim.to) {
      if (getFluidObservers(this)) {
        this._detach();
      }
      anim.to = value;
      if (getFluidObservers(this)) {
        this._attach();
      }
    }
  }
  _attach() {
    let priority2 = 0;
    const {
      to: to3
    } = this.animation;
    if (hasFluidValue(to3)) {
      addFluidObserver(to3, this);
      if (isFrameValue(to3)) {
        priority2 = to3.priority + 1;
      }
    }
    this.priority = priority2;
  }
  _detach() {
    const {
      to: to3
    } = this.animation;
    if (hasFluidValue(to3)) {
      removeFluidObserver(to3, this);
    }
  }
  _set(arg, idle = true) {
    const value = getFluidValue(arg);
    if (!is.und(value)) {
      const oldNode = getAnimated(this);
      if (!oldNode || !isEqual(value, oldNode.getValue())) {
        const nodeType = getAnimatedType(value);
        if (!oldNode || oldNode.constructor != nodeType) {
          setAnimated(this, nodeType.create(value));
        } else {
          oldNode.setValue(value);
        }
        if (oldNode) {
          raf.batchedUpdates(() => {
            this._onChange(value, idle);
          });
        }
      }
    }
    return getAnimated(this);
  }
  _onStart() {
    const anim = this.animation;
    if (!anim.changed) {
      anim.changed = true;
      sendEvent(this, "onStart", getFinishedResult(this, checkFinished(this, anim.to)), this);
    }
  }
  _onChange(value, idle) {
    if (!idle) {
      this._onStart();
      callProp(this.animation.onChange, value, this);
    }
    callProp(this.defaultProps.onChange, value, this);
    super._onChange(value, idle);
  }
  _start() {
    const anim = this.animation;
    getAnimated(this).reset(getFluidValue(anim.to));
    if (!anim.immediate) {
      anim.fromValues = anim.values.map((node) => node.lastPosition);
    }
    if (!isAnimating(this)) {
      setActiveBit(this, true);
      if (!isPaused(this)) {
        this._resume();
      }
    }
  }
  _resume() {
    if (globals.skipAnimation) {
      this.finish();
    } else {
      frameLoop.start(this);
    }
  }
  _stop(goal, cancel) {
    if (isAnimating(this)) {
      setActiveBit(this, false);
      const anim = this.animation;
      each(anim.values, (node) => {
        node.done = true;
      });
      if (anim.toValues) {
        anim.onChange = anim.onPause = anim.onResume = void 0;
      }
      callFluidObservers(this, {
        type: "idle",
        parent: this
      });
      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
      flushCalls(this._pendingCalls, result);
      if (anim.changed) {
        anim.changed = false;
        sendEvent(this, "onRest", result, this);
      }
    }
  }
};
function checkFinished(target, to3) {
  const goal = computeGoal(to3);
  const value = computeGoal(target.get());
  return isEqual(value, goal);
}
function createLoopUpdate(props, loop2 = props.loop, to3 = props.to) {
  let loopRet = callProp(loop2);
  if (loopRet) {
    const overrides = loopRet !== true && inferTo(loopRet);
    const reverse = (overrides || props).reverse;
    const reset = !overrides || overrides.reset;
    return createUpdate(_extends4({}, props, {
      loop: loop2,
      default: false,
      pause: void 0,
      to: !reverse || isAsyncTo(to3) ? to3 : void 0,
      from: reset ? props.from : void 0,
      reset
    }, overrides));
  }
}
function createUpdate(props) {
  const {
    to: to3,
    from
  } = props = inferTo(props);
  const keys = /* @__PURE__ */ new Set();
  if (is.obj(to3)) findDefined(to3, keys);
  if (is.obj(from)) findDefined(from, keys);
  props.keys = keys.size ? Array.from(keys) : null;
  return props;
}
function declareUpdate(props) {
  const update3 = createUpdate(props);
  if (is.und(update3.default)) {
    update3.default = getDefaultProps(update3);
  }
  return update3;
}
function findDefined(values2, keys) {
  eachProp(values2, (value, key) => value != null && keys.add(key));
}
var ACTIVE_EVENTS = ["onStart", "onRest", "onChange", "onPause", "onResume"];
function mergeActiveFn(target, props, type) {
  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
}
function sendEvent(target, type, ...args) {
  var _target$animation$typ, _target$animation, _target$defaultProps$, _target$defaultProps;
  (_target$animation$typ = (_target$animation = target.animation)[type]) == null ? void 0 : _target$animation$typ.call(_target$animation, ...args);
  (_target$defaultProps$ = (_target$defaultProps = target.defaultProps)[type]) == null ? void 0 : _target$defaultProps$.call(_target$defaultProps, ...args);
}
var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
var nextId = 1;
var Controller2 = class {
  constructor(props, flush2) {
    this.id = nextId++;
    this.springs = {};
    this.queue = [];
    this.ref = void 0;
    this._flush = void 0;
    this._initialProps = void 0;
    this._lastAsyncId = 0;
    this._active = /* @__PURE__ */ new Set();
    this._changed = /* @__PURE__ */ new Set();
    this._started = false;
    this._item = void 0;
    this._state = {
      paused: false,
      pauseQueue: /* @__PURE__ */ new Set(),
      resumeQueue: /* @__PURE__ */ new Set(),
      timeouts: /* @__PURE__ */ new Set()
    };
    this._events = {
      onStart: /* @__PURE__ */ new Map(),
      onChange: /* @__PURE__ */ new Map(),
      onRest: /* @__PURE__ */ new Map()
    };
    this._onFrame = this._onFrame.bind(this);
    if (flush2) {
      this._flush = flush2;
    }
    if (props) {
      this.start(_extends4({
        default: true
      }, props));
    }
  }
  get idle() {
    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
      return spring.idle && !spring.isDelayed && !spring.isPaused;
    });
  }
  get item() {
    return this._item;
  }
  set item(item) {
    this._item = item;
  }
  get() {
    const values2 = {};
    this.each((spring, key) => values2[key] = spring.get());
    return values2;
  }
  set(values2) {
    for (const key in values2) {
      const value = values2[key];
      if (!is.und(value)) {
        this.springs[key].set(value);
      }
    }
  }
  update(props) {
    if (props) {
      this.queue.push(createUpdate(props));
    }
    return this;
  }
  start(props) {
    let {
      queue
    } = this;
    if (props) {
      queue = toArray(props).map(createUpdate);
    } else {
      this.queue = [];
    }
    if (this._flush) {
      return this._flush(this, queue);
    }
    prepareKeys(this, queue);
    return flushUpdateQueue(this, queue);
  }
  stop(arg, keys) {
    if (arg !== !!arg) {
      keys = arg;
    }
    if (keys) {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].stop(!!arg));
    } else {
      stopAsync(this._state, this._lastAsyncId);
      this.each((spring) => spring.stop(!!arg));
    }
    return this;
  }
  pause(keys) {
    if (is.und(keys)) {
      this.start({
        pause: true
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].pause());
    }
    return this;
  }
  resume(keys) {
    if (is.und(keys)) {
      this.start({
        pause: false
      });
    } else {
      const springs = this.springs;
      each(toArray(keys), (key) => springs[key].resume());
    }
    return this;
  }
  each(iterator) {
    eachProp(this.springs, iterator);
  }
  _onFrame() {
    const {
      onStart,
      onChange,
      onRest
    } = this._events;
    const active = this._active.size > 0;
    const changed = this._changed.size > 0;
    if (active && !this._started || changed && !this._started) {
      this._started = true;
      flush(onStart, ([onStart2, result]) => {
        result.value = this.get();
        onStart2(result, this, this._item);
      });
    }
    const idle = !active && this._started;
    const values2 = changed || idle && onRest.size ? this.get() : null;
    if (changed && onChange.size) {
      flush(onChange, ([onChange2, result]) => {
        result.value = values2;
        onChange2(result, this, this._item);
      });
    }
    if (idle) {
      this._started = false;
      flush(onRest, ([onRest2, result]) => {
        result.value = values2;
        onRest2(result, this, this._item);
      });
    }
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._changed.add(event.parent);
      if (!event.idle) {
        this._active.add(event.parent);
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else return;
    raf.onFrame(this._onFrame);
  }
};
function flushUpdateQueue(ctrl, queue) {
  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then((results) => getCombinedResult(ctrl, results));
}
async function flushUpdate(ctrl, props, isLoop) {
  const {
    keys,
    to: to3,
    from,
    loop: loop2,
    onRest,
    onResolve
  } = props;
  const defaults2 = is.obj(props.default) && props.default;
  if (loop2) {
    props.loop = false;
  }
  if (to3 === false) props.to = null;
  if (from === false) props.from = null;
  const asyncTo = is.arr(to3) || is.fun(to3) ? to3 : void 0;
  if (asyncTo) {
    props.to = void 0;
    props.onRest = void 0;
    if (defaults2) {
      defaults2.onRest = void 0;
    }
  } else {
    each(BATCHED_EVENTS, (key) => {
      const handler = props[key];
      if (is.fun(handler)) {
        const queue = ctrl["_events"][key];
        props[key] = ({
          finished,
          cancelled
        }) => {
          const result2 = queue.get(handler);
          if (result2) {
            if (!finished) result2.finished = false;
            if (cancelled) result2.cancelled = true;
          } else {
            queue.set(handler, {
              value: null,
              finished: finished || false,
              cancelled: cancelled || false
            });
          }
        };
        if (defaults2) {
          defaults2[key] = props[key];
        }
      }
    });
  }
  const state = ctrl["_state"];
  if (props.pause === !state.paused) {
    state.paused = props.pause;
    flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
  } else if (state.paused) {
    props.pause = true;
  }
  const promises = (keys || Object.keys(ctrl.springs)).map((key) => ctrl.springs[key].start(props));
  const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
  if (asyncTo || cancel && state.asyncId) {
    promises.push(scheduleProps(++ctrl["_lastAsyncId"], {
      props,
      state,
      actions: {
        pause: noop3,
        resume: noop3,
        start(props2, resolve) {
          if (cancel) {
            stopAsync(state, ctrl["_lastAsyncId"]);
            resolve(getCancelledResult(ctrl));
          } else {
            props2.onRest = onRest;
            resolve(runAsync(asyncTo, props2, state, ctrl));
          }
        }
      }
    }));
  }
  if (state.paused) {
    await new Promise((resume) => {
      state.resumeQueue.add(resume);
    });
  }
  const result = getCombinedResult(ctrl, await Promise.all(promises));
  if (loop2 && result.finished && !(isLoop && result.noop)) {
    const nextProps = createLoopUpdate(props, loop2, to3);
    if (nextProps) {
      prepareKeys(ctrl, [nextProps]);
      return flushUpdate(ctrl, nextProps, true);
    }
  }
  if (onResolve) {
    raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
  }
  return result;
}
function getSprings(ctrl, props) {
  const springs = _extends4({}, ctrl.springs);
  if (props) {
    each(toArray(props), (props2) => {
      if (is.und(props2.keys)) {
        props2 = createUpdate(props2);
      }
      if (!is.obj(props2.to)) {
        props2 = _extends4({}, props2, {
          to: void 0
        });
      }
      prepareSprings(springs, props2, (key) => {
        return createSpring(key);
      });
    });
  }
  setSprings(ctrl, springs);
  return springs;
}
function setSprings(ctrl, springs) {
  eachProp(springs, (spring, key) => {
    if (!ctrl.springs[key]) {
      ctrl.springs[key] = spring;
      addFluidObserver(spring, ctrl);
    }
  });
}
function createSpring(key, observer) {
  const spring = new SpringValue();
  spring.key = key;
  if (observer) {
    addFluidObserver(spring, observer);
  }
  return spring;
}
function prepareSprings(springs, props, create) {
  if (props.keys) {
    each(props.keys, (key) => {
      const spring = springs[key] || (springs[key] = create(key));
      spring["_prepareNode"](props);
    });
  }
}
function prepareKeys(ctrl, queue) {
  each(queue, (props) => {
    prepareSprings(ctrl.springs, props, (key) => {
      return createSpring(key, ctrl);
    });
  });
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$3 = ["children"];
var SpringContext = (_ref) => {
  let {
    children: children2
  } = _ref, props = _objectWithoutPropertiesLoose3(_ref, _excluded$3);
  const inherited = (0, import_react41.useContext)(ctx);
  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
  props = useMemoOne(() => ({
    pause,
    immediate
  }), [pause, immediate]);
  const {
    Provider
  } = ctx;
  return React42.createElement(Provider, {
    value: props
  }, children2);
};
var ctx = makeContext(SpringContext, {});
SpringContext.Provider = ctx.Provider;
SpringContext.Consumer = ctx.Consumer;
function makeContext(target, init) {
  Object.assign(target, React42.createContext(init));
  target.Provider._context = target;
  target.Consumer._context = target;
  return target;
}
var SpringRef = () => {
  const current = [];
  const SpringRef2 = function SpringRef3(props) {
    deprecateDirectCall();
    const results = [];
    each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = _getProps(props, ctrl, i);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.current = current;
  SpringRef2.add = function(ctrl) {
    if (!current.includes(ctrl)) {
      current.push(ctrl);
    }
  };
  SpringRef2.delete = function(ctrl) {
    const i = current.indexOf(ctrl);
    if (~i) current.splice(i, 1);
  };
  SpringRef2.pause = function() {
    each(current, (ctrl) => ctrl.pause(...arguments));
    return this;
  };
  SpringRef2.resume = function() {
    each(current, (ctrl) => ctrl.resume(...arguments));
    return this;
  };
  SpringRef2.set = function(values2) {
    each(current, (ctrl) => ctrl.set(values2));
  };
  SpringRef2.start = function(props) {
    const results = [];
    each(current, (ctrl, i) => {
      if (is.und(props)) {
        results.push(ctrl.start());
      } else {
        const update3 = this._getProps(props, ctrl, i);
        if (update3) {
          results.push(ctrl.start(update3));
        }
      }
    });
    return results;
  };
  SpringRef2.stop = function() {
    each(current, (ctrl) => ctrl.stop(...arguments));
    return this;
  };
  SpringRef2.update = function(props) {
    each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
    return this;
  };
  const _getProps = function _getProps2(arg, ctrl, index2) {
    return is.fun(arg) ? arg(index2, ctrl) : arg;
  };
  SpringRef2._getProps = _getProps;
  return SpringRef2;
};
function useSprings(length, props, deps) {
  const propsFn = is.fun(props) && props;
  if (propsFn && !deps) deps = [];
  const ref = (0, import_react41.useMemo)(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
  const layoutId = (0, import_react41.useRef)(0);
  const forceUpdate = useForceUpdate();
  const state = (0, import_react41.useMemo)(() => ({
    ctrls: [],
    queue: [],
    flush(ctrl, updates2) {
      const springs2 = getSprings(ctrl, updates2);
      const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);
      return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {
        setSprings(ctrl, springs2);
        state.queue.push(() => {
          resolve(flushUpdateQueue(ctrl, updates2));
        });
        forceUpdate();
      });
    }
  }), []);
  const ctrls = (0, import_react41.useRef)([...state.ctrls]);
  const updates = [];
  const prevLength = usePrev(length) || 0;
  (0, import_react41.useMemo)(() => {
    each(ctrls.current.slice(length, prevLength), (ctrl) => {
      detachRefs(ctrl, ref);
      ctrl.stop(true);
    });
    ctrls.current.length = length;
    declareUpdates(prevLength, length);
  }, [length]);
  (0, import_react41.useMemo)(() => {
    declareUpdates(0, Math.min(prevLength, length));
  }, deps);
  function declareUpdates(startIndex, endIndex) {
    for (let i = startIndex; i < endIndex; i++) {
      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller2(null, state.flush));
      const update3 = propsFn ? propsFn(i, ctrl) : props[i];
      if (update3) {
        updates[i] = declareUpdate(update3);
      }
    }
  }
  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));
  const context = (0, import_react41.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    layoutId.current++;
    state.ctrls = ctrls.current;
    const {
      queue
    } = state;
    if (queue.length) {
      state.queue = [];
      each(queue, (cb) => cb());
    }
    each(ctrls.current, (ctrl, i) => {
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext) {
        ctrl.start({
          default: context
        });
      }
      const update3 = updates[i];
      if (update3) {
        replaceRef(ctrl, update3.ref);
        if (ctrl.ref) {
          ctrl.queue.push(update3);
        } else {
          ctrl.start(update3);
        }
      }
    });
  });
  useOnce(() => () => {
    each(state.ctrls, (ctrl) => ctrl.stop(true));
  });
  const values2 = springs.map((x) => _extends4({}, x));
  return ref ? [values2, ref] : values2;
}
function useSpring(props, deps) {
  const isFn = is.fun(props);
  const [[values2], ref] = useSprings(1, isFn ? props : [props], isFn ? deps || [] : deps);
  return isFn || arguments.length == 2 ? [values2, ref] : values2;
}
var TransitionPhase;
(function(TransitionPhase2) {
  TransitionPhase2["MOUNT"] = "mount";
  TransitionPhase2["ENTER"] = "enter";
  TransitionPhase2["UPDATE"] = "update";
  TransitionPhase2["LEAVE"] = "leave";
})(TransitionPhase || (TransitionPhase = {}));
function useTransition(data, props, deps) {
  const propsFn = is.fun(props) && props;
  const {
    reset,
    sort,
    trail = 0,
    expires = true,
    exitBeforeEnter = false,
    onDestroyed,
    ref: propsRef,
    config: propsConfig
  } = propsFn ? propsFn() : props;
  const ref = (0, import_react41.useMemo)(() => propsFn || arguments.length == 3 ? SpringRef() : void 0, []);
  const items = toArray(data);
  const transitions = [];
  const usedTransitions = (0, import_react41.useRef)(null);
  const prevTransitions = reset ? null : usedTransitions.current;
  useIsomorphicLayoutEffect(() => {
    usedTransitions.current = transitions;
  });
  useOnce(() => {
    each(transitions, (t) => {
      ref == null ? void 0 : ref.add(t.ctrl);
      t.ctrl.ref = ref;
    });
    return () => {
      each(usedTransitions.current, (t) => {
        if (t.expired) {
          clearTimeout(t.expirationId);
        }
        detachRefs(t.ctrl, ref);
        t.ctrl.stop(true);
      });
    };
  });
  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
  const expired = reset && usedTransitions.current || [];
  useIsomorphicLayoutEffect(() => each(expired, ({
    ctrl,
    item,
    key
  }) => {
    detachRefs(ctrl, ref);
    callProp(onDestroyed, item, key);
  }));
  const reused = [];
  if (prevTransitions) each(prevTransitions, (t, i) => {
    if (t.expired) {
      clearTimeout(t.expirationId);
      expired.push(t);
    } else {
      i = reused[i] = keys.indexOf(t.key);
      if (~i) transitions[i] = t;
    }
  });
  each(items, (item, i) => {
    if (!transitions[i]) {
      transitions[i] = {
        key: keys[i],
        item,
        phase: TransitionPhase.MOUNT,
        ctrl: new Controller2()
      };
      transitions[i].ctrl.item = item;
    }
  });
  if (reused.length) {
    let i = -1;
    const {
      leave
    } = propsFn ? propsFn() : props;
    each(reused, (keyIndex, prevIndex) => {
      const t = prevTransitions[prevIndex];
      if (~keyIndex) {
        i = transitions.indexOf(t);
        transitions[i] = _extends4({}, t, {
          item: items[keyIndex]
        });
      } else if (leave) {
        transitions.splice(++i, 0, t);
      }
    });
  }
  if (is.fun(sort)) {
    transitions.sort((a, b) => sort(a.item, b.item));
  }
  let delay = -trail;
  const forceUpdate = useForceUpdate();
  const defaultProps2 = getDefaultProps(props);
  const changes = /* @__PURE__ */ new Map();
  const exitingTransitions = (0, import_react41.useRef)(/* @__PURE__ */ new Map());
  const forceChange = (0, import_react41.useRef)(false);
  each(transitions, (t, i) => {
    const key = t.key;
    const prevPhase = t.phase;
    const p = propsFn ? propsFn() : props;
    let to3;
    let phase;
    let propsDelay = callProp(p.delay || 0, key);
    if (prevPhase == TransitionPhase.MOUNT) {
      to3 = p.enter;
      phase = TransitionPhase.ENTER;
    } else {
      const isLeave = keys.indexOf(key) < 0;
      if (prevPhase != TransitionPhase.LEAVE) {
        if (isLeave) {
          to3 = p.leave;
          phase = TransitionPhase.LEAVE;
        } else if (to3 = p.update) {
          phase = TransitionPhase.UPDATE;
        } else return;
      } else if (!isLeave) {
        to3 = p.enter;
        phase = TransitionPhase.ENTER;
      } else return;
    }
    to3 = callProp(to3, t.item, i);
    to3 = is.obj(to3) ? inferTo(to3) : {
      to: to3
    };
    if (!to3.config) {
      const config2 = propsConfig || defaultProps2.config;
      to3.config = callProp(config2, t.item, i, phase);
    }
    delay += trail;
    const payload = _extends4({}, defaultProps2, {
      delay: propsDelay + delay,
      ref: propsRef,
      immediate: p.immediate,
      reset: false
    }, to3);
    if (phase == TransitionPhase.ENTER && is.und(payload.from)) {
      const _p = propsFn ? propsFn() : props;
      const from = is.und(_p.initial) || prevTransitions ? _p.from : _p.initial;
      payload.from = callProp(from, t.item, i);
    }
    const {
      onResolve
    } = payload;
    payload.onResolve = (result) => {
      callProp(onResolve, result);
      const transitions2 = usedTransitions.current;
      const t2 = transitions2.find((t3) => t3.key === key);
      if (!t2) return;
      if (result.cancelled && t2.phase != TransitionPhase.UPDATE) {
        return;
      }
      if (t2.ctrl.idle) {
        const idle = transitions2.every((t3) => t3.ctrl.idle);
        if (t2.phase == TransitionPhase.LEAVE) {
          const expiry = callProp(expires, t2.item);
          if (expiry !== false) {
            const expiryMs = expiry === true ? 0 : expiry;
            t2.expired = true;
            if (!idle && expiryMs > 0) {
              if (expiryMs <= 2147483647) t2.expirationId = setTimeout(forceUpdate, expiryMs);
              return;
            }
          }
        }
        if (idle && transitions2.some((t3) => t3.expired)) {
          exitingTransitions.current.delete(t2);
          if (exitBeforeEnter) {
            forceChange.current = true;
          }
          forceUpdate();
        }
      }
    };
    const springs = getSprings(t.ctrl, payload);
    if (phase === TransitionPhase.LEAVE && exitBeforeEnter) {
      exitingTransitions.current.set(t, {
        phase,
        springs,
        payload
      });
    } else {
      changes.set(t, {
        phase,
        springs,
        payload
      });
    }
  });
  const context = (0, import_react41.useContext)(SpringContext);
  const prevContext = usePrev(context);
  const hasContext = context !== prevContext && hasProps(context);
  useIsomorphicLayoutEffect(() => {
    if (hasContext) {
      each(transitions, (t) => {
        t.ctrl.start({
          default: context
        });
      });
    }
  }, [context]);
  each(changes, (_, t) => {
    if (exitingTransitions.current.size) {
      const ind = transitions.findIndex((state) => state.key === t.key);
      transitions.splice(ind, 1);
    }
  });
  useIsomorphicLayoutEffect(() => {
    each(exitingTransitions.current.size ? exitingTransitions.current : changes, ({
      phase,
      payload
    }, t) => {
      const {
        ctrl
      } = t;
      t.phase = phase;
      ref == null ? void 0 : ref.add(ctrl);
      if (hasContext && phase == TransitionPhase.ENTER) {
        ctrl.start({
          default: context
        });
      }
      if (payload) {
        replaceRef(ctrl, payload.ref);
        if ((ctrl.ref || ref) && !forceChange.current) {
          ctrl.update(payload);
        } else {
          ctrl.start(payload);
          if (forceChange.current) {
            forceChange.current = false;
          }
        }
      }
    });
  }, reset ? void 0 : deps);
  const renderTransitions = (render) => React42.createElement(React42.Fragment, null, transitions.map((t, i) => {
    const {
      springs
    } = changes.get(t) || t.ctrl;
    const elem = render(_extends4({}, springs), t.item, t, i);
    return elem && elem.type ? React42.createElement(elem.type, _extends4({}, elem.props, {
      key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,
      ref: elem.ref
    })) : elem;
  }));
  return ref ? [renderTransitions, ref] : renderTransitions;
}
var nextKey = 1;
function getKeys(items, {
  key,
  keys = key
}, prevTransitions) {
  if (keys === null) {
    const reused = /* @__PURE__ */ new Set();
    return items.map((item) => {
      const t = prevTransitions && prevTransitions.find((t2) => t2.item === item && t2.phase !== TransitionPhase.LEAVE && !reused.has(t2));
      if (t) {
        reused.add(t);
        return t.key;
      }
      return nextKey++;
    });
  }
  return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);
}
var Interpolation = class extends FrameValue {
  constructor(source, args) {
    super();
    this.key = void 0;
    this.idle = true;
    this.calc = void 0;
    this._active = /* @__PURE__ */ new Set();
    this.source = source;
    this.calc = createInterpolator(...args);
    const value = this._get();
    const nodeType = getAnimatedType(value);
    setAnimated(this, nodeType.create(value));
  }
  advance(_dt) {
    const value = this._get();
    const oldValue = this.get();
    if (!isEqual(value, oldValue)) {
      getAnimated(this).setValue(value);
      this._onChange(value, this.idle);
    }
    if (!this.idle && checkIdle(this._active)) {
      becomeIdle(this);
    }
  }
  _get() {
    const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
    return this.calc(...inputs);
  }
  _start() {
    if (this.idle && !checkIdle(this._active)) {
      this.idle = false;
      each(getPayload(this), (node) => {
        node.done = false;
      });
      if (globals.skipAnimation) {
        raf.batchedUpdates(() => this.advance());
        becomeIdle(this);
      } else {
        frameLoop.start(this);
      }
    }
  }
  _attach() {
    let priority2 = 1;
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        addFluidObserver(source, this);
      }
      if (isFrameValue(source)) {
        if (!source.idle) {
          this._active.add(source);
        }
        priority2 = Math.max(priority2, source.priority + 1);
      }
    });
    this.priority = priority2;
    this._start();
  }
  _detach() {
    each(toArray(this.source), (source) => {
      if (hasFluidValue(source)) {
        removeFluidObserver(source, this);
      }
    });
    this._active.clear();
    becomeIdle(this);
  }
  eventObserved(event) {
    if (event.type == "change") {
      if (event.idle) {
        this.advance();
      } else {
        this._active.add(event.parent);
        this._start();
      }
    } else if (event.type == "idle") {
      this._active.delete(event.parent);
    } else if (event.type == "priority") {
      this.priority = toArray(this.source).reduce((highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1), 0);
    }
  }
};
function isIdle(source) {
  return source.idle !== false;
}
function checkIdle(active) {
  return !active.size || Array.from(active).every(isIdle);
}
function becomeIdle(self2) {
  if (!self2.idle) {
    self2.idle = true;
    each(getPayload(self2), (node) => {
      node.done = true;
    });
    callFluidObservers(self2, {
      type: "idle",
      parent: self2
    });
  }
}
var to2 = (source, ...args) => new Interpolation(source, args);
globals.assign({
  createStringInterpolator,
  to: (source, args) => new Interpolation(source, args)
});
var update2 = frameLoop.advance;

// node_modules/@react-spring/web/dist/react-spring-web.esm.js
var import_react_dom3 = __toESM(require_react_dom());
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$2 = ["style", "children", "scrollTop", "scrollLeft"];
var isCustomPropRE = /^--/;
function dangerousStyleValue(name, value) {
  if (value == null || typeof value === "boolean" || value === "") return "";
  if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) return value + "px";
  return ("" + value).trim();
}
var attributeCache = {};
function applyAnimatedValues(instance, props) {
  if (!instance.nodeType || !instance.setAttribute) {
    return false;
  }
  const isFilterElement = instance.nodeName === "filter" || instance.parentNode && instance.parentNode.nodeName === "filter";
  const _ref = props, {
    style,
    children: children2,
    scrollTop,
    scrollLeft
  } = _ref, attributes = _objectWithoutPropertiesLoose4(_ref, _excluded$2);
  const values2 = Object.values(attributes);
  const names = Object.keys(attributes).map((name) => isFilterElement || instance.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(/([A-Z])/g, (n) => "-" + n.toLowerCase())));
  if (children2 !== void 0) {
    instance.textContent = children2;
  }
  for (let name in style) {
    if (style.hasOwnProperty(name)) {
      const value = dangerousStyleValue(name, style[name]);
      if (isCustomPropRE.test(name)) {
        instance.style.setProperty(name, value);
      } else {
        instance.style[name] = value;
      }
    }
  }
  names.forEach((name, i) => {
    instance.setAttribute(name, values2[i]);
  });
  if (scrollTop !== void 0) {
    instance.scrollTop = scrollTop;
  }
  if (scrollLeft !== void 0) {
    instance.scrollLeft = scrollLeft;
  }
}
var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixKey = (prefix2, key) => prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
var prefixes = ["Webkit", "Ms", "Moz", "O"];
isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
  prefixes.forEach((prefix2) => acc[prefixKey(prefix2, prop)] = acc[prop]);
  return acc;
}, isUnitlessNumber);
var _excluded$1 = ["x", "y", "z"];
var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
var pxTransforms = /^(translate)/;
var degTransforms = /^(rotate|skew)/;
var addUnit = (value, unit) => is.num(value) && value !== 0 ? value + unit : value;
var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
var AnimatedStyle = class extends AnimatedObject {
  constructor(_ref) {
    let {
      x,
      y,
      z
    } = _ref, style = _objectWithoutPropertiesLoose4(_ref, _excluded$1);
    const inputs = [];
    const transforms = [];
    if (x || y || z) {
      inputs.push([x || 0, y || 0, z || 0]);
      transforms.push((xyz) => [`translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`, isValueIdentity(xyz, 0)]);
    }
    eachProp(style, (value, key) => {
      if (key === "transform") {
        inputs.push([value || ""]);
        transforms.push((transform) => [transform, transform === ""]);
      } else if (domTransforms.test(key)) {
        delete style[key];
        if (is.und(value)) return;
        const unit = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
        inputs.push(toArray(value));
        transforms.push(key === "rotate3d" ? ([x2, y2, z2, deg]) => [`rotate3d(${x2},${y2},${z2},${addUnit(deg, unit)})`, isValueIdentity(deg, 0)] : (input) => [`${key}(${input.map((v) => addUnit(v, unit)).join(",")})`, isValueIdentity(input, key.startsWith("scale") ? 1 : 0)]);
      }
    });
    if (inputs.length) {
      style.transform = new FluidTransform(inputs, transforms);
    }
    super(style);
  }
};
var FluidTransform = class extends FluidValue {
  constructor(inputs, transforms) {
    super();
    this._value = null;
    this.inputs = inputs;
    this.transforms = transforms;
  }
  get() {
    return this._value || (this._value = this._get());
  }
  _get() {
    let transform = "";
    let identity2 = true;
    each(this.inputs, (input, i) => {
      const arg1 = getFluidValue(input[0]);
      const [t, id] = this.transforms[i](is.arr(arg1) ? arg1 : input.map(getFluidValue));
      transform += " " + t;
      identity2 = identity2 && id;
    });
    return identity2 ? "none" : transform;
  }
  observerAdded(count) {
    if (count == 1) each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && addFluidObserver(value, this)));
  }
  observerRemoved(count) {
    if (count == 0) each(this.inputs, (input) => each(input, (value) => hasFluidValue(value) && removeFluidObserver(value, this)));
  }
  eventObserved(event) {
    if (event.type == "change") {
      this._value = null;
    }
    callFluidObservers(this, event);
  }
};
var primitives = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"];
var _excluded16 = ["scrollTop", "scrollLeft"];
globals.assign({
  batchedUpdates: import_react_dom3.unstable_batchedUpdates,
  createStringInterpolator,
  colors
});
var host = createHost(primitives, {
  applyAnimatedValues,
  createAnimatedStyle: (style) => new AnimatedStyle(style),
  getComponentProps: (_ref) => {
    let props = _objectWithoutPropertiesLoose4(_ref, _excluded16);
    return props;
  }
});
var animated = host.animated;

// node_modules/zmp-ui/esm/components/sheet/utils/constants.js
var DRAG_THRESHOLD = 100;
var ANIMATION_DURATION = 200;

// node_modules/zmp-ui/esm/components/sheet/hooks/useElementSize.js
var import_react42 = __toESM(require_react());

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index2) {
      if (entry[0] === key) {
        result = index2;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index2 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index2];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index2 = getIndex(this.__entries__, key);
        if (~index2) {
          this.__entries__[index2][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index2 = getIndex(entries, key);
        if (~index2) {
          entries.splice(index2, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx2) {
        if (ctx2 === void 0) {
          ctx2 = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx2, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }
    lastCallTime = timeStamp;
  }
  return proxy;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index2 = observers2.indexOf(observer);
      if (~index2) {
        observers2.splice(index2, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser2 || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser2 || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles) {
  var positions = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }
  return positions.reduce(function(size, position) {
    var value = styles["border-" + position + "-width"];
    return size + toFloat(value);
  }, 0);
}
function getPaddings(styles) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles.width), height = toFloat(styles.height);
  if (styles.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser2) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a) {
  var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
function createRectInit(x, y, width, height) {
  return { x, y, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx2 = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx2, entries, ctx2);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver.prototype[method] = function() {
    var _a;
    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});
var index = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver;
}();
var ResizeObserver_es_default = index;

// node_modules/zmp-ui/esm/components/sheet/hooks/useElementSize.js
var useElementSize = function useElementSize2(_ref) {
  var ref = _ref.ref;
  var _useState = (0, import_react42.useState)(0), size = _useState[0], setSize = _useState[1];
  var handleResize = function handleResize2(entries) {
    var _entries$0$borderBoxS;
    if (((_entries$0$borderBoxS = entries[0].borderBoxSize) == null ? void 0 : _entries$0$borderBoxS.length) > 0) {
      var _entries$0$borderBoxS2;
      setSize((_entries$0$borderBoxS2 = entries[0].borderBoxSize[0]) == null ? void 0 : _entries$0$borderBoxS2.blockSize);
    } else {
      setSize(entries[0].contentRect.height);
    }
  };
  (0, import_react42.useLayoutEffect)(function() {
    if (!ref || !ref.current) {
      return;
    }
    var resizeObserver = new ResizeObserver_es_default(handleResize);
    resizeObserver.observe(ref.current);
    return function() {
      resizeObserver.disconnect();
    };
  }, [ref]);
  return size || 0;
};
var useElementSize_default = useElementSize;

// node_modules/zmp-ui/esm/components/sheet/content.js
function ownKeys9(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread8(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys9(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys9(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Content2 = (0, import_react43.forwardRef)(function(props, ref) {
  var _classNames;
  var title = props.title, visible = props.visible, onVisibleChanged = props.onVisibleChanged, _props$handler = props.handler, handler = _props$handler === void 0 ? true : _props$handler, children2 = props.children, _props$autoHeight = props.autoHeight, autoHeight = _props$autoHeight === void 0 ? false : _props$autoHeight, contentRef = props.contentRef, onClose = props.onClose, swipeToClose = props.swipeToClose, style = props.style, height = props.height, snapPoints = props.snapPoints, _props$defaultSnapPoi = props.defaultSnapPoint, defaultSnapPoint = _props$defaultSnapPoi === void 0 ? 0 : _props$defaultSnapPoi, onSnap = props.onSnap;
  var handlerRef = (0, import_react43.useRef)();
  var _useState = (0, import_react43.useState)(defaultSnapPoint), currentSnapPoint = _useState[0], setCurrentSnapPoint = _useState[1];
  var sheetRef = (0, import_react43.useRef)();
  var sheetHeight = useElementSize_default({
    ref: sheetRef
  });
  var _useState2 = (0, import_react43.useState)({
    movement: [0, 0],
    down: false,
    first: false,
    vy: 0
  }), state = _useState2[0], set = _useState2[1];
  var getSnapPoints = function getSnapPoints2() {
    if (!snapPoints) return void 0;
    if (!sheetHeight) return void 0;
    if (typeof snapPoints === "function") {
      return snapPoints({
        sheetModalHeight: sheetHeight
      });
    }
    return snapPoints.map(function(item) {
      return item * sheetHeight;
    });
  };
  var sheetSnapPoints = getSnapPoints();
  var prevVisible = (0, import_react43.useRef)(false);
  var prefixCls = getPrefixCls("sheet-content");
  (0, import_react43.useImperativeHandle)(contentRef, function() {
    return sheetRef.current;
  });
  var down = state.down, movement = state.movement, vy = state.vy;
  var getDuration = function getDuration2(_ref) {
    var isVisible = _ref.visible, points = _ref.points, currentPoint = _ref.currentPoint, isDragging = _ref.down;
    if (isDragging) return 0;
    return !isVisible || !points || currentPoint === points.length - 1 ? ANIMATION_DURATION : void 0;
  };
  var animationConfig = _objectSpread8(_objectSpread8({}, config.stiff), {}, {
    duration: getDuration({
      visible,
      points: sheetSnapPoints,
      currentPoint: currentSnapPoint,
      down
    }),
    velocity: vy
  });
  var _useSpring = useSpring(function() {
    return {
      transformAmount: sheetHeight || window.innerHeight,
      movingAmount: 0,
      config: _objectSpread8({}, animationConfig)
    };
  }), _useSpring$ = _useSpring[0], transformAmount = _useSpring$.transformAmount, movingAmount = _useSpring$.movingAmount, api = _useSpring[1];
  var snapTo = function snapTo2(point) {
    setCurrentSnapPoint(point);
  };
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-hug-content"] = autoHeight, _classNames));
  (0, import_react43.useImperativeHandle)(ref, function() {
    return {
      sheet: sheetRef.current,
      snapTo
    };
  });
  (0, import_react43.useEffect)(function() {
    if (down) {
      return;
    }
    if (visible && sheetSnapPoints) {
      api.start({
        transformAmount: sheetSnapPoints[currentSnapPoint || 0],
        movingAmount: 0
      });
    } else if (visible && sheetHeight) {
      api.start({
        transformAmount: 0,
        movingAmount: 0
      });
    } else if (!visible) {
      api.start({
        transformAmount: sheetHeight || window.innerHeight,
        movingAmount: 0
      });
    }
  }, [visible, currentSnapPoint, sheetHeight]);
  (0, import_react43.useLayoutEffect)(function() {
    if (prevVisible.current) {
      setTimeout(function() {
        onVisibleChanged == null || onVisibleChanged(!!visible);
      }, ANIMATION_DURATION);
    }
    if (!visible && sheetSnapPoints && sheetSnapPoints.length && currentSnapPoint !== defaultSnapPoint) {
      setCurrentSnapPoint(defaultSnapPoint);
    }
    prevVisible.current = !!visible;
  }, [visible, onVisibleChanged]);
  (0, import_react43.useEffect)(function() {
    if (down) {
      api.set({
        movingAmount: movement[1]
      });
    }
  }, [down, movement, api]);
  var handlerDrag = function handlerDrag2(_ref2) {
    var isDragging = _ref2.down, first = _ref2.first, _ref2$velocity = _ref2.velocity, _vy = _ref2$velocity[1], movementValues = _ref2.movement, event = _ref2.event, memo = _ref2.memo;
    set({
      down: isDragging,
      movement: movementValues,
      first,
      vy: _vy
    });
    if (isDragging) return movementValues[1];
    var my = movementValues[1];
    if (memo && memo < 0 && !my) {
      my = memo;
    }
    if (my < 0 && my < -DRAG_THRESHOLD && sheetSnapPoints) {
      if (currentSnapPoint < sheetSnapPoints.length - 1) {
        onSnap == null || onSnap(currentSnapPoint + 1);
        setCurrentSnapPoint(currentSnapPoint + 1);
      } else if (!sheetSnapPoints) {
        api.start({
          transformAmount: 0,
          movingAmount: 0
        });
      }
      return my;
    }
    if (my > 0 && my > DRAG_THRESHOLD) {
      if (sheetSnapPoints && currentSnapPoint > 0) {
        onSnap == null || onSnap(currentSnapPoint - 1);
        setCurrentSnapPoint(currentSnapPoint - 1);
      } else {
        onClose == null || onClose(event);
      }
      return my;
    }
    if (sheetSnapPoints) {
      api.start({
        transformAmount: sheetSnapPoints[currentSnapPoint],
        movingAmount: 0
      });
    } else {
      api.start({
        transformAmount: 0,
        movingAmount: 0
      });
    }
    return my;
  };
  var bind = useDrag(handlerDrag, {
    filterTaps: true
  });
  var transform = to2([transformAmount, movingAmount], function(amount, moving) {
    if (amount + moving < 0) return "";
    return "translateY(" + (amount + moving) + "px)";
  });
  var header = import_react43.default.createElement("div", {
    className: prefixCls + "-header"
  }, import_react43.default.createElement("div", {
    className: prefixCls + "-title"
  }, title));
  var handlerEl = import_react43.default.createElement("div", _extends({
    ref: handlerRef,
    className: prefixCls + "-handler-wrapper"
  }, bind()), import_react43.default.createElement("span", {
    className: prefixCls + "-handler"
  }));
  var modalStyle = _objectSpread8({}, style || {});
  if (height) {
    modalStyle.height = height;
  }
  return import_react43.default.createElement(animated.div, _extends({
    style: _objectSpread8(_objectSpread8({}, modalStyle), {}, {
      transform
    })
  }, !handler && (swipeToClose || sheetSnapPoints) ? bind() : {}, {
    className: cls,
    ref: sheetRef
  }), handler && handlerEl, title && header, children2);
});
var content_default2 = Content2;

// node_modules/zmp-ui/esm/components/sheet/sheet.js
var Sheet = import_react45.default.forwardRef(function(props, ref) {
  var className = props.className, maskClosable = props.maskClosable, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, maskStyle = props.maskStyle, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskClassName = props.maskClassName, onClose = props.onClose, afterClose = props.afterClose, zIndex = props.zIndex, contentRef = props.contentRef, unmountOnClose = props.unmountOnClose;
  var _useState = (0, import_react45.useState)(false), animatedVisible = _useState[0], setAnimatedVisible = _useState[1];
  var _useState2 = (0, import_react45.useState)(!unmountOnClose), contentVisible = _useState2[0], setContentVisible = _useState2[1];
  var sheetRef = (0, import_react45.useRef)(null);
  (0, import_react45.useImperativeHandle)(contentRef, function() {
    var _sheetRef$current;
    return (_sheetRef$current = sheetRef.current) == null ? void 0 : _sheetRef$current.sheet;
  });
  (0, import_react45.useImperativeHandle)(ref, function() {
    var _sheetRef$current2, _sheetRef$current3;
    return {
      sheet: (_sheetRef$current2 = sheetRef.current) == null ? void 0 : _sheetRef$current2.sheet,
      snapTo: (_sheetRef$current3 = sheetRef.current) == null ? void 0 : _sheetRef$current3.snapTo
    };
  });
  (0, import_react45.useEffect)(function() {
    if (visible && unmountOnClose) {
      setContentVisible(true);
    }
    setAnimatedVisible(visible);
  }, [visible]);
  var prefixCls = getPrefixCls("sheet");
  var cls = clsx_m_default(prefixCls, {}, className);
  var handleAfterClose = function handleAfterClose2() {
    if (unmountOnClose) {
      setContentVisible(false);
    }
    afterClose == null || afterClose();
  };
  if (!contentVisible && unmountOnClose) {
    return null;
  }
  return import_react45.default.createElement("div", {
    className: cls
  }, mask && import_react45.default.createElement(modal_mask_default, {
    visible: animatedVisible,
    style: maskStyle,
    className: maskClassName
  }), import_react45.default.createElement(modal_wrapper_default, {
    maskClosable,
    visible: animatedVisible,
    onClose,
    afterClose: handleAfterClose,
    className: prefixCls + "-wrapper",
    style: {
      zIndex
    }
  }, import_react45.default.createElement(content_default2, _extends({}, props, {
    visible: animatedVisible,
    ref: sheetRef
  }))));
});
var sheet_default = Sheet;

// node_modules/zmp-ui/esm/components/sheet/action-sheet.js
var import_react46 = __toESM(require_react());
var _excluded17 = ["className", "actions", "title"];
var Action2 = import_react46.default.forwardRef(function(props, ref) {
  var className = props.className, actions = props.actions, title = props.title, rest = _objectWithoutPropertiesLoose(props, _excluded17);
  var sheetRef = (0, import_react46.useRef)(null);
  var prefixCls = getPrefixCls("action-sheet");
  var groups = actions || [];
  if (!Array.isArray(groups[0])) {
    groups = [groups.filter(function(group) {
      return !Array.isArray(group);
    })];
  }
  (0, import_react46.useImperativeHandle)(ref, function() {
    var _sheetRef$current;
    return (_sheetRef$current = sheetRef.current) == null ? void 0 : _sheetRef$current.sheet;
  });
  var cls = clsx_m_default(prefixCls, {}, className);
  var actionsChildren = groups.map(function(group, indx) {
    return import_react46.default.createElement("ul", {
      className: prefixCls + "-actions-group",
      key: "zaui-modal-action-group-key-" + indx
    }, group.map(function(action, index2) {
      var _classNames;
      var text = action.text, onClick = action.onClick, actionClassName = action.className, style = action.style, close = action.close, highLight = action.highLight, danger = action.danger, disabled = action.disabled;
      var onClose = props.onClose;
      var btnCls = clsx_m_default(actionClassName, prefixCls + "-action", (_classNames = {}, _classNames[prefixCls + "-action-highlight"] = highLight, _classNames));
      var onActionClick = function onActionClick2(e) {
        if (onClick) {
          onClick(e);
        }
        if (close && onClose) {
          onClose(e);
        }
      };
      var actionType = "neutral";
      if (highLight) {
        actionType = "highlight";
      }
      if (danger) {
        actionType = "danger";
      }
      return import_react46.default.createElement("li", {
        className: btnCls,
        key: action.key || "zaui-modal-action-key-" + index2
      }, import_react46.default.createElement(button_default, {
        type: actionType,
        style,
        variant: "tertiary",
        disabled,
        fullWidth: true,
        className: prefixCls + "-action-button",
        onClick: onActionClick
      }, text));
    }));
  }) || null;
  return import_react46.default.createElement(sheet_default, _extends({
    className: cls,
    ref: sheetRef,
    handler: false,
    title: void 0
  }, rest), title && import_react46.default.createElement("div", {
    className: prefixCls + "-title-wrapper"
  }, import_react46.default.createElement("div", {
    className: prefixCls + "-title"
  }, title)), actionsChildren && import_react46.default.createElement("div", {
    className: prefixCls + "-actions-groups"
  }, actionsChildren));
});
var action_sheet_default = Action2;

// node_modules/zmp-ui/esm/components/sheet/index.js
var Sheet2 = sheet_default;
Sheet2.Actions = action_sheet_default;
var sheet_default2 = Sheet2;

// node_modules/zmp-ui/esm/components/tabs/Tabs.js
var import_react54 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/tabs/TabContext.js
var import_react47 = __toESM(require_react());
var TabContext_default = (0, import_react47.createContext)({
  tabs: []
});

// node_modules/zmp-ui/esm/components/tabs/TabList.js
var import_react49 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/tabs/Tab.js
var import_react48 = __toESM(require_react());
function ownKeys10(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread9(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys10(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys10(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Tab = import_react48.default.forwardRef(function(props, ref) {
  var _classNames;
  var children2 = props.children, className = props.className, id = props.id, style = props.style, active = props.active, tabKey = props.tabKey, destroyInactiveTabPane = props.destroyInactiveTabPane;
  var _React$useState = import_react48.default.useState(active), visited = _React$useState[0], setVisited = _React$useState[1];
  (0, import_react48.useEffect)(function() {
    if (active) {
      setVisited(true);
    } else if (destroyInactiveTabPane) {
      setVisited(false);
    }
  }, [active, destroyInactiveTabPane]);
  var prefixCls = getPrefixCls("tab");
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-active"] = active, _classNames), className);
  var mergedStyle = {};
  if (!active) {
    mergedStyle.display = "none";
  }
  return import_react48.default.createElement("div", {
    id: id && id + "-tab-" + tabKey,
    role: "tabpanel",
    tabIndex: active ? 0 : -1,
    "aria-labelledby": id && id + "-tab-" + tabKey,
    "aria-hidden": !active,
    style: _objectSpread9(_objectSpread9({}, mergedStyle), style),
    ref,
    className: cls
  }, (active || visited) && children2);
});
var Tab_default = Tab;

// node_modules/zmp-ui/esm/components/tabs/TabList.js
var _excluded18 = ["key", "style", "className", "tabKey"];
var TabList = function TabList2(props) {
  var _useContext = (0, import_react49.useContext)(TabContext_default), tabs = _useContext.tabs;
  var activeKey = props.activeKey, id = props.id, destroyInactiveTabPane = props.destroyInactiveTabPane;
  var prefixCls = getPrefixCls("tab-content");
  var cls = clsx_m_default(prefixCls);
  return import_react49.default.createElement("div", {
    className: cls
  }, tabs.map(function(tab) {
    var key = tab.key, tabStyle = tab.style, tabClassName = tab.className, tabKey = tab.tabKey, restTabProps = _objectWithoutPropertiesLoose(tab, _excluded18);
    var active = key === activeKey;
    return import_react49.default.createElement(Tab_default, _extends({
      key
    }, restTabProps, {
      style: tabStyle,
      active,
      id,
      tabKey: tabKey || key,
      className: tabClassName,
      destroyInactiveTabPane
    }));
  }));
};
var TabList_default = TabList;

// node_modules/zmp-ui/esm/components/tabs/TabBar.js
var import_react51 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/tabs/TabBarItem.js
var import_react50 = __toESM(require_react());
var TabBarItem = import_react50.default.forwardRef(function(props, ref) {
  var _classNames;
  var id = props.id, style = props.style, _props$tab = props.tab, key = _props$tab.key, disabled = _props$tab.disabled, label = _props$tab.label, onClick = props.onClick, onFocus = props.onFocus, active = props.active;
  var prefixCls = getPrefixCls("tabs-tabbar-item");
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-active"] = active, _classNames));
  var onInternalClick = function onInternalClick2(e) {
    if (disabled) {
      return;
    }
    onClick == null || onClick(e);
  };
  return (
    // eslint-disable-next-line jsx-a11y/interactive-supports-focus
    import_react50.default.createElement("div", {
      ref,
      key,
      className: cls,
      style,
      "aria-controls": id && id + "-tab-" + key,
      tabIndex: disabled ? void 0 : 0,
      "aria-disabled": disabled,
      onClick: function onClick2(e) {
        e.stopPropagation();
        onInternalClick(e);
      },
      role: "tab",
      onFocus
    }, label)
  );
});
var TabBarItem_default = TabBarItem;

// node_modules/zmp-ui/esm/components/tabs/TabBar.js
var TabBar = import_react51.default.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, id = props.id, style = props.style, onTabClick = props.onTabClick, scrollable = props.scrollable, activeKey = props.activeKey;
  var _useContext = (0, import_react51.useContext)(TabContext_default), tabs = _useContext.tabs;
  var _useState = (0, import_react51.useState)({
    width: 0,
    left: 0
  }), activeLineStyles = _useState[0], setActiveLineStyles = _useState[1];
  var tabsWrapperRef = (0, import_react51.useRef)();
  var tabItemRefs = (0, import_react51.useRef)(/* @__PURE__ */ new Map());
  var getRef = function getRef2(key) {
    if (!tabItemRefs.current.has(key)) {
      tabItemRefs.current.set(key, import_react51.default.createRef());
    }
    return tabItemRefs.current.get(key);
  };
  var scrollToTab = (0, import_react51.useCallback)(function(key) {
    if (key === void 0) {
      key = activeKey;
    }
    var activeTab = getRef(key);
    if (activeTab && activeTab.current) {
      var _activeTab$current;
      var tabOffset = ((_activeTab$current = activeTab.current) == null ? void 0 : _activeTab$current.getBoundingClientRect()) || {};
      var left = tabOffset.left, right = tabOffset.right, width = tabOffset.width;
      var tabbar = ref;
      var scrollLeft = tabbar.current.scrollLeft;
      var tabbarWidth = tabbar == null ? void 0 : tabbar.current.clientWidth;
      if (!tabbarWidth) {
        return;
      }
      if (right >= tabbarWidth - 40) {
        tabbar.current.scrollTo({
          left: scrollLeft + (right - tabbarWidth) + 40,
          behavior: "smooth"
        });
        return;
      }
      if (left <= 40 && scrollLeft > 0) {
        tabbar.current.scrollTo({
          left: scrollLeft - (width - right + 40),
          behavior: "smooth"
        });
      }
    }
  }, [activeKey, ref]);
  var setLineStyles = (0, import_react51.useCallback)(function(key) {
    if (key === void 0) {
      key = activeKey;
    }
    var activeTab = getRef(key);
    if (activeTab && activeTab.current) {
      if (!activeTab.current.clientWidth) {
        return;
      }
      setActiveLineStyles({
        width: activeTab.current.clientWidth - 24,
        left: activeTab.current.offsetLeft + 12
      });
    }
  }, [activeKey]);
  (0, import_react51.useLayoutEffect)(function() {
    var refEl = ref;
    if (!refEl || !refEl.current) {
      return void 0;
    }
    var resizeObserver = new ResizeObserver_es_default(function() {
      if (refEl.current.clientWidth) {
        if (refEl.current.scrollWidth > refEl.current.clientWidth) {
          refEl.current.style.setProperty("--zaui-tabbar-width", refEl.current.scrollWidth + "px");
        }
        scrollToTab(activeKey);
        setLineStyles();
      }
    });
    resizeObserver.observe(refEl.current);
    return function() {
      resizeObserver.disconnect();
    };
  }, [activeKey]);
  var prefixCls = getPrefixCls("tabs-tabbar");
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-scrollable"] = scrollable, _classNames), className);
  (0, import_react51.useLayoutEffect)(function() {
    scrollToTab(activeKey);
    setLineStyles();
  }, [activeKey, scrollToTab, setLineStyles]);
  var tabNodes = tabs.map(function(tab) {
    var key = tab.key;
    return import_react51.default.createElement(TabBarItem_default, {
      key,
      ref: getRef(key),
      onClick: function onClick(e) {
        onTabClick == null || onTabClick(key, e);
      },
      active: key === activeKey,
      tab,
      id,
      onFocus: function onFocus() {
        if (!tabsWrapperRef.current) {
          return;
        }
        tabsWrapperRef.current.scrollTop = 0;
      }
    });
  });
  return import_react51.default.createElement("div", {
    ref,
    className: cls,
    style
  }, tabNodes, import_react51.default.createElement("span", {
    className: prefixCls + "-active-line",
    style: {
      width: activeLineStyles.width + "px",
      left: activeLineStyles.left + "px"
    }
  }));
});
var TabBar_default = TabBar;

// node_modules/zmp-ui/esm/components/tabs/utils/index.js
var import_react53 = __toESM(require_react());

// node_modules/zmp-ui/esm/utils/childrens.js
var import_react52 = __toESM(require_react());
var import_react_is2 = __toESM(require_react_is());
var toArray2 = function toArray3(children2, option) {
  if (option === void 0) {
    option = {};
  }
  var ret = [];
  import_react52.default.Children.forEach(children2, function(child) {
    if ((child === void 0 || child === null) && !option.keepEmpty) {
      return;
    }
    if (Array.isArray(child)) {
      ret = ret.concat(toArray3(child));
    } else if ((0, import_react_is2.isFragment)(child) && child.props) {
      ret = ret.concat(toArray3(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
};

// node_modules/zmp-ui/esm/components/tabs/utils/index.js
function ownKeys11(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread10(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys11(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys11(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var parseTabList = function parseTabList2(children2) {
  var tabs = toArray2(children2).map(function(node) {
    if (import_react53.default.isValidElement(node)) {
      var key = node.key !== void 0 ? String(node.key) : void 0;
      return _objectSpread10(_objectSpread10({
        key
      }, node.props), {}, {
        node
      });
    }
    return null;
  }).filter(function(tab) {
    return tab;
  });
  return tabs;
};

// node_modules/zmp-ui/esm/components/tabs/Tabs.js
function ownKeys12(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread11(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys12(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys12(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Tabs = import_react54.default.forwardRef(function(props, ref) {
  var _classNames;
  var children2 = props.children, className = props.className, activeKey = props.activeKey, defaultActiveKey = props.defaultActiveKey, id = props.id, onChange = props.onChange, onTabClick = props.onTabClick, renderTabBar = props.renderTabBar, scrollable = props.scrollable, bottomBar = props.bottomBar, destroyInactiveTabPane = props.destroyInactiveTabPane;
  var tabbarRef = (0, import_react54.useRef)();
  var tabs = parseTabList(children2);
  var tabKeys = tabs.map(function(tab) {
    return tab.key;
  }).join("_");
  var _useMergedState = useMergedState(function() {
    var _tabs$;
    return (_tabs$ = tabs[0]) == null ? void 0 : _tabs$.key;
  }, {
    value: activeKey,
    defaultValue: defaultActiveKey
  }), mergedActiveKey = _useMergedState[0], setMergedActiveKey = _useMergedState[1];
  var _useMergedState2 = useMergedState(null, {
    value: id
  }), mergedId = _useMergedState2[0];
  var _useState = (0, import_react54.useState)(function() {
    return tabs.findIndex(function(tab) {
      return tab.key === mergedActiveKey;
    });
  }), activeIndex = _useState[0], setActiveIndex = _useState[1];
  (0, import_react54.useEffect)(function() {
    var newActiveIndex = tabs.findIndex(function(tab) {
      return tab.key === mergedActiveKey;
    });
    if (newActiveIndex === -1) {
      var _tabs$newActiveIndex;
      newActiveIndex = Math.max(0, Math.min(activeIndex, tabs.length - 1));
      setMergedActiveKey((_tabs$newActiveIndex = tabs[newActiveIndex]) == null ? void 0 : _tabs$newActiveIndex.key);
    }
    setActiveIndex(newActiveIndex);
  }, [mergedActiveKey, activeIndex, tabs, tabKeys, setMergedActiveKey]);
  var onInternalTabClick = function onInternalTabClick2(key, e) {
    onTabClick == null || onTabClick(key, e);
    var isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange == null || onChange(key);
    }
  };
  var sharedProps = {
    id: mergedId || void 0,
    activeKey: mergedActiveKey
  };
  var prefixCls = getPrefixCls("tabs");
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-bottom"] = bottomBar, _classNames), className);
  var tabbarProps = _objectSpread11(_objectSpread11({}, sharedProps), {}, {
    onTabClick: onInternalTabClick,
    panes: children2,
    scrollable
  });
  var tabBar = renderTabBar ? renderTabBar(tabbarProps) : import_react54.default.createElement(TabBar_default, _extends({
    ref: tabbarRef
  }, tabbarProps, {
    id: tabbarProps.id || ""
  }));
  var tabContext = (0, import_react54.useMemo)(function() {
    return {
      tabs
    };
  }, [tabs]);
  return import_react54.default.createElement(TabContext_default.Provider, {
    value: tabContext
  }, import_react54.default.createElement("div", {
    ref,
    className: cls
  }, !bottomBar && tabBar, import_react54.default.createElement(TabList_default, _extends({
    destroyInactiveTabPane
  }, sharedProps)), bottomBar && tabBar));
});
var Tabs_default = Tabs;

// node_modules/zmp-ui/esm/components/tabs/index.js
var Tabs2 = Tabs_default;
Tabs2.Tab = Tab_default;
var tabs_default = Tabs2;

// node_modules/zmp-ui/esm/components/page/index.js
var import_react56 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/router/ZMPRouter.js
var import_react55 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/router/common/constant.js
var PAGE_TRANSITION_DIRECTION = {
  FORWARD: "forward",
  BACKWARD: "backward"
};
var ANIMATION_DURATION2 = 400;
var NO_ANIMATION_DURATION = 200;

// node_modules/zmp-ui/esm/components/router/ZMPRouter.js
var AnimationRouterContext = import_react55.default.createContext(void 0);
var ZMPRouter = function ZMPRouter2(props) {
  var _useState = (0, import_react55.useState)(true), animate = _useState[0], setAnimate = _useState[1];
  var _useState2 = (0, import_react55.useState)(PAGE_TRANSITION_DIRECTION.FORWARD), direction = _useState2[0], setDirection = _useState2[1];
  var pageScrollPosition = (0, import_react55.useRef)({});
  var children2 = props.children, memoryRouter = props.memoryRouter;
  var basepath = window.BASE_PATH || "";
  var urlParams = new URLSearchParams(window.location.search);
  var appEnv = urlParams.get("env");
  if (appEnv === "TESTING_LOCAL" || appEnv === "TESTING" || appEnv === "DEVELOPMENT") {
    basepath = "/zapps/" + window.APP_ID;
  }
  var handleSetAnimate = (0, import_react55.useCallback)(function(_ref) {
    var _ref$animate = _ref.animate, ani = _ref$animate === void 0 ? true : _ref$animate, _ref$direction = _ref.direction, dir = _ref$direction === void 0 ? PAGE_TRANSITION_DIRECTION.FORWARD : _ref$direction;
    setAnimate(!!ani);
    var correctDirection = [PAGE_TRANSITION_DIRECTION.FORWARD, PAGE_TRANSITION_DIRECTION.BACKWARD].some(function(item) {
      return item === dir;
    }) ? dir : PAGE_TRANSITION_DIRECTION.FORWARD;
    setDirection(correctDirection);
  }, [setAnimate, setDirection]);
  var updateScrollPosition = function updateScrollPosition2(key, position) {
    pageScrollPosition.current[key] = position;
  };
  var contextValue = (0, import_react55.useMemo)(function() {
    return {
      setAnimate: handleSetAnimate,
      animate,
      direction,
      pageScrollPosition: pageScrollPosition.current,
      updatePosition: updateScrollPosition
    };
  }, [animate, direction, handleSetAnimate]);
  var RouterComponent = memoryRouter ? MemoryRouter : BrowserRouter;
  var routerProps = memoryRouter ? {
    initialEntries: [basepath]
  } : {};
  return import_react55.default.createElement(AnimationRouterContext.Provider, {
    value: contextValue
  }, import_react55.default.createElement(RouterComponent, _extends({
    basename: basepath
  }, routerProps), children2));
};
var ZMPRouter_default = ZMPRouter;

// node_modules/zmp-ui/esm/components/page/index.js
var _excluded19 = ["className", "id", "style", "children", "resetScroll", "hideScrollbar", "restoreScroll", "restoreScrollOnBack", "name"];
var Page = import_react56.default.forwardRef(function(props, ref) {
  var _classNames;
  var routerContext = (0, import_react56.useContext)(AnimationRouterContext);
  var className = props.className, id = props.id, style = props.style, children2 = props.children, _props$resetScroll = props.resetScroll, resetScroll = _props$resetScroll === void 0 ? true : _props$resetScroll, _props$hideScrollbar = props.hideScrollbar, hideScrollbar = _props$hideScrollbar === void 0 ? false : _props$hideScrollbar, restoreScroll = props.restoreScroll, restoreScrollOnBack = props.restoreScrollOnBack, name = props.name, rest = _objectWithoutPropertiesLoose(props, _excluded19);
  var isScrolling = (0, import_react56.useRef)();
  if (!routerContext && (restoreScroll || restoreScrollOnBack)) {
    throw new Error("To use Scroll Restoration feature, Page must be contained with ZMPRouter.");
  }
  var location = useLocation();
  var getPageKey = function getPageKey2() {
    if (restoreScrollOnBack) {
      return location.key;
    }
    return name || location.pathname;
  };
  var prefixCls = getPrefixCls("page");
  var pageRef = (0, import_react56.useRef)();
  (0, import_react56.useImperativeHandle)(ref, function() {
    return pageRef.current;
  });
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-hide-scrollbar"] = hideScrollbar, _classNames), className);
  var positionKey = getPageKey();
  var onPageScroll = function onPageScroll2() {
    if (!routerContext) {
      return;
    }
    clearTimeout(isScrolling.current);
    isScrolling.current = setTimeout(function() {
      var _pageRef$current;
      var updatePosition = routerContext.updatePosition;
      updatePosition(positionKey, ((_pageRef$current = pageRef.current) == null ? void 0 : _pageRef$current.scrollTop) || 0);
    }, 150);
  };
  var restoreScrollPosition = (0, import_react56.useCallback)(function() {
    if (!routerContext) {
      return;
    }
    var pageScrollPosition = routerContext.pageScrollPosition;
    if (pageScrollPosition[positionKey] !== void 0 && restoreScrollOnBack || restoreScroll) {
      var _pageScrollPosition$p;
      pageRef.current.scrollTo(0, (_pageScrollPosition$p = pageScrollPosition == null ? void 0 : pageScrollPosition[positionKey]) != null ? _pageScrollPosition$p : 0);
    }
  }, [restoreScroll, restoreScrollOnBack, routerContext, positionKey]);
  (0, import_react56.useLayoutEffect)(function() {
    var page = pageRef.current;
    if (page && routerContext && (restoreScroll || restoreScrollOnBack)) {
      restoreScrollPosition();
      page == null || page.addEventListener("scroll", onPageScroll);
    }
    if (resetScroll && !restoreScroll && !restoreScrollOnBack) {
      page.scrollTo(0, 0);
    }
    return function() {
      if (page && routerContext && (restoreScroll || restoreScrollOnBack)) {
        page == null || page.removeEventListener("scroll", onPageScroll);
      }
    };
  }, [pageRef, resetScroll, restoreScroll, restoreScrollOnBack]);
  return import_react56.default.createElement("div", _extends({}, rest, {
    className: cls,
    id,
    style,
    ref: pageRef
  }), children2);
});
var page_default = Page;

// node_modules/zmp-ui/esm/components/router/AnimationRoutes.js
var import_react57 = __toESM(require_react());

// node_modules/zmp-ui/esm/utils/device.js
var iOS = function iOS2() {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
};

// node_modules/zmp-ui/esm/components/router/AnimationRoutes.js
var _excluded20 = ["element"];
function ownKeys13(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread12(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys13(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys13(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var AnimationRoutes = function AnimationRoutes2(props) {
  var _classNames;
  var navigationType = useNavigationType();
  var direction = (0, import_react57.useRef)(PAGE_TRANSITION_DIRECTION.FORWARD);
  var children2 = props.children;
  var context = (0, import_react57.useContext)(AnimationRouterContext);
  var _ref = context || {}, animate = _ref.animate, setAnimate = _ref.setAnimate, directionSetting = _ref.direction;
  var location = useLocation();
  var pathname = location.pathname;
  var initialX = (0, import_react57.useRef)(null);
  var initialY = (0, import_react57.useRef)(null);
  var nodeRefs = (0, import_react57.useRef)({});
  var prefixCls = getPrefixCls("routes");
  var getKey2 = function getKey3(path) {
    if (!path) return "";
    var pathToCompare = path.charAt(0) !== "/" ? "/" + path : path;
    if (pathToCompare.lastIndexOf("/") > 0) {
      pathToCompare = pathToCompare.substring(0, pathToCompare.length - 1);
    }
    return pathToCompare;
  };
  var getNodeRef = (0, import_react57.useCallback)(function(path) {
    var key = getKey2(path);
    if (!key) return null;
    if (!nodeRefs.current[String(key)]) {
      nodeRefs.current[String(key)] = (0, import_react57.createRef)();
    }
    return nodeRefs.current[String(key)];
  }, []);
  var routList = (0, import_react57.useMemo)(function() {
    return import_react57.Children.map(children2, function(child) {
      if (import_react57.default.isValidElement(child)) {
        var _child$props = child.props, element = _child$props.element, restProps = _objectWithoutPropertiesLoose(_child$props, _excluded20);
        if (!element || element.props.replace === true) return child;
        return _objectSpread12(_objectSpread12({}, child), {}, {
          props: _objectSpread12(_objectSpread12({}, restProps), {}, {
            element
          })
        });
      }
      return child;
    });
  }, [children2]);
  var startTouch = function startTouch2(e) {
    initialX.current = e.touches[0].clientX;
    initialY.current = e.touches[0].clientY;
  };
  var moveTouch = function moveTouch2(e) {
    if (initialX.current === null) {
      return;
    }
    if (initialY.current === null) {
      return;
    }
    var currentX = e.touches[0].clientX;
    var currentY = e.touches[0].clientY;
    var diffX = initialX.current - currentX;
    var diffY = initialY.current - currentY;
    if (initialX.current <= 24 && Math.abs(diffX) > Math.abs(diffY) && diffX <= 0 && animate) {
      e.preventDefault();
      setAnimate == null || setAnimate({
        animate: false
      });
      e.preventDefault();
    }
    initialX.current = null;
    initialY.current = null;
  };
  (0, import_react57.useEffect)(function() {
    var isIOS = iOS();
    if (isIOS) {
      document.addEventListener("touchstart", startTouch, {
        passive: false
      });
      document.addEventListener("touchmove", moveTouch, {
        passive: false
      });
    }
    return function() {
      if (isIOS) {
        document.removeEventListener("touchstart", startTouch);
        document.removeEventListener("touchmove", moveTouch);
      }
    };
  }, []);
  if (animate) {
    direction.current = navigationType === Action.Pop ? PAGE_TRANSITION_DIRECTION.BACKWARD : directionSetting || PAGE_TRANSITION_DIRECTION.FORWARD;
  }
  var animationCls = clsx_m_default((_classNames = {}, _classNames[prefixCls + "-" + direction.current] = animate, _classNames[prefixCls + "-no-animation"] = !animate, _classNames));
  var wrapperCls = clsx_m_default(prefixCls, {});
  var nodeRef = (0, import_react57.useMemo)(function() {
    return getNodeRef(pathname);
  }, [pathname, getNodeRef]);
  return import_react57.default.createElement(TransitionGroup_default, {
    className: wrapperCls,
    childFactory: function childFactory2(child) {
      return (0, import_react57.cloneElement)(child, {
        classNames: animationCls,
        timeout: animate ? ANIMATION_DURATION2 : NO_ANIMATION_DURATION
      });
    }
  }, import_react57.default.createElement(CSSTransition_default, {
    key: pathname,
    timeout: animate ? ANIMATION_DURATION2 : NO_ANIMATION_DURATION,
    onExited: function onExited() {
      setAnimate == null || setAnimate({
        animate: true,
        direction: PAGE_TRANSITION_DIRECTION.FORWARD
      });
    },
    nodeRef,
    unmountOnExit: true
  }, import_react57.default.createElement("div", {
    ref: nodeRef,
    className: prefixCls + "-item"
  }, import_react57.default.createElement(Routes, {
    location
  }, routList))));
};
var AnimationRoutes_default = AnimationRoutes;

// node_modules/zmp-ui/esm/components/router/index.js
var router_default = ZMPRouter_default;

// node_modules/zmp-ui/esm/components/text/Text.js
var import_react58 = __toESM(require_react());
var _excluded21 = ["className", "children", "style", "bold", "size"];
var Text = function Text2(props) {
  var _classNames;
  var className = props.className, children2 = props.children, style = props.style, bold = props.bold, size = props.size, rest = _objectWithoutPropertiesLoose(props, _excluded21);
  var prefixCls = getPrefixCls("text");
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-bold"] = bold, _classNames[prefixCls + "-" + size] = size, _classNames), className);
  return import_react58.default.createElement("span", _extends({}, rest, {
    className: cls,
    style
  }), children2);
};
var Text_default = Text;

// node_modules/zmp-ui/esm/components/text/TitleText.js
var import_react59 = __toESM(require_react());
var _excluded22 = ["className", "children", "style", "size"];
var Title = function Title2(props) {
  var _classNames;
  var className = props.className, children2 = props.children, style = props.style, size = props.size, rest = _objectWithoutPropertiesLoose(props, _excluded22);
  var prefixCls = getPrefixCls("text-title");
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-" + size] = size, _classNames), className);
  return import_react59.default.createElement("span", _extends({}, rest, {
    className: cls,
    style
  }), children2);
};
Title.displayName = "Text.Title";
var TitleText_default = Title;

// node_modules/zmp-ui/esm/components/text/HeaderText.js
var import_react60 = __toESM(require_react());
var _excluded23 = ["className", "children", "style", "size"];
var HeaderText = function HeaderText2(props) {
  var _classNames;
  var className = props.className, children2 = props.children, style = props.style, size = props.size, rest = _objectWithoutPropertiesLoose(props, _excluded23);
  var prefixCls = getPrefixCls("text-header");
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-" + size] = size, _classNames), className);
  return import_react60.default.createElement("span", _extends({}, rest, {
    className: cls,
    style
  }), children2);
};
HeaderText.displayName = "Text.Header";
var HeaderText_default = HeaderText;

// node_modules/zmp-ui/esm/components/text/index.js
var Text3 = Text_default;
Text3.Title = TitleText_default;
Text3.Header = HeaderText_default;
var text_default = Text3;

// node_modules/zmp-ui/esm/components/box/index.js
var import_react61 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/box/utils/constants.js
var BoxPropsKeys = function(BoxPropsKeys2) {
  BoxPropsKeys2["textAlign"] = "textAlign";
  BoxPropsKeys2["verticalAlign"] = "verticalAlign";
  BoxPropsKeys2["justifyContent"] = "justifyContent";
  BoxPropsKeys2["alignItems"] = "alignItems";
  BoxPropsKeys2["alignContent"] = "alignContent";
  BoxPropsKeys2["flexDirection"] = "flexDirection";
  return BoxPropsKeys2;
}({});
var BOX_PROPS = {
  textAlign: ["left", "right", "center", "justify", "initial", "inherit"],
  verticalAlign: ["baseline", "sub", "super", "top", "text-top", "middle", "bottom", "text-bottom", "initial", "inherit"],
  justifyContent: ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly", "initial"],
  alignItems: ["flex-start", "flex-end", "stretch", "baseline", "center", "initial"],
  alignContent: ["stretch", "center", "flex-start", "flex-end", "space-between", "space-around", "space-evenly"],
  flexDirection: ["row", "column", "row-reverse", "column-reverse"]
};

// node_modules/zmp-ui/esm/components/box/utils/index.js
var isValidBoxProps = function isValidBoxProps2(value, prop) {
  if (!value || !prop) return false;
  if (!BOX_PROPS[prop]) return false;
  return BOX_PROPS[prop].find(function(val) {
    return val === value;
  });
};
var validateSpacingNumber = function validateSpacingNumber2(num) {
  return !Number.isNaN(num) && num >= 0 && num <= 10;
};

// node_modules/zmp-ui/esm/components/box/index.js
var _excluded24 = ["id", "children", "className", "style", "m", "p", "mt", "ml", "mb", "mr", "mx", "my", "pt", "pl", "pb", "pr", "px", "py", "noSpace", "inline", "width", "height", "verticalAlign", "textAlign", "flex", "flexDirection", "flexWrap", "justifyContent", "alignItems", "alignContent"];
function ownKeys14(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread13(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys14(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys14(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Box = import_react61.default.forwardRef(function(props, ref) {
  var _classNames;
  var id = props.id, children2 = props.children, className = props.className, style = props.style, _props$m = props.m, m = _props$m === void 0 ? -1 : _props$m, _props$p = props.p, p = _props$p === void 0 ? -1 : _props$p, _props$mt = props.mt, mt = _props$mt === void 0 ? -1 : _props$mt, _props$ml = props.ml, ml = _props$ml === void 0 ? -1 : _props$ml, _props$mb = props.mb, mb = _props$mb === void 0 ? -1 : _props$mb, _props$mr = props.mr, mr = _props$mr === void 0 ? -1 : _props$mr, _props$mx = props.mx, mx = _props$mx === void 0 ? -1 : _props$mx, _props$my = props.my, my = _props$my === void 0 ? -1 : _props$my, _props$pt = props.pt, pt = _props$pt === void 0 ? -1 : _props$pt, _props$pl = props.pl, pl = _props$pl === void 0 ? -1 : _props$pl, _props$pb = props.pb, pb = _props$pb === void 0 ? -1 : _props$pb, _props$pr = props.pr, pr = _props$pr === void 0 ? -1 : _props$pr, _props$px = props.px, px = _props$px === void 0 ? -1 : _props$px, _props$py = props.py, py = _props$py === void 0 ? -1 : _props$py, noSpace = props.noSpace, inline = props.inline, width = props.width, height = props.height, _props$verticalAlign = props.verticalAlign, verticalAlign = _props$verticalAlign === void 0 ? "" : _props$verticalAlign, _props$textAlign = props.textAlign, textAlign = _props$textAlign === void 0 ? "" : _props$textAlign, flex = props.flex, _props$flexDirection = props.flexDirection, flexDirection = _props$flexDirection === void 0 ? "" : _props$flexDirection, flexWrap = props.flexWrap, _props$justifyContent = props.justifyContent, justifyContent = _props$justifyContent === void 0 ? "" : _props$justifyContent, _props$alignItems = props.alignItems, alignItems = _props$alignItems === void 0 ? "" : _props$alignItems, _props$alignContent = props.alignContent, alignContent = _props$alignContent === void 0 ? "" : _props$alignContent, rest = _objectWithoutPropertiesLoose(props, _excluded24);
  var prefixCls = getPrefixCls("box");
  var classes = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-no-space"] = noSpace, _classNames[prefixCls + "-inline"] = inline, _classNames[prefixCls + "-m-" + m] = validateSpacingNumber(m), _classNames[prefixCls + "-mt-" + mt] = validateSpacingNumber(mt), _classNames[prefixCls + "-ml-" + ml] = validateSpacingNumber(ml), _classNames[prefixCls + "-mb-" + mb] = validateSpacingNumber(mb), _classNames[prefixCls + "-mr-" + mr] = validateSpacingNumber(mr), _classNames[prefixCls + "-mx-" + mx] = validateSpacingNumber(mx), _classNames[prefixCls + "-my-" + my] = validateSpacingNumber(my), _classNames[prefixCls + "-p-" + p] = validateSpacingNumber(p), _classNames[prefixCls + "-pt-" + pt] = validateSpacingNumber(pt), _classNames[prefixCls + "-pl-" + pl] = validateSpacingNumber(pl), _classNames[prefixCls + "-pb-" + pb] = validateSpacingNumber(pb), _classNames[prefixCls + "-pr-" + pr] = validateSpacingNumber(pr), _classNames[prefixCls + "-px-" + px] = validateSpacingNumber(px), _classNames[prefixCls + "-py-" + py] = validateSpacingNumber(py), _classNames[prefixCls + "-flex"] = flex, _classNames[prefixCls + "-flex-" + flexDirection] = isValidBoxProps(flexDirection, BoxPropsKeys.flexDirection), _classNames[prefixCls + "-vertical-align-" + verticalAlign] = isValidBoxProps(verticalAlign, BoxPropsKeys.verticalAlign), _classNames[prefixCls + "-text-align-" + textAlign] = isValidBoxProps(textAlign, BoxPropsKeys.textAlign), _classNames[prefixCls + "-flex-wrap"] = flexWrap === true, _classNames[prefixCls + "-flex-nowrap"] = flexWrap === false, _classNames[prefixCls + "-justify-" + justifyContent] = isValidBoxProps(justifyContent, BoxPropsKeys.justifyContent), _classNames[prefixCls + "-align-items-" + alignItems] = isValidBoxProps(alignItems, BoxPropsKeys.alignItems), _classNames[prefixCls + "-align-content-" + alignContent] = isValidBoxProps(alignContent, BoxPropsKeys.alignContent), _classNames), className);
  var boxStyle = _objectSpread13({}, style || {});
  if (width) {
    boxStyle.width = width;
  }
  if (height) {
    boxStyle.height = height;
  }
  return import_react61.default.createElement("div", _extends({}, rest, {
    ref,
    id,
    style: boxStyle,
    className: classes
  }), children2);
});
var box_default = Box;

// node_modules/zmp-ui/esm/components/checkbox/Checkbox.js
var import_react64 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/checkbox/context.js
var import_react62 = __toESM(require_react());
var GroupContext = (0, import_react62.createContext)(null);

// node_modules/zmp-ui/esm/components/checkbox/TickIcon.js
var import_react63 = __toESM(require_react());
var TickIcon = function TickIcon2() {
  return import_react63.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 14 11",
    fill: "none"
  }, import_react63.default.createElement("path", {
    d: "M1.5 5.5L5 9L12.5 1.5",
    stroke: "currentColor",
    strokeWidth: "3",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
};
var TickIcon_default = TickIcon;

// node_modules/zmp-ui/esm/components/checkbox/Checkbox.js
var _excluded25 = ["className", "children", "disabled", "style", "defaultChecked", "size", "label", "indeterminate"];
function ownKeys15(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread14(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys15(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys15(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Checkbox = import_react64.default.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, children2 = props.children, disabled = props.disabled, style = props.style, defaultChecked = props.defaultChecked, size = props.size, label = props.label, _props$indeterminate = props.indeterminate, indeterminate = _props$indeterminate === void 0 ? false : _props$indeterminate, restProps = _objectWithoutPropertiesLoose(props, _excluded25);
  var checkboxGroup = (0, import_react64.useContext)(GroupContext);
  var mergedDisabled = disabled || (checkboxGroup == null ? void 0 : checkboxGroup.disabled);
  var checkboxRef = (0, import_react64.useRef)();
  var checkboxProps = _objectSpread14({}, restProps);
  if (checkboxGroup) {
    checkboxProps.name = checkboxGroup.name;
    checkboxProps.checked = checkboxGroup.value.indexOf(restProps.value) !== -1;
  }
  var _useState = (0, import_react64.useState)("checked" in restProps ? restProps.checked : defaultChecked), checked = _useState[0], setChecked = _useState[1];
  (0, import_react64.useEffect)(function() {
    checkboxGroup == null || checkboxGroup.registerValue == null || checkboxGroup.registerValue(restProps.value);
  }, []);
  (0, import_react64.useImperativeHandle)(ref, function() {
    return checkboxRef == null ? void 0 : checkboxRef.current;
  });
  var prefixCls = getPrefixCls("checkbox");
  var checkboxSize = size || (checkboxGroup == null ? void 0 : checkboxGroup.size);
  var inputChecked = checkboxProps.checked !== void 0 ? checkboxProps.checked : checked;
  var cls = clsx_m_default(prefixCls + "-wrapper", (_classNames = {}, _classNames[prefixCls + "-checked"] = inputChecked, _classNames[prefixCls + "-disabled"] = mergedDisabled, _classNames[prefixCls + "-" + checkboxSize] = checkboxSize, _classNames[prefixCls + "-indeterminate"] = !inputChecked && indeterminate, _classNames), className);
  var checkboxCls = clsx_m_default(["" + prefixCls], {});
  var ariaChecked = indeterminate ? "mixed" : void 0;
  var handleOnChange = function handleOnChange2(e) {
    if (!("checked" in checkboxProps)) {
      setChecked(e.target.checked);
    }
    if (checkboxGroup && checkboxGroup.toggleOption) {
      checkboxGroup.toggleOption({
        label: children2 || label,
        value: restProps.value
      });
    }
    restProps.onChange == null || restProps.onChange({
      target: _objectSpread14(_objectSpread14({}, props), {}, {
        checked: e.target.checked
      }),
      stopPropagation: function stopPropagation() {
        e.stopPropagation();
      },
      preventDefault: function preventDefault() {
        e.preventDefault();
      },
      nativeEvent: e.nativeEvent
    });
  };
  return (
    // eslint-disable-next-line jsx-a11y/label-has-associated-control
    import_react64.default.createElement("label", {
      className: cls,
      style
    }, import_react64.default.createElement("span", {
      className: checkboxCls
    }, import_react64.default.createElement("input", _extends({}, checkboxProps, {
      className: prefixCls + "-input",
      checked: !!inputChecked,
      ref: checkboxRef,
      type: "checkbox",
      "aria-checked": ariaChecked,
      disabled,
      onChange: handleOnChange
    })), import_react64.default.createElement("span", {
      className: prefixCls + "-inner"
    }, !!inputChecked && import_react64.default.createElement("span", {
      className: prefixCls + "-inner-check-icon"
    }, import_react64.default.createElement(TickIcon_default, null)))), (children2 || label) && import_react64.default.createElement("span", null, children2 || label))
  );
});
var Checkbox_default = Checkbox;

// node_modules/zmp-ui/esm/components/checkbox/Group.js
var import_react65 = __toESM(require_react());
var _excluded26 = ["className", "defaultValue", "children", "options", "onChange"];
var Group3 = import_react65.default.forwardRef(function(props, ref) {
  var className = props.className, defaultValue = props.defaultValue, children2 = props.children, _props$options = props.options, options = _props$options === void 0 ? [] : _props$options, onChange = props.onChange, restProps = _objectWithoutPropertiesLoose(props, _excluded26);
  var inputChildren = children2;
  var _useState = (0, import_react65.useState)(restProps.value || defaultValue || []), value = _useState[0], setValue = _useState[1];
  var _React$useState = import_react65.default.useState([]), registeredValues = _React$useState[0], setRegisteredValues = _React$useState[1];
  (0, import_react65.useEffect)(function() {
    if ("value" in restProps) {
      setValue(restProps.value || []);
    }
  }, [restProps, restProps.value]);
  var prefixCls = getPrefixCls("checkbox-group");
  var cls = clsx_m_default(prefixCls, className);
  var getOptions = (0, import_react65.useCallback)(function() {
    return options.map(function(option) {
      if (typeof option === "string" || typeof option === "number") {
        return {
          label: option,
          value: option
        };
      }
      return option;
    });
  }, [options]);
  if (options && options.length > 0) {
    inputChildren = getOptions().map(function(option) {
      return import_react65.default.createElement(Checkbox_default, {
        key: option.value.toString(),
        disabled: "disabled" in option ? option.disabled : restProps.disabled,
        name: option.name,
        value: option.value,
        checked: value.indexOf(option.value) !== -1,
        onChange: option.onChange,
        className: clsx_m_default(prefixCls + "-item", option.className),
        style: option.style,
        label: option.label
      });
    });
  }
  var registerValue = (0, import_react65.useCallback)(function(val) {
    setRegisteredValues(function(vals) {
      return [].concat(vals, [val]);
    });
  }, []);
  var toggleOption = (0, import_react65.useCallback)(function(option) {
    var optionIndex = value.indexOf(option.value);
    var newValue = [].concat(value);
    if (optionIndex === -1) {
      newValue.push(option.value);
    } else {
      newValue.splice(optionIndex, 1);
    }
    if (!("value" in restProps)) {
      setValue(newValue);
    }
    var opts = getOptions();
    onChange == null || onChange(newValue.filter(function(val) {
      return registeredValues.indexOf(val) !== -1;
    }).sort(function(a, b) {
      var indexA = opts.findIndex(function(opt) {
        return opt.value === a;
      });
      var indexB = opts.findIndex(function(opt) {
        return opt.value === b;
      });
      return indexA - indexB;
    }));
  }, [getOptions, onChange, registeredValues, restProps, value]);
  var contextValue = (0, import_react65.useMemo)(function() {
    return {
      value,
      disabled: restProps.disabled,
      name: restProps.name,
      toggleOption,
      registerValue,
      size: restProps.size
    };
  }, [value, restProps.disabled, restProps.name, toggleOption, registerValue, restProps.size]);
  return import_react65.default.createElement("div", {
    className: cls,
    ref
  }, import_react65.default.createElement(GroupContext.Provider, {
    value: contextValue
  }, inputChildren));
});
var Group_default = Group3;

// node_modules/zmp-ui/esm/components/checkbox/index.js
var Checkbox2 = Checkbox_default;
Checkbox2.Group = Group_default;
var checkbox_default = Checkbox2;

// node_modules/zmp-ui/esm/components/radio/Radio.js
var import_react67 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/radio/context.js
var import_react66 = __toESM(require_react());
var GroupContext2 = (0, import_react66.createContext)(null);
var context_default = GroupContext2;

// node_modules/zmp-ui/esm/components/radio/Radio.js
var _excluded27 = ["className", "children", "style", "disabled", "size", "label", "defaultChecked"];
function ownKeys16(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread15(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys16(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys16(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Radio = import_react67.default.forwardRef(function(props, ref) {
  var _classNames, _classNames2;
  var groupContext = (0, import_react67.useContext)(context_default);
  var prefixCls = getPrefixCls("radio");
  var className = props.className, children2 = props.children, style = props.style, disabled = props.disabled, size = props.size, label = props.label, defaultChecked = props.defaultChecked, restProps = _objectWithoutPropertiesLoose(props, _excluded27);
  var _useState = (0, import_react67.useState)("checked" in restProps ? restProps.checked : defaultChecked), checked = _useState[0], setChecked = _useState[1];
  var radioProps = _objectSpread15({}, restProps);
  radioProps.disabled = disabled;
  var onChange = function onChange2(e) {
    if (!("checked" in radioProps)) {
      setChecked(e.target.checked);
    }
    props.onChange == null || props.onChange(e);
    groupContext == null || groupContext.onChange == null || groupContext.onChange(e);
  };
  if (groupContext) {
    var _props$value, _groupContext$value;
    radioProps.name = groupContext.name;
    radioProps.checked = ((_props$value = props.value) == null ? void 0 : _props$value.toString()) === ((_groupContext$value = groupContext.value) == null ? void 0 : _groupContext$value.toString());
    radioProps.disabled = radioProps.disabled || groupContext.disabled;
  }
  var radioSize = (groupContext == null ? void 0 : groupContext.size) || size;
  var inputChecked = radioProps.checked !== void 0 ? radioProps.checked : checked;
  var wrapperCls = clsx_m_default(prefixCls + "-wrapper", (_classNames = {}, _classNames[prefixCls + "-" + radioSize] = radioSize, _classNames), className);
  var radioCls = clsx_m_default(prefixCls, (_classNames2 = {}, _classNames2[prefixCls + "-checked"] = inputChecked, _classNames2[prefixCls + "-disabled"] = radioProps.disabled, _classNames2));
  return (
    // eslint-disable-next-line jsx-a11y/label-has-associated-control
    import_react67.default.createElement("label", {
      className: wrapperCls,
      style
    }, import_react67.default.createElement("span", {
      className: radioCls
    }, import_react67.default.createElement("input", _extends({}, radioProps, {
      checked: !!inputChecked,
      onChange,
      type: "radio",
      className: prefixCls + "-input",
      ref
    })), import_react67.default.createElement("span", {
      className: prefixCls + "-checkmark"
    })), children2 !== void 0 ? import_react67.default.createElement("span", null, children2) : import_react67.default.createElement("span", null, label))
  );
});
var Radio_default = Radio;

// node_modules/zmp-ui/esm/components/radio/Group.js
var import_react68 = __toESM(require_react());
var RadioGroup = function RadioGroup2(props) {
  var className = props.className, options = props.options, disabled = props.disabled, children2 = props.children, size = props.size, name = props.name, style = props.style, propValue = props.value, defaultValue = props.defaultValue;
  var _useState = (0, import_react68.useState)(propValue || defaultValue), value = _useState[0], setValue = _useState[1];
  var onRadioChange = (0, import_react68.useCallback)(function(e) {
    var lastValue = value;
    var val = e.target.value;
    if (!("value" in props)) {
      setValue(val);
    }
    var onChange = props.onChange;
    if (onChange && val !== lastValue) {
      onChange(val);
    }
  }, [props, value]);
  (0, import_react68.useLayoutEffect)(function() {
    if (propValue) {
      setValue(propValue);
    }
  }, [propValue]);
  var prefixCls = getPrefixCls("radio-group");
  var childrenRadio = children2;
  if (options && options.length > 0) {
    childrenRadio = options.map(function(option) {
      return import_react68.default.createElement(Radio_default, {
        key: "radio-group-value-options-" + option.value,
        className: prefixCls + "-item",
        disabled: option.disabled || disabled,
        value: option.value,
        checked: value === option.value,
        style: option.style,
        size
      }, option.label);
    });
  }
  var contextValue = (0, import_react68.useMemo)(function() {
    return {
      onChange: onRadioChange,
      value,
      disabled: !!disabled,
      name,
      size
    };
  }, [disabled, name, onRadioChange, size, value]);
  var cls = clsx_m_default(prefixCls, className);
  return import_react68.default.createElement("div", {
    className: cls,
    style
  }, import_react68.default.createElement(context_default.Provider, {
    value: contextValue
  }, childrenRadio));
};
RadioGroup.displayName = "Radio.Group";
var Group_default2 = RadioGroup;

// node_modules/zmp-ui/esm/components/radio/index.js
var Radio2 = Radio_default;
Radio2.Group = Group_default2;
var radio_default = Radio2;

// node_modules/zmp-ui/esm/components/switch/index.js
var import_react69 = __toESM(require_react());
var _excluded28 = ["className", "wrapperClassName", "size", "label"];
var Switch = import_react69.default.forwardRef(function(props, ref) {
  var _clsx, _clsx2;
  var className = props.className, wrapperClassName = props.wrapperClassName, size = props.size, label = props.label, rest = _objectWithoutPropertiesLoose(props, _excluded28);
  var prefixCls = getPrefixCls("switch");
  var Wrapper = label ? "label" : "div";
  return import_react69.default.createElement(Wrapper, {
    className: clsx_m_default(prefixCls + "-wrapper")
  }, import_react69.default.createElement("input", _extends({}, rest, {
    ref,
    type: "checkbox",
    className: clsx_m_default(prefixCls, (_clsx = {}, _clsx[prefixCls + "-small"] = size === "small", _clsx), className)
  })), label && import_react69.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-label", (_clsx2 = {}, _clsx2[prefixCls + "-label-small"] = size === "small", _clsx2))
  }, label));
});
var switch_default = Switch;

// node_modules/zmp-ui/esm/components/progress/index.js
var import_react70 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/progress/utils/index.js
var getPercent = function getPercent2(completed, maxCompleted) {
  if (completed <= 0 || maxCompleted <= 0) {
    return 0;
  }
  if (completed > maxCompleted) {
    return 100;
  }
  return Math.round(completed / maxCompleted * 100 * 100) / 100;
};

// node_modules/zmp-ui/esm/components/progress/index.js
function ownKeys17(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread16(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys17(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys17(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Progress = import_react70.default.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, _props$maxCompleted = props.maxCompleted, maxCompleted = _props$maxCompleted === void 0 ? 100 : _props$maxCompleted, _props$completed = props.completed, completed = _props$completed === void 0 ? 0 : _props$completed, strokeWidth = props.strokeWidth, strokeColor = props.strokeColor, _props$trailColor = props.trailColor, trailColor = _props$trailColor === void 0 ? null : _props$trailColor, formatLabel = props.formatLabel, showLabel = props.showLabel;
  var prefixCls = getPrefixCls("progress");
  var strokeStyle = {};
  var trailStyle = {};
  if (typeof strokeColor === "string") {
    strokeStyle = {
      background: strokeColor
    };
  }
  if (typeof trailColor === "string") {
    trailStyle = {
      background: trailColor
    };
  }
  var percent = getPercent(completed, maxCompleted);
  var progressStyle = _objectSpread16({
    width: percent + "%"
  }, strokeStyle);
  if (strokeWidth) {
    trailStyle.height = strokeWidth + "px";
  }
  var label = null;
  if (showLabel) {
    label = formatLabel ? formatLabel(completed, maxCompleted) : percent + "%";
  }
  var cls = clsx_m_default(prefixCls, (_classNames = {}, _classNames[prefixCls + "-show-label"] = showLabel, _classNames), className);
  return import_react70.default.createElement("div", {
    ref,
    className: cls
  }, import_react70.default.createElement("div", {
    className: prefixCls + "-outer"
  }, import_react70.default.createElement("div", {
    className: prefixCls + "-inner",
    style: trailStyle
  }, import_react70.default.createElement("div", {
    className: prefixCls + "-completed",
    style: progressStyle
  }))), import_react70.default.createElement("span", {
    className: prefixCls + "-label"
  }, label));
});
var progress_default = Progress;

// node_modules/zmp-ui/esm/components/spinner/index.js
var import_react71 = __toESM(require_react());
var Spinner = import_react71.default.forwardRef(function(props, ref) {
  var prefixCls = getPrefixCls("spinner");
  var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$logo = props.logo, logo = _props$logo === void 0 ? null : _props$logo;
  var cls = clsx_m_default(prefixCls);
  if (!visible) {
    return null;
  }
  var logoEl = typeof logo === "string" ? import_react71.default.createElement("img", {
    src: logo,
    alt: "spinner"
  }) : logo;
  return import_react71.default.createElement("div", {
    ref,
    className: cls
  }, import_react71.default.createElement("div", {
    className: prefixCls + "-ring"
  }), import_react71.default.createElement("div", {
    className: prefixCls + "-dot"
  }), import_react71.default.createElement("div", {
    className: prefixCls + "-logo"
  }, logoEl));
});
var spinner_default = Spinner;

// node_modules/zmp-ui/esm/components/slider/Slider.js
var import_react75 = __toESM(require_react());

// node_modules/zmp-ui/esm/utils/clamp.js
function clamp2(value, min, max) {
  return Math.min(Math.max(value, min), max);
}

// node_modules/zmp-ui/esm/utils/get-position.js
function getPosition(_ref) {
  var value = _ref.value, min = _ref.min, max = _ref.max;
  var position = (value - min) / (max - min) * 100;
  return Math.min(Math.max(position, 0), 100);
}

// node_modules/zmp-ui/esm/components/slider/Track.js
var import_react73 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/slider/Mark.js
var import_react72 = __toESM(require_react());
var Mark = function Mark2(props) {
  var _clsx;
  var position = props.position, filled = props.filled;
  var prefixCls = getPrefixCls("slider-mark");
  return import_react72.default.createElement("div", {
    className: clsx_m_default(prefixCls, (_clsx = {}, _clsx[prefixCls + "-filled"] = filled, _clsx)),
    style: {
      left: position + "%"
    }
  });
};
var Mark_default = Mark;

// node_modules/zmp-ui/esm/components/slider/Track.js
var Track = import_react73.default.forwardRef(function(props, ref) {
  var children2 = props.children, offset = props.offset, width = props.width, marks = props.marks, onMouseLeave = props.onMouseLeave, onMouseEnter = props.onMouseEnter;
  var prefixCls = getPrefixCls("slider-track");
  return import_react73.default.createElement("div", {
    ref,
    className: clsx_m_default(prefixCls),
    onMouseLeave,
    onMouseEnter
  }, import_react73.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-bar"),
    style: {
      left: offset + "%",
      width: width + "%"
    }
  }), marks && Array.isArray(marks) && marks.map(function(mark) {
    return import_react73.default.createElement(Mark_default, {
      key: mark,
      position: mark,
      filled: mark >= offset && mark <= width + offset
    });
  }), children2);
});
var Track_default = Track;

// node_modules/zmp-ui/esm/utils/get-change-value.js
function getChangeValue(_ref) {
  var value = _ref.value, containerWidth = _ref.containerWidth, min = _ref.min, max = _ref.max, step = _ref.step, precision = _ref.precision;
  var left = !containerWidth ? value : Math.min(Math.max(value, 0), containerWidth) / containerWidth;
  var dx = left * (max - min);
  var nextValue = (dx !== 0 ? Math.round(dx / step) * step : 0) + min;
  if (precision !== void 0) {
    return Number(nextValue.toFixed(precision));
  }
  return nextValue;
}

// node_modules/zmp-ui/esm/components/slider/Thumb.js
var import_react74 = __toESM(require_react());
var Thumb = function Thumb2(props) {
  var position = props.position;
  var prefixCls = getPrefixCls("slider-thumb");
  return import_react74.default.createElement("div", {
    className: clsx_m_default(prefixCls),
    style: {
      left: position + "%"
    }
  });
};
var Thumb_default = Thumb;

// node_modules/zmp-ui/esm/components/slider/Slider.js
var Slider = function Slider2(props) {
  var rawValue = props.value, defaultValue = props.defaultValue, name = props.name, label = props.label, showValue = props.showValue, renderValue = props.renderValue, prefix2 = props.prefix, suffix = props.suffix, _props$min = props.min, min = _props$min === void 0 ? 0 : _props$min, _props$max = props.max, max = _props$max === void 0 ? 100 : _props$max, _props$step = props.step, step = _props$step === void 0 ? 1 : _props$step, _props$minRange = props.minRange, minRange = _props$minRange === void 0 ? 1 : _props$minRange, _props$marks = props.marks, marks = _props$marks === void 0 ? false : _props$marks, onChange = props.onChange;
  var prefixCls = getPrefixCls("slider");
  var _useMergedState = useMergedState(defaultValue || 0, {
    value: rawValue
  }), value = _useMergedState[0], setValue = _useMergedState[1];
  var valueRender = (0, import_react75.useMemo)(function() {
    if (!showValue) return null;
    if (renderValue) {
      return renderValue(value);
    }
    return Array.isArray(value) ? value.join(" - ") : value;
  }, [value, showValue, renderValue]);
  var _useMemo = (0, import_react75.useMemo)(function() {
    if (!Array.isArray(value)) {
      return {
        offset: 0,
        position: getPosition({
          min,
          max,
          value: value || 0
        })
      };
    }
    var start2 = getPosition({
      min,
      max,
      value: value[0]
    });
    var end = getPosition({
      min,
      max,
      value: value[1]
    });
    return {
      offset: start2,
      position: end - start2
    };
  }, [value, min, max]), offset = _useMemo.offset, position = _useMemo.position;
  var markList = (0, import_react75.useMemo)(function() {
    if (!marks) return void 0;
    if (marks !== true) return marks.map(function(mark) {
      return getPosition({
        min,
        max,
        value: mark
      });
    });
    var stepCount = (max - min) / step;
    var list = [];
    for (var i = 0; i <= stepCount; i += 1) {
      var markValue = min + i * step;
      var markPosition = getPosition({
        min,
        max,
        value: markValue
      });
      list.push(markPosition);
    }
    return list;
  }, [marks, min, max, step]);
  var isSliding = (0, import_react75.useRef)(false);
  var frame = (0, import_react75.useRef)(0);
  var trackRef = (0, import_react75.useRef)(null);
  var thumbIndex = (0, import_react75.useRef)(0);
  var handleChange = function handleChange2(_ref) {
    var x = _ref.x;
    var nextValue = getChangeValue({
      value: x,
      min,
      max,
      step
    });
    if (!Array.isArray(value)) {
      setValue(nextValue);
      onChange == null || onChange(nextValue);
    } else {
      var start2 = value[0], end = value[1];
      if (thumbIndex.current === 0) {
        var endValue = clamp2(end - nextValue < minRange ? nextValue + step : end, min, max);
        if (endValue - nextValue < minRange) return;
        var newValue = [nextValue, endValue];
        setValue(newValue);
        onChange == null || onChange(newValue);
      } else {
        var startValue = clamp2(nextValue - start2 < minRange ? nextValue - step : start2, min, max);
        if (nextValue - startValue < minRange) return;
        var cloneValue = [startValue, nextValue];
        setValue(cloneValue);
        onChange == null || onChange(cloneValue);
      }
    }
  };
  var handleMove = function handleMove2(_ref2, checkNearest) {
    var x = _ref2.x;
    cancelAnimationFrame(frame.current);
    frame.current = requestAnimationFrame(function() {
      if (trackRef.current) {
        var rect = trackRef.current.getBoundingClientRect();
        if (rect.width && rect.height) {
          var tempX = clamp2((x - rect.left) / rect.width, 0, 1);
          if (checkNearest) {
            if (Array.isArray(value)) {
              var start2 = value[0], end = value[1];
              var middle = (start2 + end) / 2;
              var nextValue = getChangeValue({
                value: tempX,
                min,
                max,
                step
              });
              thumbIndex.current = nextValue < middle ? 0 : 1;
            } else {
              thumbIndex.current = 0;
            }
          }
          handleChange({
            x: tempX
          });
        }
      }
    });
  };
  var handleMouseDown = function handleMouseDown2(event) {
    isSliding.current = true;
    handleMove({
      x: event.clientX,
      y: event.clientY
    }, true);
  };
  var handleMouseMove = function handleMouseMove2(e) {
    if (isSliding.current) {
      handleMove({
        x: e.clientX,
        y: e.clientY
      });
    }
  };
  var handleMouseUp = function handleMouseUp2() {
    isSliding.current = false;
  };
  var handleTouchStart = function handleTouchStart2(event) {
    isSliding.current = true;
    handleMove({
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    }, true);
  };
  var handleTouchMove = function handleTouchMove2(e) {
    if (e.cancelable) e.preventDefault();
    isSliding.current = true;
    handleMove({
      x: e.touches[0].clientX,
      y: e.touches[0].clientY
    });
  };
  var handleTouchEnd = function handleTouchEnd2() {
    isSliding.current = false;
  };
  return import_react75.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-wrapper")
  }, (label || showValue) && import_react75.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-header")
  }, import_react75.default.createElement(text_default, {
    className: clsx_m_default(prefixCls + "-label")
  }, label), import_react75.default.createElement(text_default, {
    size: "small",
    bold: true,
    className: clsx_m_default(prefixCls + "-value")
  }, valueRender)), import_react75.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-content")
  }, prefix2 && import_react75.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-prefix")
  }, prefix2), import_react75.default.createElement("div", {
    role: "presentation",
    className: clsx_m_default(prefixCls + "-handler"),
    onMouseDown: handleMouseDown,
    onMouseMove: handleMouseMove,
    onMouseUp: handleMouseUp,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd
  }, import_react75.default.createElement(Track_default, {
    ref: trackRef,
    width: position,
    offset,
    marks: markList
  }, Array.isArray(value) && import_react75.default.createElement(Thumb_default, {
    position: offset
  }), import_react75.default.createElement(Thumb_default, {
    position: offset + position
  }))), suffix && import_react75.default.createElement("div", {
    className: clsx_m_default(prefixCls + "-suffix")
  }, suffix)), Array.isArray(value) ? import_react75.default.createElement(import_react75.default.Fragment, null, import_react75.default.createElement("input", {
    type: "hidden",
    name: name ? name + "_from" : void 0,
    value: value[0]
  }), import_react75.default.createElement("input", {
    type: "hidden",
    name: name ? name + "_to" : void 0,
    value: value[1]
  })) : import_react75.default.createElement("input", {
    type: "hidden",
    name,
    value
  }));
};
var Slider_default = Slider;

// node_modules/zmp-ui/esm/components/slider/index.js
var Slider3 = Slider_default;
var slider_default = Slider3;

// node_modules/zmp-ui/esm/components/header/index.js
var import_react76 = __toESM(require_react());
function ownKeys18(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread17(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys18(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys18(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Header = import_react76.default.forwardRef(function(props, ref) {
  var navigate = useNavigate();
  var _props$showBackIcon = props.showBackIcon, showBackIcon = _props$showBackIcon === void 0 ? true : _props$showBackIcon, backIcon = props.backIcon, onBackClick = props.onBackClick, title = props.title, className = props.className, style = props.style, id = props.id, backgroundColor = props.backgroundColor, textColor = props.textColor;
  var prefixCls = getPrefixCls("header");
  var cls = clsx_m_default(prefixCls, {}, className);
  var handleBackClick = function handleBackClick2(event) {
    if (onBackClick) {
      onBackClick(event);
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    navigate(-1);
  };
  var backIconEl = backIcon || import_react76.default.createElement(icon_default, {
    icon: "zi-chevron-left"
  });
  var componentStyle = _objectSpread17({}, style);
  if (backgroundColor) {
    componentStyle.backgroundColor = backgroundColor;
  }
  if (textColor) {
    componentStyle.color = textColor;
  }
  return import_react76.default.createElement("div", {
    ref,
    className: cls,
    style: componentStyle,
    id
  }, showBackIcon && import_react76.default.createElement("span", {
    className: prefixCls + "-back"
  }, import_react76.default.createElement(button_default, {
    className: prefixCls + "-back-btn",
    type: "neutral",
    variant: "tertiary",
    onClick: handleBackClick,
    style: {
      color: textColor
    },
    icon: backIconEl
  })), import_react76.default.createElement("span", {
    className: prefixCls + "-title"
  }, title));
});
var header_default = Header;

// node_modules/zmp-ui/esm/components/select/Option.js
var Option = function Option2() {
  return null;
};
Option.isSelectOption = true;
var Option_default = Option;

// node_modules/zmp-ui/esm/components/select/OtpGroup.js
var OptGroup = function OptGroup2() {
  return null;
};
OptGroup.isSelectOptGroup = true;
var OtpGroup_default = OptGroup;

// node_modules/zmp-ui/esm/components/select/Select.js
var import_react83 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/select/SelectTrigger.js
var import_react80 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/trigger/index.js
var import_react79 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/trigger/context.js
var import_react77 = __toESM(require_react());
var TriggerContext = import_react77.default.createContext({
  onPopupMouseDown: function onPopupMouseDown() {
    return {};
  }
});
var context_default2 = TriggerContext;

// node_modules/zmp-ui/esm/utils/addEventListener.js
var import_react_dom4 = __toESM(require_react_dom());
function addEventListenerWrap(target, eventType, cb, option) {
  var callback = import_react_dom4.default.unstable_batchedUpdates ? function run(e) {
    import_react_dom4.default.unstable_batchedUpdates(cb, e);
  } : cb;
  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }
  return {
    remove: function remove() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}

// node_modules/zmp-ui/esm/utils/raf.js
var raf2 = function raf3(callback) {
  return +setTimeout(callback, 16);
};
var caf = function caf2(num) {
  return clearTimeout(num);
};
if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
  raf2 = function raf4(callback) {
    return window.requestAnimationFrame(callback);
  };
  caf = function caf3(handle) {
    return window.cancelAnimationFrame(handle);
  };
}
var rafUUID = 0;
var rafIds = /* @__PURE__ */ new Map();
function cleanup(id) {
  rafIds["delete"](id);
}
function wrapperRaf(callback, times) {
  if (times === void 0) {
    times = 1;
  }
  rafUUID += 1;
  var id = rafUUID;
  function callRef(leftTimes) {
    if (leftTimes === 0) {
      cleanup(id);
      callback();
    } else {
      var realId = raf2(function() {
        callRef(leftTimes - 1);
      });
      rafIds.set(id, realId);
    }
  }
  callRef(times);
  return id;
}
wrapperRaf.cancel = function(id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};

// node_modules/zmp-ui/esm/utils/contains.js
function contains(root, n) {
  if (!root) {
    return false;
  }
  return root.contains(n);
}

// node_modules/zmp-ui/esm/components/portal/index.js
var import_react78 = __toESM(require_react());
var import_react_dom5 = __toESM(require_react_dom());
function canUseDom() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
var Portal = (0, import_react78.forwardRef)(function(props, ref) {
  var didUpdate = props.didUpdate, getContainer = props.getContainer, children2 = props.children;
  var parentRef = (0, import_react78.useRef)();
  var containerRef = (0, import_react78.useRef)();
  (0, import_react78.useImperativeHandle)(ref, function() {
    return {};
  });
  var initRef = (0, import_react78.useRef)(false);
  if (!initRef.current && canUseDom()) {
    containerRef.current = getContainer();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  }
  (0, import_react78.useEffect)(function() {
    didUpdate == null || didUpdate(props);
  });
  (0, import_react78.useEffect)(function() {
    var _containerRef$current;
    if ((containerRef == null || (_containerRef$current = containerRef.current) == null ? void 0 : _containerRef$current.parentNode) === null && parentRef.current !== null) {
      var _parentRef$current;
      parentRef == null || (_parentRef$current = parentRef.current) == null || _parentRef$current.appendChild(containerRef.current);
    }
    return function() {
      var _containerRef$current2;
      (_containerRef$current2 = containerRef.current) == null || (_containerRef$current2 = _containerRef$current2.parentNode) == null || _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? import_react_dom5.default.createPortal(children2, containerRef.current) : null;
});
var portal_default = Portal;

// node_modules/zmp-ui/esm/components/trigger/index.js
function ownKeys19(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread18(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys19(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys19(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var noop4 = function noop5() {
  return {};
};
function returnEmptyString() {
  return "";
}
function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }
  return window.document;
}
var ALL_HANDLERS = ["onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur", "onContextMenu"];
function generateTrigger(PortalComponent) {
  var Trigger = function(_React$Component) {
    _inheritsLoose(Trigger2, _React$Component);
    function Trigger2(props) {
      var _this;
      _this = _React$Component.call(this, props) || this;
      _defineProperty(_assertThisInitialized(_this), "sheetRef", import_react79.default.createRef());
      _defineProperty(_assertThisInitialized(_this), "triggerRef", import_react79.default.createRef());
      _defineProperty(_assertThisInitialized(_this), "portalContainer", void 0);
      _defineProperty(_assertThisInitialized(_this), "attachId", void 0);
      _defineProperty(_assertThisInitialized(_this), "clickOutsideHandler", void 0);
      _defineProperty(_assertThisInitialized(_this), "touchOutsideHandler", void 0);
      _defineProperty(_assertThisInitialized(_this), "mouseDownTimeout", void 0);
      _defineProperty(_assertThisInitialized(_this), "focusTime", void 0);
      _defineProperty(_assertThisInitialized(_this), "preClickTime", void 0);
      _defineProperty(_assertThisInitialized(_this), "preTouchTime", void 0);
      _defineProperty(_assertThisInitialized(_this), "delayTimer", void 0);
      _defineProperty(_assertThisInitialized(_this), "hasPopupMouseDown", void 0);
      _defineProperty(_assertThisInitialized(_this), "eventHandlers", {});
      _defineProperty(_assertThisInitialized(_this), "onFocus", function(e) {
        var focusDelay = _this.props.focusDelay;
        _this.fireEvents("onFocus", e);
        _this.clearDelayTimer();
        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();
          if (focusDelay) _this.delaySetPopupVisible(true, focusDelay);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onMouseDown", function(e) {
        _this.fireEvents("onMouseDown", e);
        _this.preClickTime = Date.now();
      });
      _defineProperty(_assertThisInitialized(_this), "onTouchStart", function(e) {
        _this.fireEvents("onTouchStart", e);
        _this.preTouchTime = Date.now();
      });
      _defineProperty(_assertThisInitialized(_this), "onBlur", function(e) {
        var blurDelay = _this.props.blurDelay;
        _this.fireEvents("onBlur", e);
        _this.clearDelayTimer();
        if (_this.isBlurToHide() && blurDelay) {
          _this.delaySetPopupVisible(false, blurDelay);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
        event.stopPropagation();
        var popupVisible = _this.state.popupVisible;
        _this.fireEvents("onClick", event);
        if (_this.focusTime) {
          var preTime;
          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }
          if (preTime && Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }
          _this.focusTime = 0;
        }
        _this.preClickTime = 0;
        _this.preTouchTime = 0;
        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }
        var nextVisible = !popupVisible;
        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!popupVisible);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onPopupMouseDown", function() {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function() {
          _this.hasPopupMouseDown = false;
        }, 0);
        if (_this.context) {
          var _ref = _this.context, onPopupMouseDown2 = _ref.onPopupMouseDown;
          onPopupMouseDown2.apply(void 0, arguments);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "onDocumentClick", function(event) {
        var _this$props = _this.props, mask = _this$props.mask, maskClosable = _this$props.maskClosable, popupType = _this$props.popupType;
        if (mask && !maskClosable || popupType === "sheet") {
          return;
        }
        var target = event.target;
        var root = _this.getRootDomNode();
        var popupNode = _this.getPopupDomNode();
        if (!contains(root, target) && !contains(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      });
      _defineProperty(_assertThisInitialized(_this), "getRootDomNode", function() {
        var _this$triggerRef$curr;
        return ((_this$triggerRef$curr = _this.triggerRef.current) == null ? void 0 : _this$triggerRef$curr.input) || _this.triggerRef.current;
      });
      _defineProperty(_assertThisInitialized(_this), "getComponent", function() {
        var _this$props2 = _this.props, popupClassName = _this$props2.popupClassName, popupStyle = _this$props2.popupStyle, mask = _this$props2.mask, maskClosable = _this$props2.maskClosable, zIndex = _this$props2.zIndex, popup = _this$props2.popup, onPopupVisibleChange = _this$props2.onPopupVisibleChange;
        var sheetAnimationVisible = _this.state.sheetAnimationVisible;
        var mouseProps = {};
        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return import_react79.default.createElement(sheet_default2, _extends({
          visible: sheetAnimationVisible,
          className: popupClassName
        }, mouseProps, {
          style: popupStyle,
          mask,
          maskClosable,
          onClose: function onClose() {
            _this.close();
          },
          afterClose: function afterClose() {
            _this.setState({
              popupVisible: false,
              sheetAnimationVisible: false,
              prevPopupVisible: false
            });
            onPopupVisibleChange == null || onPopupVisibleChange(false);
          },
          zIndex,
          handler: false,
          contentRef: _this.sheetRef
        }), typeof popup === "function" ? popup() : popup);
      });
      _defineProperty(_assertThisInitialized(_this), "attachParent", function(popupContainer) {
        if (_this.attachId) wrapperRaf.cancel(_this.attachId);
        var _this$props3 = _this.props, getPopupContainer = _this$props3.getPopupContainer, getDocument = _this$props3.getDocument;
        var domNode = _this.getRootDomNode();
        var mountNode;
        if (!getPopupContainer) {
          mountNode = getDocument == null ? void 0 : getDocument(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          mountNode = getPopupContainer(domNode);
        }
        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          _this.attachId = wrapperRaf(function() {
            _this.attachParent(popupContainer);
          });
        }
      });
      _defineProperty(_assertThisInitialized(_this), "getContainer", function() {
        if (!_this.portalContainer) {
          var getDocument = _this.props.getDocument;
          var popupContainer = getDocument == null ? void 0 : getDocument(_this.getRootDomNode()).createElement("div");
          if (popupContainer) {
            popupContainer.style.position = "absolute";
            popupContainer.style.top = "0";
            popupContainer.style.left = "0";
            popupContainer.style.width = "100%";
          }
          _this.portalContainer = popupContainer;
        }
        if (_this.portalContainer) _this.attachParent(_this.portalContainer);
        return _this.portalContainer;
      });
      _defineProperty(_assertThisInitialized(_this), "handlePortalUpdate", function() {
        var _this$state = _this.state, prevPopupVisible = _this$state.prevPopupVisible, popupVisible = _this$state.popupVisible;
        var afterPopupVisibleChange = _this.props.afterPopupVisibleChange;
        if (prevPopupVisible !== popupVisible) {
          afterPopupVisibleChange == null || afterPopupVisibleChange(popupVisible);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "triggerContextValue", {
        onPopupMouseDown: _this.onPopupMouseDown
      });
      var _popupVisible;
      if ("popupVisible" in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }
      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible,
        sheetAnimationVisible: false
      };
      ALL_HANDLERS.forEach(function(h) {
        _this.eventHandlers["fire" + h] = function(e) {
          _this.fireEvents(h, e);
        };
      });
      return _this;
    }
    var _proto = Trigger2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.componentDidUpdate();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      var props = this.props;
      var state = this.state;
      if (state.popupVisible) {
        var currentDocument;
        if (!this.clickOutsideHandler && this.isClickToHide()) {
          currentDocument = props.getDocument == null ? void 0 : props.getDocument(this.getRootDomNode());
          this.clickOutsideHandler = addEventListenerWrap(currentDocument, "mousedown", this.onDocumentClick);
        }
        if (!this.touchOutsideHandler) {
          currentDocument = currentDocument || (props.getDocument == null ? void 0 : props.getDocument(this.getRootDomNode()));
          this.touchOutsideHandler = addEventListenerWrap(currentDocument, "touchstart", this.onDocumentClick);
        }
        return;
      }
      this.clearOutsideHandler();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.clearDelayTimer();
      this.clearOutsideHandler();
      clearTimeout(this.mouseDownTimeout);
      if (this.attachId) wrapperRaf.cancel(this.attachId);
    };
    _proto.setPopupVisible = function setPopupVisible(popupVisible) {
      var onPopupVisibleChange = this.props.onPopupVisibleChange;
      var prevPopupVisible = this.state.popupVisible;
      this.clearDelayTimer();
      if (prevPopupVisible !== popupVisible) {
        if (popupVisible) {
          if (!("popupVisible" in this.props)) {
            this.setState({
              popupVisible,
              prevPopupVisible,
              sheetAnimationVisible: popupVisible
            });
          } else {
            this.setState({
              sheetAnimationVisible: popupVisible,
              prevPopupVisible
            });
          }
          onPopupVisibleChange == null || onPopupVisibleChange(popupVisible);
        } else {
          this.setState({
            sheetAnimationVisible: popupVisible,
            prevPopupVisible
          });
        }
      }
    };
    Trigger2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref2, prevState) {
      var popupVisible = _ref2.popupVisible;
      var newState = {};
      if (popupVisible !== void 0 && prevState.popupVisible !== popupVisible) {
        if (popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
          newState.sheetAnimationVisible = true;
        } else {
          newState.sheetAnimationVisible = popupVisible;
          newState.prevPopupVisible = prevState.prevPopupVisible;
        }
      }
      return newState;
    };
    _proto.getPopupDomNode = function getPopupDomNode() {
      return this.sheetRef.current || null;
    };
    _proto.delaySetPopupVisible = function delaySetPopupVisible(visible, delayS) {
      var _this2 = this;
      var delay = delayS * 1e3;
      this.clearDelayTimer();
      if (delay) {
        this.delayTimer = window.setTimeout(function() {
          _this2.setPopupVisible(visible);
          _this2.clearDelayTimer();
        }, delay);
      } else {
        this.setPopupVisible(visible);
      }
    };
    _proto.clearDelayTimer = function clearDelayTimer() {
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
        this.delayTimer = null;
      }
    };
    _proto.clearOutsideHandler = function clearOutsideHandler() {
      if (this.clickOutsideHandler) {
        this.clickOutsideHandler.remove();
        this.clickOutsideHandler = null;
      }
      if (this.touchOutsideHandler) {
        this.touchOutsideHandler.remove();
        this.touchOutsideHandler = null;
      }
    };
    _proto.createTwoChains = function createTwoChains(event) {
      var children2 = this.props.children;
      var childPros = children2.props;
      var props = this.props;
      if (childPros[event] && props[event]) {
        return this.eventHandlers["fire" + event];
      }
      return childPros[event] || props[event];
    };
    _proto.isClickToShow = function isClickToShow() {
      var _this$props4 = this.props, action = _this$props4.action, showAction = _this$props4.showAction;
      return (action == null ? void 0 : action.indexOf("click")) !== -1 || (showAction == null ? void 0 : showAction.indexOf("click")) !== -1;
    };
    _proto.isClickToHide = function isClickToHide() {
      var _this$props5 = this.props, action = _this$props5.action, hideAction = _this$props5.hideAction;
      return (action == null ? void 0 : action.indexOf("click")) !== -1 || (hideAction == null ? void 0 : hideAction.indexOf("click")) !== -1;
    };
    _proto.isFocusToShow = function isFocusToShow() {
      var _this$props6 = this.props, action = _this$props6.action, showAction = _this$props6.showAction;
      return (action == null ? void 0 : action.indexOf("focus")) !== -1 || (showAction == null ? void 0 : showAction.indexOf("focus")) !== -1;
    };
    _proto.isBlurToHide = function isBlurToHide() {
      var _this$props7 = this.props, action = _this$props7.action, hideAction = _this$props7.hideAction;
      return (action == null ? void 0 : action.indexOf("focus")) !== -1 || (hideAction == null ? void 0 : hideAction.indexOf("blur")) !== -1;
    };
    _proto.fireEvents = function fireEvents(type, e) {
      var children2 = this.props.children;
      var childCallback = children2.props[type];
      if (childCallback) {
        childCallback(e);
      }
      var callback = this.props[type];
      if (callback) {
        callback(e);
      }
    };
    _proto.close = function close() {
      this.setPopupVisible(false);
    };
    _proto.render = function render() {
      var popupVisible = this.state.popupVisible;
      var _this$props8 = this.props, children2 = _this$props8.children, forceRender = _this$props8.forceRender, className = _this$props8.className, autoDestroy = _this$props8.autoDestroy;
      var child = import_react79.default.Children.only(children2);
      var newChildProps = {
        key: "trigger"
      };
      if (this.isClickToHide() || this.isClickToShow()) {
        newChildProps.onClick = this.onClick;
        newChildProps.onInputTriggerClick = this.onClick;
        newChildProps.onMouseDown = this.onMouseDown;
        newChildProps.onTouchStart = this.onTouchStart;
      } else {
        newChildProps.onClick = this.createTwoChains("onClick");
        newChildProps.onInputTriggerClick = this.createTwoChains("onClick");
        newChildProps.onMouseDown = this.createTwoChains("onMouseDown");
        newChildProps.onTouchStart = this.createTwoChains("onTouchStart");
      }
      if (this.isFocusToShow() || this.isBlurToHide()) {
        newChildProps.onFocus = this.onFocus;
        newChildProps.onBlur = this.onBlur;
      } else {
        newChildProps.onFocus = this.createTwoChains("onFocus");
        newChildProps.onBlur = this.createTwoChains("onBlur");
      }
      var childrenClassName = clsx_m_default(child && child.props && child.props.className, className);
      if (childrenClassName) {
        newChildProps.className = childrenClassName;
      }
      var cloneProps = _objectSpread18({}, newChildProps);
      if (supportRef(child)) {
        cloneProps.ref = composeRef(this.triggerRef, child.ref);
      }
      var trigger = import_react79.default.cloneElement(child, cloneProps);
      var portal = null;
      if (popupVisible || forceRender) {
        portal = import_react79.default.createElement(PortalComponent, {
          key: "portal",
          getContainer: this.getContainer,
          didUpdate: this.handlePortalUpdate
        }, this.getComponent());
      }
      if (!popupVisible && autoDestroy) {
        portal = null;
      }
      return import_react79.default.createElement(context_default2.Provider, {
        value: this.triggerContextValue
      }, trigger, portal);
    };
    return Trigger2;
  }(import_react79.default.Component);
  _defineProperty(Trigger, "defaultProps", void 0);
  Trigger.contextType = context_default2;
  Trigger.defaultProps = {
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: noop4,
    afterPopupVisibleChange: noop4,
    onPopupAlign: noop4,
    popupClassName: "",
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false,
    zIndex: 1001,
    popupType: "sheet"
  };
  return Trigger;
}
var trigger_default = generateTrigger(portal_default);

// node_modules/zmp-ui/esm/components/select/SelectTrigger.js
var PickerTrigger = function PickerTrigger2(props) {
  var children2 = props.children, popupElement = props.popupElement, _props$defaultOpen = props.defaultOpen, defaultOpen = _props$defaultOpen === void 0 ? false : _props$defaultOpen, visible = props.visible, onVisibilityChange = props.onVisibilityChange, mask = props.mask, maskCloseable = props.maskCloseable;
  return import_react80.default.createElement(trigger_default, {
    action: "click",
    defaultPopupVisible: defaultOpen,
    popupVisible: visible,
    onPopupVisibleChange: onVisibilityChange,
    popup: popupElement,
    mask,
    maskClosable: maskCloseable
  }, children2);
};
var SelectTrigger_default = PickerTrigger;

// node_modules/zmp-ui/esm/components/select/SelectPanel.js
var import_react82 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/select/context.js
var import_react81 = __toESM(require_react());
var Context = (0, import_react81.createContext)(null);

// node_modules/zmp-ui/esm/components/select/SelectPanel.js
var SelectPanel = function SelectPanel2(props) {
  var className = props.className, optionsList = props.optionsList, title = props.title;
  var selectContext = (0, import_react82.useContext)(Context);
  var _ref = selectContext, disabled = _ref.disabled, value = _ref.value, updateValue = _ref.updateValue, closeSelectSheet = _ref.closeSelectSheet;
  var prefixCls = getPrefixCls("select");
  var panelPrefixCls = prefixCls + "-panel";
  var cls = clsx_m_default(panelPrefixCls, {}, className);
  var renderOptions = function renderOptions2(options) {
    var content = [];
    options.forEach(function(otp) {
      if (otp.group) {
        content.push(import_react82.default.createElement("div", {
          className: prefixCls + "-group",
          key: otp.key
        }, otp.label));
      } else {
        var _otp$value, _classNames;
        var isSelected = Array.isArray(value) ? value.find(function(val) {
          return val === otp.value;
        }) : value.toString() === (otp == null || (_otp$value = otp.value) == null ? void 0 : _otp$value.toString());
        var itemCls = clsx_m_default(prefixCls + "-option", (_classNames = {}, _classNames[prefixCls + "-option-selected"] = isSelected, _classNames[prefixCls + "-option-disabled"] = disabled || otp.data.disabled, _classNames));
        content.push(import_react82.default.createElement("div", {
          key: otp.value,
          className: itemCls,
          role: "presentation",
          onClick: function onClick() {
            if (!disabled && !otp.data.disabled && otp.value !== void 0) {
              updateValue == null || updateValue(otp.value);
            }
          }
        }, otp.data.children || import_react82.default.createElement("span", null, otp.label), isSelected && import_react82.default.createElement(icon_default, {
          className: prefixCls + "-option-check-icon",
          icon: "zi-check"
        })));
      }
    });
    return content;
  };
  var closeModal = function closeModal2() {
    closeSelectSheet == null || closeSelectSheet();
  };
  return import_react82.default.createElement("div", {
    className: cls
  }, import_react82.default.createElement("div", {
    className: prefixCls + "-header"
  }, import_react82.default.createElement("div", {
    className: prefixCls + "-title"
  }, title), import_react82.default.createElement(button_default, {
    type: "neutral",
    variant: "tertiary",
    className: prefixCls + "-close-icon",
    icon: import_react82.default.createElement(icon_default, {
      icon: "zi-close"
    }),
    onClick: closeModal
  })), import_react82.default.createElement("div", {
    className: prefixCls + "-options"
  }, renderOptions(optionsList)));
};
var SelectPanel_default = SelectPanel;

// node_modules/zmp-ui/esm/components/select/utils/options.js
var React77 = __toESM(require_react());
var _excluded29 = ["children", "value"];
var _excluded210 = ["children"];
function ownKeys20(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread19(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys20(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys20(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
function convertNodeToOption(node) {
  var _ref = node, key = _ref.key, _ref$props = _ref.props, children2 = _ref$props.children, value = _ref$props.value, restProps = _objectWithoutPropertiesLoose(_ref$props, _excluded29);
  return _objectSpread19({
    key,
    value: value !== void 0 ? value : key,
    children: children2
  }, restProps);
}
function convertChildrenToData(nodes, optionOnly) {
  if (optionOnly === void 0) {
    optionOnly = false;
  }
  return toArray2(nodes).map(function(node, index2) {
    if (!React77.isValidElement(node) || !node.type) {
      return null;
    }
    var _ref2 = node, isSelectOptGroup = _ref2.type.isSelectOptGroup, key = _ref2.key, _ref2$props = _ref2.props, children2 = _ref2$props.children, restProps = _objectWithoutPropertiesLoose(_ref2$props, _excluded210);
    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }
    return _objectSpread19(_objectSpread19({
      key: "__ZAUI_SELECT_GRP__" + (key === null ? index2 : key) + "__",
      label: key
    }, restProps), {}, {
      options: convertChildrenToData(children2)
    });
  }).filter(function(data) {
    return data !== null;
  });
}
function getKey(data, index2) {
  var key = data.key;
  var value = data.value;
  if (key !== null && key !== void 0) {
    return key;
  }
  if (value !== void 0) {
    return value;
  }
  return "zaui-index-key-" + index2;
}
function flattenOptions(options) {
  var flattenList = [];
  function dig(list, isGroupOption) {
    list.forEach(function(data) {
      var label = data.label;
      if (isGroupOption || !("options" in data)) {
        var value = data.value;
        flattenList.push({
          key: getKey(data, flattenList.length),
          groupOption: isGroupOption,
          data,
          label: data.title,
          value
        });
      } else {
        flattenList.push({
          key: getKey(data, flattenList.length),
          group: true,
          data,
          label
        });
        dig(data.options, true);
      }
    });
  }
  dig(options, false);
  return flattenList;
}

// node_modules/zmp-ui/esm/components/select/Select.js
var _excluded30 = ["className", "defaultOpen", "label", "status", "helperText", "errorText", "placeholder", "children", "defaultValue", "disabled", "mask", "maskCloseable", "multiple", "onChange", "closeOnSelect", "onVisibilityChange"];
var Select = import_react83.default.forwardRef(function(props, ref) {
  var className = props.className, defaultOpen = props.defaultOpen, label = props.label, status = props.status, helperText = props.helperText, errorText = props.errorText, placeholder = props.placeholder, children2 = props.children, defaultValue = props.defaultValue, disabled = props.disabled, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskCloseable = props.maskCloseable, maskCloseable = _props$maskCloseable === void 0 ? true : _props$maskCloseable, multiple = props.multiple, onChange = props.onChange, closeOnSelect = props.closeOnSelect, _onVisibilityChange = props.onVisibilityChange, restProps = _objectWithoutPropertiesLoose(props, _excluded30);
  var _useState = (0, import_react83.useState)(restProps.value || defaultValue || []), value = _useState[0], setValue = _useState[1];
  var _useState2 = (0, import_react83.useState)(!!defaultOpen && !disabled), visible = _useState2[0], setVisible = _useState2[1];
  var prefixCls = getPrefixCls("select");
  var cls = clsx_m_default(prefixCls, className);
  var optionsList = convertChildrenToData(children2);
  var options = flattenOptions(optionsList);
  var getSelectedInputDisplay = function getSelectedInputDisplay2(val) {
    if (!Array.isArray(val)) {
      var _options$find;
      return (_options$find = options.find(function(otp) {
        return otp.value === val;
      })) == null || (_options$find = _options$find.label) == null ? void 0 : _options$find.toString();
    }
    return val.map(function(selected) {
      var item = options.find(function(otp) {
        return selected === otp.value;
      });
      return item == null ? void 0 : item.label;
    }).join(", ");
  };
  var inputDisplay = getSelectedInputDisplay(restProps.value || value);
  var updateValue = (0, import_react83.useCallback)(function(val) {
    if (Array.isArray(value) && multiple) {
      var index2 = value.indexOf(val);
      if (index2 !== -1) {
        var newValue = [].concat(value);
        newValue.splice(index2, 1);
        onChange == null || onChange([].concat(newValue));
        setValue([].concat(newValue));
      } else {
        onChange == null || onChange([].concat(value, [val]));
        setValue([].concat(value, [val]));
      }
    } else {
      onChange == null || onChange(val);
      setValue(val);
      if (closeOnSelect) {
        closeSelectSheet();
      }
    }
  }, [closeOnSelect, multiple, onChange, value]);
  var closeSelectSheet = function closeSelectSheet2() {
    setVisible(false);
  };
  var contextValue = (0, import_react83.useMemo)(function() {
    return {
      value: restProps.value || value,
      name: restProps.name,
      disabled,
      updateValue,
      closeSelectSheet
    };
  }, [disabled, restProps.name, restProps.value, updateValue, value]);
  var getPopupElement = (0, import_react83.useCallback)(function() {
    return import_react83.default.createElement(SelectPanel_default, {
      title: label,
      optionsList: options
    }, children2);
  }, [children2, label, options]);
  return import_react83.default.createElement(Context.Provider, {
    value: contextValue
  }, import_react83.default.createElement(SelectTrigger_default, {
    defaultOpen,
    visible,
    popupElement: getPopupElement(),
    mask,
    maskCloseable,
    onVisibilityChange: function onVisibilityChange(v) {
      if (v !== visible) {
        setVisible(v);
        _onVisibilityChange == null || _onVisibilityChange(v);
      }
    }
  }, import_react83.default.createElement(Input_default, {
    ref,
    className: cls,
    label,
    helperText,
    status,
    errorText,
    placeholder,
    readOnly: true,
    disabled,
    value: inputDisplay,
    name: restProps.name,
    id: restProps.id,
    suffix: import_react83.default.createElement(icon_default, {
      className: prefixCls + "-icon",
      icon: "zi-chevron-down"
    })
  })));
});
var Select_default = Select;

// node_modules/zmp-ui/esm/components/select/index.js
var Select2 = Select_default;
Select2.Option = Option_default;
Select2.OtpGroup = OtpGroup_default;
var select_default = Select2;

// node_modules/zmp-ui/esm/components/snackbar-provider/SnackbarProvider.js
var import_react89 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/snackbar-provider/props-type.js
var SnackbarPosition = function(SnackbarPosition2) {
  SnackbarPosition2["top"] = "top";
  SnackbarPosition2["bottom"] = "bottom";
  return SnackbarPosition2;
}({});
var SnackbarType = function(SnackbarType2) {
  SnackbarType2["default"] = "default";
  SnackbarType2["success"] = "success";
  SnackbarType2["info"] = "info";
  SnackbarType2["error"] = "error";
  SnackbarType2["warning"] = "warning";
  SnackbarType2["loading"] = "loading";
  SnackbarType2["download"] = "download";
  SnackbarType2["countdown"] = "countdown";
  SnackbarType2["wifi-connected"] = "wifi-connected";
  SnackbarType2["wifi-disconnected"] = "wifi-disconnected";
  return SnackbarType2;
}({});

// node_modules/zmp-ui/esm/components/snackbar-provider/context.js
var import_react84 = __toESM(require_react());
var SnackbarContext = (0, import_react84.createContext)(null);
var context_default3 = SnackbarContext;

// node_modules/zmp-ui/esm/components/snackbar-provider/BaseSnackbar.js
var import_react88 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/snackbar-provider/common/constants.js
var DEFAULT_DURATION = 2e3;
var DEFAULT_POSITION = SnackbarPosition.bottom;
var DEFAULT_INTERVAL = 250;
var DEFAULT_COUNTDOWN_DURATION = 5e3;
var COUNTDOWN_STROKE_WIDTH = 2;
var COUNTDOWN_RADIUS = 12;

// node_modules/zmp-ui/esm/components/snackbar-provider/icons.js
var import_react86 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/snackbar-provider/LoadingIcon.js
var import_react85 = __toESM(require_react());
var LoadingIcon3 = function LoadingIcon4() {
  return import_react85.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "100%",
    height: "100%",
    viewBox: "0 0 24 24",
    fill: "none"
  }, import_react85.default.createElement("path", {
    d: "M24 12C24 18.6274 18.6274 24 12 24C5.37258 24 0 18.6274 0 12C0 5.37258 5.37258 0 12 0C18.6274 0 24 5.37258 24 12ZM2.49 12C2.49 17.2522 6.74777 21.51 12 21.51C17.2522 21.51 21.51 17.2522 21.51 12C21.51 6.74777 17.2522 2.49 12 2.49C6.74777 2.49 2.49 6.74777 2.49 12Z",
    fill: "#FFFFFF",
    fillOpacity: "1"
  }), import_react85.default.createElement("path", {
    d: "M15.6784 1.89361C15.9136 1.24748 16.6317 0.908557 17.25 1.20938C18.2892 1.71497 19.2519 2.369 20.1071 3.15267C21.2689 4.21731 22.2097 5.50037 22.8757 6.92858C23.5417 8.3568 23.9198 9.90221 23.9886 11.4766C24.0392 12.6355 23.9214 13.7933 23.6407 14.9143C23.4737 15.5814 22.7525 15.9136 22.1064 15.6784C21.4603 15.4433 21.1358 14.7295 21.2846 14.0582C21.4641 13.2486 21.5373 12.4172 21.5009 11.5852C21.4465 10.3375 21.1468 9.11276 20.619 7.9809C20.0912 6.84904 19.3456 5.83222 18.4249 4.98849C17.8108 4.42584 17.1269 3.94752 16.3914 3.5646C15.7815 3.24709 15.4433 2.53973 15.6784 1.89361Z",
    fill: "#52A0FF"
  }));
};
var LoadingIcon_default = LoadingIcon3;

// node_modules/zmp-ui/esm/components/snackbar-provider/icons.js
var Wifi = function Wifi2() {
  return import_react86.default.createElement(icon_default, {
    icon: "zi-wifi"
  });
};
var WifiOff = function WifiOff2() {
  return import_react86.default.createElement(icon_default, {
    icon: "zi-wifi-off"
  });
};
var Download = function Download2() {
  return import_react86.default.createElement(icon_default, {
    icon: "zi-download-solid"
  });
};
var Error2 = function Error3() {
  return import_react86.default.createElement(icon_default, {
    icon: "zi-close-circle-solid"
  });
};
var Warning = function Warning2() {
  return import_react86.default.createElement(icon_default, {
    icon: "zi-warning-solid"
  });
};
var Info = function Info2() {
  return import_react86.default.createElement(icon_default, {
    icon: "zi-info-circle-solid"
  });
};
var Success = function Success2() {
  return import_react86.default.createElement(icon_default, {
    icon: "zi-check-circle-solid"
  });
};
var getIcon = function getIcon2(type) {
  switch (type) {
    case SnackbarType.download:
      return import_react86.default.createElement(Download, null);
    case SnackbarType.error:
      return import_react86.default.createElement(Error2, null);
    case SnackbarType.warning:
      return import_react86.default.createElement(Warning, null);
    case SnackbarType.success:
      return import_react86.default.createElement(Success, null);
    case SnackbarType["wifi-connected"]:
      return import_react86.default.createElement(Wifi, null);
    case SnackbarType["wifi-disconnected"]:
      return import_react86.default.createElement(WifiOff, null);
    case SnackbarType.loading:
      return import_react86.default.createElement(LoadingIcon_default, null);
    default:
      return import_react86.default.createElement(Info, null);
  }
};
var icons_default2 = getIcon;

// node_modules/zmp-ui/esm/components/snackbar-provider/CountDown.js
var import_react87 = __toESM(require_react());
var CountDown = function CountDown2(_ref) {
  var _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? DEFAULT_COUNTDOWN_DURATION : _ref$duration;
  var prefixCls = getPrefixCls("snackbar-countdown");
  var maxCount = duration / 1e3;
  var _useState = (0, import_react87.useState)(maxCount), current = _useState[0], setCurrent = _useState[1];
  var strokeWidth = COUNTDOWN_STROKE_WIDTH;
  var radius = COUNTDOWN_RADIUS - strokeWidth / 2;
  var width = COUNTDOWN_RADIUS * 2;
  var height = COUNTDOWN_RADIUS * 2;
  var viewBox = "0 0 " + width + " " + height;
  var dashArray = radius * Math.PI * 2;
  var percentage = current / maxCount * 100;
  var dashOffset = dashArray - dashArray * percentage / 100;
  (0, import_react87.useEffect)(function() {
    var timmer = setInterval(function() {
      if (current > 0) {
        setCurrent(function(cur) {
          return cur - 1;
        });
      } else {
        clearInterval(timmer);
      }
    }, 1e3);
    return function() {
      return clearInterval(timmer);
    };
  }, [current]);
  return import_react87.default.createElement("div", {
    className: prefixCls
  }, import_react87.default.createElement("svg", {
    className: prefixCls + "-circle",
    width: COUNTDOWN_RADIUS * 2,
    height: COUNTDOWN_RADIUS * 2,
    viewBox
  }, import_react87.default.createElement("circle", {
    className: prefixCls + "-background",
    cx: COUNTDOWN_RADIUS,
    cy: COUNTDOWN_RADIUS,
    r: radius,
    strokeWidth: strokeWidth + "px"
  }), import_react87.default.createElement("circle", {
    className: prefixCls + "-progress",
    cx: COUNTDOWN_RADIUS,
    cy: COUNTDOWN_RADIUS,
    r: radius,
    strokeWidth: strokeWidth + "px",
    style: {
      strokeDasharray: dashArray,
      strokeDashoffset: dashOffset
    },
    transform: "rotate(-90)"
  }), import_react87.default.createElement("text", {
    className: prefixCls + "-counter",
    x: COUNTDOWN_RADIUS,
    y: radius,
    dy: ".4em",
    textAnchor: "middle"
  }, current)));
};
var CountDown_default = CountDown;

// node_modules/zmp-ui/esm/components/snackbar-provider/BaseSnackbar.js
function ownKeys21(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread20(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys21(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys21(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var BaseSnackbar = import_react88.default.forwardRef(function(props, ref) {
  var _classNames, _classNames2;
  var text = props.text, prefixIcon = props.prefixIcon, action = props.action, icon2 = props.icon, verticalAction = props.verticalAction, style = props.style, className = props.className, type = props.type, position = props.position, _props$downloadProgre = props.downloadProgress, downloadProgress = _props$downloadProgre === void 0 ? 0 : _props$downloadProgre, duration = props.duration, zIndex = props.zIndex;
  var snackbarContext = (0, import_react88.useContext)(context_default3);
  var validPosition = Object.values(SnackbarPosition).includes(position) ? position : DEFAULT_POSITION;
  var prefixCls = getPrefixCls("snackbar");
  var defaultIcon;
  if (type !== SnackbarType["default"] && type !== SnackbarType.countdown) {
    defaultIcon = icons_default2(type);
  }
  if (type === SnackbarType.countdown) {
    defaultIcon = import_react88.default.createElement(CountDown_default, {
      duration: duration || DEFAULT_COUNTDOWN_DURATION
    });
  }
  var textOnly = !icon2 && !defaultIcon && !prefixIcon && !action;
  var cls = clsx_m_default(prefixCls, className, (_classNames = {}, _classNames[prefixCls + "-vertical-action"] = verticalAction, _classNames[prefixCls + "-" + validPosition] = validPosition, _classNames[prefixCls + "-text-only"] = textOnly, _classNames));
  var iconEl = prefixIcon || defaultIcon || (icon2 ? import_react88.default.createElement(icon_default, {
    icon: "zi-info-circle-solid"
  }) : null);
  var progressBar = type === SnackbarType.download ? import_react88.default.createElement(progress_default, {
    className: prefixCls + "-progress",
    maxCompleted: 100,
    completed: downloadProgress
  }) : null;
  var onClickAction = function onClickAction2(event) {
    event.preventDefault();
    if (action && action.close && snackbarContext) {
      snackbarContext.closeSnackbar == null || snackbarContext.closeSnackbar();
    }
    action == null || action.onClick == null || action.onClick(event);
  };
  var iconClass = clsx_m_default(prefixCls + "-prefix-icon", (_classNames2 = {}, _classNames2[prefixCls + "-success"] = type === SnackbarType.success, _classNames2[prefixCls + "-error"] = type === SnackbarType.error, _classNames2[prefixCls + "-warning"] = type === SnackbarType.warning, _classNames2[prefixCls + "-info"] = type === SnackbarType.info, _classNames2[prefixCls + "-download"] = type === SnackbarType.download, _classNames2[prefixCls + "-success"] = type === SnackbarType.success, _classNames2[prefixCls + "-wifi-connected"] = type === SnackbarType["wifi-connected"], _classNames2[prefixCls + "-wifi-disconnected"] = type === SnackbarType["wifi-disconnected"], _classNames2[prefixCls + "-loading"] = type === SnackbarType.loading, _classNames2));
  var elStyle = {};
  if (style) {
    elStyle = _objectSpread20({}, style);
  }
  if (zIndex) {
    elStyle.zIndex = zIndex;
  }
  return import_react88.default.createElement("div", {
    className: cls,
    ref,
    style: elStyle
  }, import_react88.default.createElement("div", {
    className: prefixCls + "-content"
  }, import_react88.default.createElement("div", {
    className: prefixCls + "-desc-wrapper"
  }, iconEl && import_react88.default.createElement("div", {
    className: iconClass
  }, iconEl), text && import_react88.default.createElement("div", {
    className: prefixCls + "-desc"
  }, text)), progressBar), action && import_react88.default.createElement("div", {
    role: "presentation",
    className: prefixCls + "-action",
    onClick: onClickAction
  }, action.text));
});
var BaseSnackbar_default = BaseSnackbar;

// node_modules/zmp-ui/esm/components/snackbar-provider/SnackbarProvider.js
var SnackbarProvider = import_react89.default.forwardRef(function(props, ref) {
  var _classNames, _classNames2, _classNames3, _classNames4;
  var _useState = (0, import_react89.useState)(false), open = _useState[0], setOpen = _useState[1];
  var _useState2 = (0, import_react89.useState)(false), appearDone = _useState2[0], setAppearDone = _useState2[1];
  var _useState3 = (0, import_react89.useState)(null), timeoutId = _useState3[0], setTimeoutId = _useState3[1];
  var _useState4 = (0, import_react89.useState)(""), text = _useState4[0], setText = _useState4[1];
  var _useState5 = (0, import_react89.useState)(false), icon2 = _useState5[0], setIcon = _useState5[1];
  var _useState6 = (0, import_react89.useState)(null), prefixIcon = _useState6[0], setPrefixIcon = _useState6[1];
  var _useState7 = (0, import_react89.useState)(SnackbarType["default"]), type = _useState7[0], setType = _useState7[1];
  var _useState8 = (0, import_react89.useState)(SnackbarPosition.bottom), position = _useState8[0], setPosition = _useState8[1];
  var _useState9 = (0, import_react89.useState)(type === SnackbarType.countdown ? DEFAULT_COUNTDOWN_DURATION : DEFAULT_DURATION), duration = _useState9[0], setDuration = _useState9[1];
  var snackbarRef = (0, import_react89.useRef)();
  var _useState10 = (0, import_react89.useState)(), onClose = _useState10[0], setOnclose = _useState10[1];
  var _useState11 = (0, import_react89.useState)(), action = _useState11[0], setAction = _useState11[1];
  var _useState12 = (0, import_react89.useState)(false), verticalAction = _useState12[0], setVerticalAction = _useState12[1];
  var _useState13 = (0, import_react89.useState)(0), downloadCompleted = _useState13[0], setDownloadCompleted = _useState13[1];
  (0, import_react89.useImperativeHandle)(ref, function() {
    return snackbarRef.current;
  });
  var triggerSnackbar = (0, import_react89.useCallback)(function(option) {
    var snackbarTYpe = option.type;
    var snackbarPos = option.position;
    setText((option == null ? void 0 : option.text) || "");
    setIcon(!!(option != null && option.icon));
    setPrefixIcon(option == null ? void 0 : option.prefixIcon);
    setType(snackbarTYpe || SnackbarType["default"]);
    setDuration((option == null ? void 0 : option.duration) || DEFAULT_DURATION);
    setPosition(snackbarPos || DEFAULT_POSITION);
    setAction(option == null ? void 0 : option.action);
    setVerticalAction(!!(option != null && option.verticalAction));
    setOnclose(function() {
      return option == null ? void 0 : option.onClose;
    });
    setDownloadCompleted(0);
  }, []);
  var openSnackbar = (0, import_react89.useCallback)(function(option) {
    if (open === true) {
      setOpen(false);
      setTimeout(function() {
        triggerSnackbar(option);
        setOpen(true);
      }, DEFAULT_INTERVAL);
    } else {
      triggerSnackbar(option);
      setOpen(true);
    }
  }, [open, triggerSnackbar]);
  var closeSnackbar = (0, import_react89.useCallback)(function() {
    setOpen(false);
  }, []);
  var setDownloadProgress = (0, import_react89.useCallback)(function(completed) {
    setDownloadCompleted(completed);
  }, []);
  var validPosition = Object.values(SnackbarPosition).includes(position) ? position : DEFAULT_POSITION;
  var prefixCls = getPrefixCls("snackbar");
  var contextValue = (0, import_react89.useMemo)(function() {
    return {
      openSnackbar,
      closeSnackbar,
      setDownloadProgress
    };
  }, [openSnackbar, closeSnackbar, setDownloadProgress]);
  var children2 = props.children, className = props.className, style = props.style, zIndex = props.zIndex;
  return import_react89.default.createElement(context_default3.Provider, {
    value: contextValue
  }, children2, import_react89.default.createElement(CSSTransition_default, {
    "in": open,
    timeout: {
      enter: 100,
      exit: 100,
      appear: 100
    },
    mountOnEnter: true,
    unmountOnExit: true,
    onEntered: function onEntered() {
      return setAppearDone(true);
    },
    onExited: function onExited() {
      return setAppearDone(false);
    },
    onEnter: function onEnter() {
      clearTimeout(timeoutId);
      var timeout2 = type === SnackbarType.countdown ? duration + 1e3 : duration;
      setTimeoutId(setTimeout(function() {
        setOpen(false);
      }, timeout2));
    },
    onExit: function onExit() {
      onClose == null || onClose();
    },
    classNames: {
      enter: clsx_m_default(prefixCls + "-enter", (_classNames = {}, _classNames[prefixCls + "-enter-" + validPosition] = validPosition, _classNames)),
      enterActive: clsx_m_default(prefixCls + "-enter-active", (_classNames2 = {}, _classNames2[prefixCls + "-enter-active-" + validPosition] = validPosition, _classNames2)),
      exitActive: clsx_m_default(prefixCls + "-exit-active", (_classNames3 = {}, _classNames3[prefixCls + "-exit-active-" + validPosition] = validPosition, _classNames3))
    },
    nodeRef: snackbarRef
  }, import_react89.default.createElement(BaseSnackbar_default, {
    ref: snackbarRef,
    position,
    text,
    action,
    icon: icon2,
    type,
    prefixIcon,
    duration,
    style,
    className: clsx_m_default(prefixCls, className, (_classNames4 = {}, _classNames4[prefixCls + "-" + validPosition + "-visible"] = appearDone, _classNames4)),
    verticalAction,
    downloadProgress: downloadCompleted,
    zIndex
  })));
});
var SnackbarProvider_default = SnackbarProvider;

// node_modules/zmp-ui/esm/components/snackbar-provider/hooks/useSnackbar.js
var import_react90 = __toESM(require_react());
var useSnackbar = function useSnackbar2() {
  var snackbarContext = (0, import_react90.useContext)(context_default3);
  var _ref = snackbarContext || {}, openSnackbar = _ref.openSnackbar, closeSnackbar = _ref.closeSnackbar, setDownloadProgress = _ref.setDownloadProgress;
  var open = function open2(option) {
    openSnackbar == null || openSnackbar(option);
  };
  var close = function close2() {
    closeSnackbar == null || closeSnackbar();
  };
  var setDownload = function setDownload2(completed) {
    setDownloadProgress == null || setDownloadProgress(completed);
  };
  return {
    openSnackbar: open,
    closeSnackbar: close,
    setDownloadProgress: setDownload
  };
};

// node_modules/zmp-ui/esm/components/snackbar-provider/index.js
var snackbar_provider_default = SnackbarProvider_default;

// node_modules/zmp-ui/esm/components/picker/Picker.js
var import_react94 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/picker/PickerTrigger.js
var import_react91 = __toESM(require_react());
var PickerTrigger3 = function PickerTrigger4(props) {
  var children2 = props.children, popupElement = props.popupElement, onVisibilityChange = props.onVisibilityChange, defaultOpen = props.defaultOpen, visible = props.visible, mask = props.mask, maskClosable = props.maskClosable;
  return import_react91.default.createElement(trigger_default, {
    action: "click",
    popup: popupElement,
    defaultPopupVisible: defaultOpen,
    popupVisible: visible,
    mask,
    maskClosable,
    onPopupVisibleChange: onVisibilityChange
  }, children2);
};
var PickerTrigger_default = PickerTrigger3;

// node_modules/zmp-ui/esm/components/picker/PickerPanel.js
var import_react93 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/picker/PickerColumn.js
var import_react92 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/picker/common/constant.js
var DEFAULT_PICKER_ITEM_HEIGHT = 52;

// node_modules/zmp-ui/esm/components/picker/PickerColumn.js
function ownKeys22(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread21(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys22(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys22(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var columnHeight = DEFAULT_PICKER_ITEM_HEIGHT * 5;
var itemHeight = DEFAULT_PICKER_ITEM_HEIGHT;
var PickerColumn = function PickerColumn2(props) {
  var options = props.options, className = props.className, prefixCls = props.prefixCls, value = props.value, defaultValue = props.defaultValue, name = props.name, onChange = props.onChange, _props$datePickerColu = props.datePickerColumn, datePickerColumn = _props$datePickerColu === void 0 ? false : _props$datePickerColu;
  var prevSelected = (0, import_react92.useRef)();
  var animationRef = (0, import_react92.useRef)();
  var scrollerTranslateRef = (0, import_react92.useRef)(0);
  var _useState = (0, import_react92.useState)(function() {
    var initVal = value || defaultValue;
    var selectedIndex = initVal ? options.map(function(opt) {
      return opt.value;
    }).indexOf(initVal.value) : 0;
    var translate = columnHeight / 2 - itemHeight / 2 - selectedIndex * itemHeight;
    scrollerTranslateRef.current = translate;
    prevSelected.current = options[selectedIndex].value;
    return {
      isMoving: false,
      startTouchY: 0,
      startScrollerTranslate: translate,
      scrollerTranslate: translate,
      minTranslate: columnHeight / 2 - itemHeight * options.length + itemHeight / 2,
      maxTranslate: columnHeight / 2 - itemHeight / 2
    };
  }), state = _useState[0], setState = _useState[1];
  var updateScrollerTranslate = function updateScrollerTranslate2(data) {
    scrollerTranslateRef.current = data;
    setState(function(prev) {
      return _objectSpread21(_objectSpread21({}, prev), {}, {
        scrollerTranslate: data
      });
    });
  };
  var onValueSelected = function onValueSelected2(opt, colName) {
    onChange == null || onChange(opt, colName);
  };
  var computeTranslate = function computeTranslate2() {
    var initVal = value || defaultValue;
    var selectedIndex = initVal ? options.map(function(opt) {
      return opt.value;
    }).indexOf(initVal.value) : 0;
    if (datePickerColumn && (value == null ? void 0 : value.value) === prevSelected.current && selectedIndex <= 0 && prevSelected.current) {
      var latestValue = parseInt(prevSelected.current.toString(), 10);
      var lastValue = parseInt(options[options.length - 1].value.toString(), 10);
      if (latestValue > lastValue) {
        selectedIndex = options.length - 1;
      }
    }
    selectedIndex = Math.max(selectedIndex, 0);
    onValueSelected(options[selectedIndex], name);
    prevSelected.current = options[selectedIndex].value;
    var translate = columnHeight / 2 - itemHeight / 2 - selectedIndex * itemHeight;
    scrollerTranslateRef.current = translate;
    return {
      scrollerTranslate: translate,
      minTranslate: columnHeight / 2 - itemHeight * options.length + itemHeight / 2,
      maxTranslate: columnHeight / 2 - itemHeight / 2
    };
  };
  (0, import_react92.useEffect)(function() {
    if (state.isMoving) return;
    var newState = computeTranslate();
    setState(function(prev) {
      return _objectSpread21(_objectSpread21({}, prev), newState);
    });
  }, [value, options]);
  var handleTouchStart = function handleTouchStart2(event) {
    var startY = event.targetTouches[0].pageY;
    setState(function(prev) {
      return _objectSpread21(_objectSpread21({}, prev), {}, {
        isMoving: true,
        startTouchY: startY,
        startScrollerTranslate: scrollerTranslateRef.current
      });
    });
  };
  var handleTouchMove = function handleTouchMove2(event) {
    var touchY = event.targetTouches[0].pageY;
    var delta = touchY - state.startTouchY;
    var nextTranslate = state.startScrollerTranslate + delta;
    if (nextTranslate < state.minTranslate) {
      nextTranslate = state.minTranslate - Math.pow(state.minTranslate - nextTranslate, 0.8);
    } else if (nextTranslate > state.maxTranslate) {
      nextTranslate = state.maxTranslate + Math.pow(nextTranslate - state.maxTranslate, 0.8);
    }
    cancelAnimationFrame(animationRef.current);
    animationRef.current = requestAnimationFrame(function() {
      updateScrollerTranslate(nextTranslate);
    });
  };
  var handleTouchEnd = function handleTouchEnd2() {
    setState(function(prev) {
      return _objectSpread21(_objectSpread21({}, prev), {}, {
        isMoving: false
      });
    });
    var minTranslate = state.minTranslate, maxTranslate = state.maxTranslate;
    var current = scrollerTranslateRef.current;
    var activeIndex = 0;
    if (current > maxTranslate) {
      activeIndex = 0;
    } else if (current < minTranslate) {
      activeIndex = options.length - 1;
    } else {
      activeIndex = Math.round((maxTranslate - current) / itemHeight);
    }
    onValueSelected(options[activeIndex], name);
    prevSelected.current = options[activeIndex].value;
    var newTranslate = columnHeight / 2 - itemHeight / 2 - activeIndex * itemHeight;
    updateScrollerTranslate(newTranslate);
  };
  var handleTouchCancel = function handleTouchCancel2() {
    updateScrollerTranslate(state.startScrollerTranslate);
    setState(function(prev) {
      return _objectSpread21(_objectSpread21({}, prev), {}, {
        isMoving: false
      });
    });
  };
  var renderItems = function renderItems2() {
    var selectedIndex = options.findIndex(function(opt) {
      return opt.value === (value == null ? void 0 : value.value);
    });
    return options.map(function(option, index2) {
      var _classNames;
      var style2 = {
        height: itemHeight + "px",
        lineHeight: itemHeight + "px"
      };
      var itemPrefixCls = prefixCls + "-item";
      var itemCls = clsx_m_default(itemPrefixCls, (_classNames = {}, _classNames[itemPrefixCls + "-selected"] = !state.isMoving && index2 === selectedIndex, _classNames[itemPrefixCls + "-2nd"] = !state.isMoving && selectedIndex > -1 && (index2 === selectedIndex - 1 || index2 === selectedIndex + 1), _classNames));
      return import_react92.default.createElement("div", {
        key: name + "-" + (option.key || option.value),
        className: itemCls,
        style: style2,
        onClick: function onClick() {
          return onValueSelected(option, name);
        },
        role: "presentation"
      }, option.displayName);
    });
  };
  var translateString = "translate3d(0, " + state.scrollerTranslate + "px, 0)";
  var style = {
    willChange: "transform",
    MsTransform: translateString,
    MozTransform: translateString,
    OTransform: translateString,
    WebkitTransform: translateString,
    transform: translateString,
    transitionDuration: state.isMoving ? "0ms" : "150ms"
  };
  var cls = clsx_m_default(prefixCls + "-column", className);
  var scrollerPrefixCls = prefixCls + "-scroller";
  return import_react92.default.createElement("div", {
    className: cls
  }, import_react92.default.createElement("div", {
    className: scrollerPrefixCls,
    onTouchStart: handleTouchStart,
    onTouchMove: handleTouchMove,
    onTouchEnd: handleTouchEnd,
    onTouchCancel: handleTouchCancel,
    style: _objectSpread21({
      height: columnHeight + "px"
    }, style)
  }, renderItems()));
};
PickerColumn.defaultProps = {
  datePickerColumn: false
};
var PickerColumn_default = import_react92.default.memo(PickerColumn);

// node_modules/zmp-ui/esm/components/picker/PickerPanel.js
var PickerPanel = function PickerPanel2(props) {
  var className = props.className, prefixCls = props.prefixCls, data = props.data, value = props.value, defaultValue = props.defaultValue, onChange = props.onChange, action = props.action, datePicker = props.datePicker, closePanel = props.closePanel, title = props.title, initData = props.initData;
  var panelPrefixCls = prefixCls + "-panel";
  var cls = clsx_m_default(panelPrefixCls, {}, className);
  var closeModal = function closeModal2(event) {
    closePanel == null || closePanel(event);
  };
  var handleClickAction = function handleClickAction2(event) {
    if (action && action.close) {
      closeModal(event);
    }
    action == null || action.onClick == null || action.onClick(event);
  };
  var renderInner = function renderInner2() {
    var innerPrefixCls = prefixCls + "-inner";
    var columnNodes = data.map(function(column, index2) {
      var otpVal = value ? value[column.name] : void 0;
      var otpDefaultValue = defaultValue ? defaultValue[column.name] : void 0;
      if (initData && initData[column.name] && !otpVal && !otpDefaultValue) {
        otpDefaultValue = column.options.find(function(opt) {
          return opt.value === initData[column.name];
        });
      }
      return import_react93.default.createElement(PickerColumn_default, {
        key: "zaui-picker-column-" + (column.name || index2),
        name: column.name,
        prefixCls,
        datePickerColumn: datePicker,
        options: column.options,
        value: otpVal,
        defaultValue: otpDefaultValue,
        onChange
      });
    });
    return import_react93.default.createElement("div", {
      className: innerPrefixCls
    }, columnNodes);
  };
  return import_react93.default.createElement("div", {
    className: cls
  }, import_react93.default.createElement("div", {
    className: prefixCls + "-header"
  }, import_react93.default.createElement("div", {
    className: prefixCls + "-title"
  }, title), import_react93.default.createElement(button_default, {
    type: "neutral",
    variant: "tertiary",
    className: prefixCls + "-close-icon",
    icon: import_react93.default.createElement(icon_default, {
      icon: "zi-close"
    }),
    onClick: closeModal
  })), renderInner(), action && import_react93.default.createElement("div", {
    className: prefixCls + "-action"
  }, import_react93.default.createElement(button_default, {
    fullWidth: true,
    onClick: handleClickAction
  }, action.text)));
};
PickerPanel.defaultProps = {
  initData: void 0,
  datePicker: false
};
var PickerPanel_default = import_react93.default.memo(PickerPanel);

// node_modules/zmp-ui/esm/components/picker/Picker.js
function ownKeys23(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread23(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys23(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys23(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Picker = function Picker2(props) {
  var label = props.label, helperText = props.helperText, status = props.status, errorText = props.errorText, data = props.data, value = props.value, defaultValue = props.defaultValue, onChange = props.onChange, action = props.action, placeholder = props.placeholder, title = props.title, defaultOpen = props.defaultOpen, disabled = props.disabled, formatPickedValueDisplay = props.formatPickedValueDisplay, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, inputClass = props.inputClass, datePicker = props.datePicker, initData = props.initData, suffix = props.suffix, prefix2 = props.prefix, _onVisibilityChange = props.onVisibilityChange, updateDatePickerData = props.updateDatePickerData, id = props.id, inputName = props.name;
  var getInitValue = function getInitValue2(val, defaultVal, options) {
    var getOption = function getOption2(opts) {
      var result = {};
      Object.keys(opts).forEach(function(optName) {
        var group = options.find(function(dataGroup) {
          return dataGroup.name === optName;
        });
        if (group) {
          var opt = group.options.find(function(o) {
            return o.value === opts[optName];
          });
          if (opt) {
            result[optName] = opt;
          } else if (datePicker) {
            updateDatePickerData == null || updateDatePickerData();
          }
        }
      });
      return result;
    };
    if (val) return getOption(val);
    if (defaultVal) return getOption(defaultVal);
    return {};
  };
  var _useState = (0, import_react94.useState)(!!defaultOpen && !disabled), visible = _useState[0], setVisible = _useState[1];
  var _useState2 = (0, import_react94.useState)(getInitValue(value, defaultValue, data || [])), pickerValue = _useState2[0], setPickerValue = _useState2[1];
  (0, import_react94.useEffect)(function() {
    if (value) {
      setPickerValue(getInitValue(value, void 0, data || []));
    } else {
      setPickerValue({});
    }
  }, [value]);
  var closePicker = function closePicker2() {
    setVisible(false);
  };
  var handleChangePickerValue = function handleChangePickerValue2(otp, name) {
    var _pickerValue$name;
    var newState = _objectSpread23({}, pickerValue);
    if (((_pickerValue$name = pickerValue[name]) == null ? void 0 : _pickerValue$name.value) !== otp.value) {
      newState[name] = otp;
    }
    setPickerValue(newState);
    if (!value) {
      onChange == null || onChange(newState);
    } else {
      var different = false;
      Object.entries(value).forEach(function(_ref) {
        var _newState$k;
        var k = _ref[0], v = _ref[1];
        if (((_newState$k = newState[k]) == null ? void 0 : _newState$k.value) !== v) {
          different = true;
        }
      });
      if (different) {
        onChange == null || onChange(newState);
      }
    }
  };
  var prefixCls = getPrefixCls("picker");
  var inputCls = clsx_m_default(prefixCls + "-input", inputClass);
  var getPopupElement = function getPopupElement2() {
    return import_react94.default.createElement(PickerPanel_default, {
      prefixCls,
      className: prefixCls,
      data,
      value: pickerValue,
      onChange: handleChangePickerValue,
      title,
      closePanel: closePicker,
      action,
      datePicker,
      initData
    });
  };
  var getInputDisplay = function getInputDisplay2(picked) {
    if (formatPickedValueDisplay) {
      return formatPickedValueDisplay(picked);
    }
    return Object.keys(picked).map(function(k) {
      return pickerValue[k].displayName;
    }).filter(function(item) {
      return item !== null;
    }).join(", ");
  };
  var inputDisplay = getInputDisplay(pickerValue);
  return import_react94.default.createElement(PickerTrigger_default, {
    popupElement: getPopupElement(),
    visible,
    defaultOpen,
    onVisibilityChange: function onVisibilityChange(v) {
      if (!disabled) {
        setVisible(v);
        _onVisibilityChange == null || _onVisibilityChange(v);
      }
    },
    mask,
    maskClosable
  }, import_react94.default.createElement(input_default, {
    label,
    className: inputCls,
    helperText,
    status,
    errorText,
    placeholder,
    value: inputDisplay,
    readOnly: true,
    disabled,
    prefix: prefix2,
    suffix,
    id,
    name: inputName
  }));
};
Picker.defaultProps = {
  datePicker: false,
  initData: void 0
};
var Picker_default = Picker;

// node_modules/zmp-ui/esm/components/picker/index.js
var picker_default = Picker_default;

// node_modules/zmp-ui/esm/components/date-picker/index.js
var import_react95 = __toESM(require_react());

// node_modules/zmp-ui/esm/utils/date.js
var getWeeksInMonth = function getWeeksInMonth2(year, monthNumber, startDayOfWeek) {
  if (startDayOfWeek === void 0) {
    startDayOfWeek = 0;
  }
  var firstDayOfWeek = startDayOfWeek || 0;
  var firstOfMonth = new Date(year, monthNumber - 1, 1);
  var lastOfMonth = new Date(year, monthNumber, 0);
  var numberOfDaysInMonth = lastOfMonth.getDate();
  var firstWeekDay = (firstOfMonth.getDay() - firstDayOfWeek + 7) % 7;
  var used = firstWeekDay + numberOfDaysInMonth;
  return Math.ceil(used / 7);
};
var dayFormatter = function dayFormatter2(locale) {
  return new Intl.DateTimeFormat(locale, {
    day: "2-digit"
  });
};
var monthFormatter = function monthFormatter2(locale) {
  return new Intl.DateTimeFormat(locale, {
    month: "long"
  });
};
var shortMonthFormatter = function shortMonthFormatter2(locale) {
  return new Intl.DateTimeFormat(locale, {
    month: "short"
  });
};
var yearFormatter = function yearFormatter2(locale) {
  return new Intl.DateTimeFormat(locale, {
    year: "numeric"
  });
};
var getDayOfWeekArray = function getDayOfWeekArray2(startOfWeek) {
  var dayOfWeekArray = [];
  for (var i = 0; i < 7; i++) {
    dayOfWeekArray.push((startOfWeek + i) % 7);
  }
  return dayOfWeekArray;
};

// node_modules/zmp-ui/esm/components/date-picker/common/constants.js
var YEAR_COL_NAME = "year";
var MONTH_COL_NAME = "month";
var DATE_COL_NAME = "date";
var DEFAULT_DATE_PICKER_COLUMN_FORMAT = "DD-MM-YYYY";
var COLUMN_FORMATS = ["MM-DD-YYYY", "DD-MM-YYYY", "YYYY-MM-DD"];

// node_modules/zmp-ui/esm/components/date-picker/utils/index.js
var getMonthlyDay = function getMonthlyDay2(year, month) {
  var day = 31;
  if (month === 1 || month === 3 || month === 5 || month === 7 || month === 8 || month === 10 || month === 12) {
    day = 31;
  } else if (month === 4 || month === 6 || month === 11 || month === 9) {
    day = 30;
  } else if (month === 2) {
    if (year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)) {
      day = 29;
    } else {
      day = 28;
    }
  }
  return day;
};
var getDateRange = function getDateRange2(startDate, endDate) {
  var result = {
    startDate: startDate.getDate(),
    startMonth: startDate.getMonth() + 1,
    startYear: startDate.getFullYear(),
    endDate: endDate.getDate(),
    endMonth: endDate.getMonth() + 1,
    endYear: endDate.getFullYear()
  };
  return result;
};
var getPosition2 = function getPosition3(_ref) {
  var currentMonth = _ref.currentMonth, currentYear = _ref.currentYear, startDate = _ref.startDate, endDate = _ref.endDate;
  var _getDateRange = getDateRange(startDate, endDate), startMonth = _getDateRange.startMonth, startYear = _getDateRange.startYear, endMonth = _getDateRange.endMonth, endYear = _getDateRange.endYear;
  return {
    isStartMonth: startMonth && currentYear === startYear && currentMonth <= startMonth,
    isEndMonth: endMonth && currentYear === endYear && currentMonth >= endMonth,
    isStartYear: startYear && currentYear <= startYear,
    isEndYear: endYear && currentYear >= endYear
  };
};
var convertDateToPickerValue = function convertDateToPickerValue2(date) {
  var _ref2;
  var year = date.getFullYear();
  var month = date.getMonth() + 1;
  var day = date.getDate();
  return _ref2 = {}, _ref2[YEAR_COL_NAME] = year.toString(), _ref2[MONTH_COL_NAME] = month.toString(), _ref2[DATE_COL_NAME] = day.toString(), _ref2;
};
var twoDigits = function twoDigits2(number) {
  return number < 10 ? "0" + number : number;
};
var formatDate = function formatDate2(d, config2) {
  if (config2 === void 0) {
    config2 = {};
  }
  var date = new Date(d);
  var year = date.getFullYear();
  var month = date.getMonth();
  var month1 = month + 1;
  var day = date.getDate();
  var _config = config2, dateFormat = _config.dateFormat, locale = _config.locale;
  if (typeof dateFormat === "string") {
    var tokens = {
      yyyy: year,
      yy: String(year).substring(2),
      mm: twoDigits(month1),
      m: month1,
      MM: monthFormatter(locale).format(date),
      M: shortMonthFormatter(locale).format(date),
      dd: twoDigits(day),
      d: day
    };
    var regexp = new RegExp(Object.keys(tokens).map(function(t) {
      return "(" + t + ")";
    }).join("|"), "g");
    return dateFormat.replace(regexp, function(token) {
      if (token in tokens) return "" + tokens[token];
      return token;
    });
  }
  if (typeof dateFormat === "function") {
    return dateFormat(date);
  }
  var formatter = new Intl.DateTimeFormat(locale, dateFormat);
  return formatter.format(date);
};
var createPickerColumns = function createPickerColumns2(date, config2) {
  if (config2 === void 0) {
    config2 = {};
  }
  var defaultPickerFormat = DEFAULT_DATE_PICKER_COLUMN_FORMAT;
  var customPickerFormat;
  var currentMonth = date.getMonth() + 1;
  var currentYear = date.getFullYear();
  var _config2 = config2, locale = _config2.locale;
  if (config2.datePickerColumns && typeof config2.datePickerColumns === "string" && COLUMN_FORMATS.map(function(k2) {
    return k2;
  }).includes(config2.datePickerColumns.toUpperCase())) {
    customPickerFormat = config2.datePickerColumns.toUpperCase();
  }
  var dateFormatArr = customPickerFormat ? customPickerFormat.split(/-|\/|\s|:/g) : defaultPickerFormat.split(/-|\/|\s|:/g);
  var _getDateRange2 = getDateRange(config2.startDate, config2.endDate), startDate = _getDateRange2.startDate, startMonth = _getDateRange2.startMonth, startYear = _getDateRange2.startYear, endDate = _getDateRange2.endDate, endMonth = _getDateRange2.endMonth, endYear = _getDateRange2.endYear;
  var _getPosition = getPosition2({
    currentMonth,
    currentYear,
    startDate: config2.startDate,
    endDate: config2.endDate
  }), isEndYear = _getPosition.isEndYear, isStartYear = _getPosition.isStartYear, isEndMonth = _getPosition.isEndMonth, isStartMonth = _getPosition.isStartMonth;
  var len = dateFormatArr.length;
  var columns = [];
  for (var i = 0; i < len; i += 1) {
    var f = dateFormatArr[i];
    if (f === "YYYY") {
      var years = {
        options: [],
        name: YEAR_COL_NAME
      };
      var start2 = startYear;
      var end = endYear;
      for (var j = start2; j <= end; j += 1) {
        years.options.push({
          value: j.toString(),
          displayName: yearFormatter(locale).format((/* @__PURE__ */ new Date()).setFullYear(j))
        });
      }
      columns.push(years);
    } else if (f === "MM") {
      var months = {
        options: [],
        name: MONTH_COL_NAME
      };
      var _start = isStartYear ? startMonth : 1;
      var _end = isEndYear ? endMonth : 12;
      if (isStartYear) {
        _start = Number.parseInt(startMonth.toString(), 10);
      }
      if (isEndYear) {
        _end = Number.parseInt(endMonth.toString(), 10);
      }
      for (var k = _start; k <= _end; k += 1) {
        months.options.push({
          value: k.toString(),
          displayName: monthFormatter(locale).format((/* @__PURE__ */ new Date("0001-01-01")).setMonth(k - 1))
        });
      }
      columns.push(months);
    } else if (f === "DD") {
      var days = {
        options: [],
        name: DATE_COL_NAME
      };
      var _end2 = getMonthlyDay(currentYear, currentMonth);
      var _start2 = 1;
      if (isStartMonth && startDate) {
        _start2 = startDate;
      }
      if (isEndMonth) {
        _end2 = endDate;
      }
      for (var l = _start2; l <= _end2; l += 1) {
        days.options.push({
          value: l.toString(),
          displayName: dayFormatter(locale).format((/* @__PURE__ */ new Date("0001-01-01")).setDate(l))
        });
      }
      columns.push(days);
    }
  }
  return columns;
};

// node_modules/zmp-ui/esm/components/date-picker/index.js
var _excluded31 = ["inputClass", "suffix", "label", "placeholder", "status", "helperText", "errorText", "value", "defaultValue", "startDate", "onChange", "disabled", "onVisibilityChange", "endDate", "columnsFormat", "formatPickedValueDisplay", "locale", "dateFormat", "title"];
var DatePicker = function DatePicker2(props) {
  var inputClass = props.inputClass, suffix = props.suffix, label = props.label, placeholder = props.placeholder, status = props.status, helperText = props.helperText, errorText = props.errorText, value = props.value, defaultValue = props.defaultValue, _props$startDate = props.startDate, startDate = _props$startDate === void 0 ? new Date(1900, 0, 1, 0, 0, 0) : _props$startDate, onChange = props.onChange, disabled = props.disabled, onVisibilityChange = props.onVisibilityChange, _props$endDate = props.endDate, endDate = _props$endDate === void 0 ? new Date(2100, 31, 11, 0, 0, 0) : _props$endDate, _props$columnsFormat = props.columnsFormat, columnsFormat = _props$columnsFormat === void 0 ? "DD-MM-YYYY" : _props$columnsFormat, formatPickedValueDisplay = props.formatPickedValueDisplay, _props$locale = props.locale, locale = _props$locale === void 0 ? "vi-VN" : _props$locale, _props$dateFormat = props.dateFormat, dateFormat = _props$dateFormat === void 0 ? "dd/mm/yyyy" : _props$dateFormat, title = props.title, restProps = _objectWithoutPropertiesLoose(props, _excluded31);
  var prefixCls = getPrefixCls("date-picker");
  var cls = clsx_m_default(prefixCls, inputClass);
  var _useState = (0, import_react95.useState)(function() {
    return createPickerColumns(value || defaultValue || /* @__PURE__ */ new Date(), {
      startDate,
      endDate,
      datePickerColumns: columnsFormat,
      dateFormat,
      locale
    });
  }), datePickerData = _useState[0], setDatePickerData = _useState[1];
  var _useState2 = (0, import_react95.useState)(), dateValue = _useState2[0], setDateValue = _useState2[1];
  var initDateValue = convertDateToPickerValue(/* @__PURE__ */ new Date());
  var defaultDateValue = defaultValue ? convertDateToPickerValue(defaultValue) : void 0;
  (0, import_react95.useEffect)(function() {
    if (value) {
      setDateValue(convertDateToPickerValue(value));
    } else {
      setDateValue(void 0);
    }
  }, [value]);
  var updateData = function updateData2(curDate, curMonth, curYear, fireOnChange) {
    if (fireOnChange === void 0) {
      fireOnChange = true;
    }
    var currentDate = curDate;
    var currentMonth = curMonth;
    var currentYear = curYear;
    var needUpdate = false;
    var _getDateRange = getDateRange(startDate, endDate), settingStartDate = _getDateRange.startDate, startMonth = _getDateRange.startMonth, settingEndDate = _getDateRange.endDate, endMonth = _getDateRange.endMonth;
    var _getPosition = getPosition2({
      startDate,
      endDate,
      currentMonth,
      currentYear
    }), isEndMonth = _getPosition.isEndMonth, isEndYear = _getPosition.isEndYear, isStartMonth = _getPosition.isStartMonth, isStartYear = _getPosition.isStartYear;
    var dateCols;
    var monthCols;
    var yearCols;
    datePickerData.forEach(function(col) {
      if (col.name === DATE_COL_NAME) {
        dateCols = col;
      }
      if (col.name === MONTH_COL_NAME) {
        monthCols = col;
      }
      if (col.name === YEAR_COL_NAME) {
        yearCols = col;
      }
    });
    var startOptMonth = isStartYear ? startMonth : 1;
    var endOptMonth = isEndYear ? endMonth : 12;
    if (monthCols && monthCols.options.length !== endOptMonth - startOptMonth + 1) {
      needUpdate = true;
      var opts = [];
      for (var m = startOptMonth; m <= endOptMonth; m += 1) {
        opts.push({
          value: m.toString(),
          displayName: monthFormatter(locale).format((/* @__PURE__ */ new Date("0001-01-01")).setMonth(m - 1))
        });
      }
      monthCols.options = [].concat(opts);
    }
    if (isStartYear && currentMonth < startMonth) {
      currentMonth = startMonth;
    }
    if (isEndYear && currentMonth > endMonth) {
      currentMonth = endMonth;
    }
    var monthlyDays = getMonthlyDay(currentYear, currentMonth);
    var startOptDate = isStartMonth ? settingStartDate : 1;
    var endOptDate = isEndMonth ? settingEndDate : monthlyDays;
    if (dateCols && dateCols.options.length !== endOptDate - startOptDate + 1) {
      needUpdate = true;
      var _opts = [];
      for (var d = startOptDate; d <= endOptDate; d += 1) {
        _opts.push({
          value: d.toString(),
          displayName: dayFormatter(locale).format((/* @__PURE__ */ new Date("0001-01-01")).setDate(d))
        });
      }
      dateCols.options = [].concat(_opts);
    }
    if (currentDate > monthlyDays) {
      currentDate = monthlyDays;
    }
    if (isEndMonth && currentDate > settingEndDate) {
      currentDate = settingEndDate;
    } else if (isStartMonth && currentDate < settingStartDate) {
      currentDate = settingStartDate;
    }
    if (needUpdate) {
      var newOpts = [];
      datePickerData.forEach(function(col) {
        if (col.name === DATE_COL_NAME && dateCols) {
          newOpts.push(dateCols);
        }
        if (col.name === YEAR_COL_NAME && yearCols) {
          newOpts.push(yearCols);
        }
        if (col.name === MONTH_COL_NAME && monthCols) {
          newOpts.push(monthCols);
        }
      });
      setDatePickerData(newOpts);
    }
    if (!Number.isNaN(curYear) && !Number.isNaN(curMonth) && !Number.isNaN(curDate)) {
      var _setDateValue;
      setDateValue((_setDateValue = {}, _setDateValue[YEAR_COL_NAME] = currentYear.toString(), _setDateValue[MONTH_COL_NAME] = currentMonth.toString(), _setDateValue[DATE_COL_NAME] = currentDate.toString(), _setDateValue));
      if (fireOnChange) {
        var _onChange;
        onChange == null || onChange(new Date(currentYear, currentMonth - 1, currentDate, 0, 0, 0), (_onChange = {}, _onChange[YEAR_COL_NAME] = currentYear.toString(), _onChange[MONTH_COL_NAME] = currentMonth.toString(), _onChange[DATE_COL_NAME] = currentDate.toString(), _onChange));
      }
    }
  };
  var handleChangePicker = function handleChangePicker2(val) {
    var _val$DATE_COL_NAME, _val$MONTH_COL_NAME, _val$YEAR_COL_NAME;
    var date = parseInt((_val$DATE_COL_NAME = val[DATE_COL_NAME]) == null ? void 0 : _val$DATE_COL_NAME.value.toString(), 10);
    var month = parseInt((_val$MONTH_COL_NAME = val[MONTH_COL_NAME]) == null ? void 0 : _val$MONTH_COL_NAME.value.toString(), 10);
    var year = parseInt((_val$YEAR_COL_NAME = val[YEAR_COL_NAME]) == null ? void 0 : _val$YEAR_COL_NAME.value.toString(), 10);
    if (!Number.isNaN(year)) {
      updateData(date, month, year);
    }
  };
  var updateDatePickerData = function updateDatePickerData2() {
    if (!value) {
      return;
    }
    updateData(value.getDate(), value.getMonth() + 1, value.getFullYear(), false);
  };
  var suffixIconNode = import_react95.default.createElement("span", {
    className: prefixCls + "-suffix"
  }, suffix || import_react95.default.createElement(icon_default, {
    icon: "zi-calendar"
  }));
  var formatDateValue = function formatDateValue2(pickedValue) {
    if (pickedValue[DATE_COL_NAME] && pickedValue[MONTH_COL_NAME] && pickedValue[YEAR_COL_NAME]) {
      var curDate = parseInt(pickedValue[DATE_COL_NAME].value.toString(), 10);
      var curMonth = parseInt(pickedValue[MONTH_COL_NAME].value.toString(), 10);
      var curYear = parseInt(pickedValue[YEAR_COL_NAME].value.toString(), 10);
      var date = new Date(curYear, curMonth - 1, curDate, 0, 0, 0);
      if (formatPickedValueDisplay) {
        return formatPickedValueDisplay(date);
      }
      return formatDate(date, {
        dateFormat,
        locale
      });
    }
    return "";
  };
  return import_react95.default.createElement(picker_default, _extends({
    data: datePickerData,
    title,
    label,
    placeholder: placeholder || dateFormat,
    status,
    value: dateValue,
    defaultValue: defaultDateValue,
    helperText,
    errorText,
    inputClass: cls,
    datePicker: true,
    disabled,
    formatPickedValueDisplay: formatDateValue,
    initData: initDateValue,
    suffix: suffixIconNode,
    updateDatePickerData,
    onChange: handleChangePicker,
    onVisibilityChange
  }, restProps));
};
var date_picker_default = DatePicker;

// node_modules/zmp-ui/esm/components/bottom-navigation/BottomNavigation.js
var import_react101 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/bottom-navigation/context.js
var import_react96 = __toESM(require_react());
var BottomNavigationContext = (0, import_react96.createContext)(null);

// node_modules/zmp-ui/esm/components/bottom-navigation/utils/index.js
var import_react97 = __toESM(require_react());
function ownKeys24(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread24(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys24(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys24(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var parseItemList = function parseItemList2(children2) {
  var tabs = toArray2(children2).map(function(node) {
    if (import_react97.default.isValidElement(node)) {
      var key = node.key !== void 0 ? String(node.key) : void 0;
      return _objectSpread24(_objectSpread24({
        key
      }, node.props), {}, {
        node
      });
    }
    return null;
  }).filter(function(tab) {
    return tab;
  });
  return tabs;
};

// node_modules/zmp-ui/esm/components/bottom-navigation/BottomNavigationItem.js
var import_react98 = __toESM(require_react());
var BottomNavigationItem = import_react98.default.forwardRef(function(props, ref) {
  var _classNames;
  var icon2 = props.icon, activeIcon = props.activeIcon, label = props.label, onClick = props.onClick, active = props.active, onChange = props.onChange, itemKey = props.itemKey, id = props.id, className = props.className, style = props.style;
  var prefixCls = getPrefixCls("bottom-navigation-item");
  var cls = clsx_m_default(prefixCls, className, (_classNames = {}, _classNames[prefixCls + "-active"] = !!active, _classNames));
  var handleClickItem = function handleClickItem2(e) {
    if (itemKey) {
      onChange(itemKey);
    }
    onClick == null || onClick(e);
  };
  var iconEl = active && activeIcon ? activeIcon : icon2;
  return import_react98.default.createElement("button", {
    id,
    style,
    ref,
    onClick: handleClickItem,
    className: cls
  }, iconEl && import_react98.default.createElement("span", {
    className: prefixCls + "-icon"
  }, " ", iconEl), import_react98.default.createElement("span", {
    className: prefixCls + "-label"
  }, label));
});
var BottomNavigationItem_default = BottomNavigationItem;

// node_modules/zmp-ui/esm/components/bottom-navigation/AnimatedBottomNavigationItem.js
var import_react100 = __toESM(require_react());

// node_modules/zmp-ui/esm/hooks/useNavigate/index.js
var import_react99 = __toESM(require_react());
var useNavigate2 = function useNavigate3() {
  var navigate = useNavigate();
  var context = import_react99.default.useContext(AnimationRouterContext);
  if (!context) {
    throw new Error("To use `useNavigate`, component must be contained with ZMPRouter component");
  }
  return (0, import_react99.useCallback)(function(to3, options) {
    var _ref = options || {}, animate = _ref.animate, direction = _ref.direction;
    context.setAnimate({
      animate: animate != null ? animate : true,
      direction: direction || "forward"
    });
    if (typeof to3 === "number") {
      navigate(to3);
    } else {
      navigate(to3, options);
    }
  }, [context, navigate]);
};
var useNavigate_default = useNavigate2;

// node_modules/zmp-ui/esm/components/bottom-navigation/AnimatedBottomNavigationItem.js
var _excluded32 = ["linkTo", "onClick"];
var AnimatedBottomNavigationItem = import_react100.default.forwardRef(function(props, ref) {
  var navigate = useNavigate_default();
  var context = (0, import_react100.useContext)(BottomNavigationContext);
  var linkTo = props.linkTo, onClick = props.onClick, rest = _objectWithoutPropertiesLoose(props, _excluded32);
  var itemRef = (0, import_react100.useRef)(null);
  var handleClick = function handleClick2(e) {
    if (onClick) {
      onClick == null || onClick(e);
    } else if (linkTo) {
      var direction = "forward";
      if (context && context.items) {
        var itemKey = context.items.findIndex(function(item) {
          return item.key === rest.itemKey;
        });
        var activeItemkey = context.items.findIndex(function(item) {
          return item.key === context.activeKey;
        });
        direction = activeItemkey > itemKey ? "backward" : "forward";
        if (activeItemkey === itemKey) {
          return;
        }
      }
      navigate == null || navigate(linkTo, {
        animate: true,
        direction
      });
    }
  };
  (0, import_react100.useImperativeHandle)(ref, function() {
    return itemRef.current;
  });
  return import_react100.default.createElement(BottomNavigationItem_default, _extends({
    ref: itemRef
  }, rest, {
    onClick: handleClick
  }));
});
var AnimatedBottomNavigationItem_default = AnimatedBottomNavigationItem;

// node_modules/zmp-ui/esm/components/bottom-navigation/BottomNavigation.js
var _excluded33 = ["key", "style", "className", "itemKey", "linkTo"];
function ownKeys25(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread25(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys25(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys25(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var BottomNavigation = import_react101.default.forwardRef(function(props, ref) {
  var _classNames;
  var className = props.className, style = props.style, children2 = props.children, fixed = props.fixed, id = props.id, onChange = props.onChange, activeKey = props.activeKey, defaultActiveKey = props.defaultActiveKey, zIndex = props.zIndex;
  var prefixCls = getPrefixCls("bottom-navigation");
  var cls = clsx_m_default(prefixCls, className, (_classNames = {}, _classNames[prefixCls + "-fixed"] = fixed, _classNames));
  var items = parseItemList(children2);
  if (!items || items.length < 2) {
    console.warn("Bottom Navigation must to have at least 2 items");
  }
  var itemKeys = items.map(function(item) {
    return item.key;
  }).join("_");
  var _useMergedState = useMergedState(function() {
    var _items$;
    return (_items$ = items[0]) == null ? void 0 : _items$.key;
  }, {
    value: activeKey,
    defaultValue: defaultActiveKey
  }), mergedActiveKey = _useMergedState[0], setMergedActiveKey = _useMergedState[1];
  var _useState = (0, import_react101.useState)(function() {
    return items.findIndex(function(item) {
      return item.key === mergedActiveKey;
    });
  }), activeIndex = _useState[0], setActiveIndex = _useState[1];
  (0, import_react101.useEffect)(function() {
    var newActiveIndex = items.findIndex(function(item) {
      return item.key === mergedActiveKey;
    });
    if (newActiveIndex === -1) {
      var _items$newActiveIndex;
      newActiveIndex = Math.max(0, Math.min(activeIndex, items.length - 1));
      setMergedActiveKey((_items$newActiveIndex = items[newActiveIndex]) == null ? void 0 : _items$newActiveIndex.key);
    }
    setActiveIndex(newActiveIndex);
  }, [mergedActiveKey, activeIndex, items, itemKeys, setMergedActiveKey]);
  var handleonChange = function handleonChange2(key) {
    var isActiveChanged = key !== mergedActiveKey;
    setMergedActiveKey(key);
    if (isActiveChanged) {
      onChange == null || onChange(key);
    }
  };
  var contextValue = (0, import_react101.useMemo)(function() {
    return {
      activeKey: mergedActiveKey,
      items
    };
  }, [items, mergedActiveKey]);
  var elStyle = _objectSpread25(_objectSpread25({}, style || {}), zIndex !== void 0 ? {
    zIndex
  } : {});
  return import_react101.default.createElement("div", {
    ref,
    id,
    style: elStyle,
    className: cls
  }, import_react101.default.createElement("div", {
    className: prefixCls + "-content"
  }, import_react101.default.createElement(BottomNavigationContext.Provider, {
    value: contextValue
  }, items.map(function(item) {
    var key = item.key, tabStyle = item.style, tabClassName = item.className, itemKey = item.itemKey, linkTo = item.linkTo, restTabProps = _objectWithoutPropertiesLoose(item, _excluded33);
    var activeItem = key === mergedActiveKey;
    if (linkTo) {
      return import_react101.default.createElement(AnimatedBottomNavigationItem_default, _extends({
        key
      }, restTabProps, {
        linkTo,
        style: tabStyle,
        active: activeItem,
        itemKey: itemKey || key,
        className: tabClassName,
        onChange: handleonChange
      }));
    }
    return import_react101.default.createElement(BottomNavigationItem_default, _extends({
      key
    }, restTabProps, {
      style: tabStyle,
      active: activeItem,
      itemKey: itemKey || key,
      className: tabClassName,
      onChange: handleonChange
    }));
  }))));
});
var BottomNavigation_default = BottomNavigation;

// node_modules/zmp-ui/esm/components/bottom-navigation/index.js
var BottomNavigation2 = BottomNavigation_default;
BottomNavigation2.Item = BottomNavigationItem_default;
var bottom_navigation_default = BottomNavigation2;

// node_modules/zmp-ui/esm/components/swiper/Swiper.js
var import_react106 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/swiper/utils/index.js
var import_react102 = __toESM(require_react());
function ownKeys26(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread26(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys26(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys26(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var getSlides = function getSlides2(children2, loop2) {
  var slides = toArray2(children2).map(function(node, index2) {
    if (import_react102.default.isValidElement(node)) {
      var key = node.key ? String(node.key) : index2;
      return _objectSpread26(_objectSpread26({
        key
      }, node.props), {}, {
        node
      });
    }
    return null;
  }).filter(function(slide) {
    return slide;
  });
  if (loop2) {
    var firstSlide = slides[0];
    var lastSlide = slides[slides.length - 1];
    if (firstSlide) {
      slides.push(_objectSpread26(_objectSpread26({}, firstSlide), {}, {
        key: firstSlide.key + "-clone"
      }));
    }
    if (lastSlide) {
      slides.unshift(_objectSpread26(_objectSpread26({}, lastSlide), {}, {
        key: (lastSlide == null ? void 0 : lastSlide.key) + "-clone"
      }));
    }
  }
  return slides;
};

// node_modules/zmp-ui/esm/components/swiper/context.js
var import_react103 = __toESM(require_react());
var SwiperContext = (0, import_react103.createContext)(null);

// node_modules/zmp-ui/esm/components/swiper/SwiperSlide.js
var import_react104 = __toESM(require_react());
var _excluded34 = ["children", "style", "className"];
var SwiperSlide = import_react104.default.forwardRef(function(props, ref) {
  var children2 = props.children, _props$style = props.style, style = _props$style === void 0 ? {} : _props$style, className = props.className, restProps = _objectWithoutPropertiesLoose(props, _excluded34);
  var prefixCls = getPrefixCls("swiper-item");
  var cls = clsx_m_default(prefixCls, className);
  return import_react104.default.createElement(animated.div, _extends({}, restProps, {
    ref,
    className: cls,
    style
  }), children2);
});
SwiperSlide.defaultProps = {
  style: {}
};
var SwiperSlide_default = SwiperSlide;

// node_modules/zmp-ui/esm/components/swiper/SwiperDots.js
var import_react105 = __toESM(require_react());
var SwiperDots = function SwiperDots2() {
  var context = (0, import_react105.useContext)(SwiperContext);
  var prefixCls = getPrefixCls("swiper-dots");
  var cls = clsx_m_default(prefixCls);
  var getDots = function getDots2() {
    if (!context) return null;
    var slides = context.slides, activeIndex = context.activeIndex;
    return slides.map(function(slide, index2) {
      var _clsx;
      var slideCls = clsx_m_default(prefixCls + "-item", (_clsx = {}, _clsx[prefixCls + "-item-active"] = activeIndex === index2, _clsx));
      return import_react105.default.createElement("div", {
        key: "dot-" + slide.key,
        className: slideCls
      });
    });
  };
  return import_react105.default.createElement("div", {
    className: cls
  }, getDots());
};
var SwiperDots_default = SwiperDots;

// node_modules/zmp-ui/esm/components/swiper/utils/constants.js
var DURATION = 400;
var AUTOPLAY_DELAY = 3e3;
var SWIPE_DISTANCE = 100;

// node_modules/zmp-ui/esm/components/swiper/Swiper.js
var _excluded35 = ["style"];
function ownKeys27(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread27(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys27(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys27(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Swiper = import_react106.default.forwardRef(function(props, ref) {
  var children2 = props.children, _props$defaultActive = props.defaultActive, defaultActive = _props$defaultActive === void 0 ? 0 : _props$defaultActive, _props$dots = props.dots, dots = _props$dots === void 0 ? true : _props$dots, _props$autoplay = props.autoplay, autoplay = _props$autoplay === void 0 ? false : _props$autoplay, id = props.id, style = props.style, className = props.className, afterChange = props.afterChange, _props$duration = props.duration, duration = _props$duration === void 0 ? AUTOPLAY_DELAY : _props$duration, _props$loop = props.loop, loop2 = _props$loop === void 0 ? false : _props$loop, _props$disableSwipe = props.disableSwipe, disableSwipe = _props$disableSwipe === void 0 ? false : _props$disableSwipe;
  var autoPlayRequest = import_react106.default.useRef(0);
  var lastTimeAutoPlay = import_react106.default.useRef(0);
  var index2 = (0, import_react106.useRef)(loop2 ? defaultActive + 1 : defaultActive);
  var _useState = (0, import_react106.useState)(loop2 ? defaultActive + 1 : defaultActive), active = _useState[0], setActive = _useState[1];
  var runningAnimation = (0, import_react106.useRef)(false);
  var _useState2 = (0, import_react106.useState)({
    xMove: 0,
    down: false
  }), springState = _useState2[0], setSpringState = _useState2[1];
  var slides = getSlides(children2, loop2);
  var _useSprings = useSprings(slides.length, function() {
    return {
      opacity: 1
    };
  }), springs = _useSprings[0], setOpacity = _useSprings[1];
  var _useSpring = useSpring(function() {
    return {
      translateX: -active * 100,
      moving: 0,
      config: {
        duration: DURATION
      }
    };
  }, []), _useSpring$ = _useSpring[0], translateX = _useSpring$.translateX, moving = _useSpring$.moving, set = _useSpring[1];
  var prefixCls = getPrefixCls("swiper");
  var cls = clsx_m_default(prefixCls, className);
  var xMove = springState.xMove, down = springState.down;
  var getTotalSlides = (0, import_react106.useCallback)(function() {
    if (loop2) {
      return slides.length - 2;
    }
    return slides.length;
  }, [slides, loop2]);
  var runSprings = (0, import_react106.useCallback)(function(_vx, isDragging, mx, offset) {
    var offsetValue = offset || 1;
    if (isDragging || runningAnimation.current) {
      return;
    }
    var totalSlides = getTotalSlides();
    var activeIndex = index2.current;
    if (!isDragging && Math.abs(mx) > SWIPE_DISTANCE) {
      index2.current += mx > 0 ? -1 * offsetValue : 1 * offsetValue;
      activeIndex = index2.current;
      if (index2.current === totalSlides) {
        activeIndex = loop2 ? totalSlides : totalSlides - 1;
        setActive(totalSlides);
      } else if (index2.current <= 0) {
        activeIndex = loop2 ? totalSlides + index2.current % totalSlides : 0;
        setActive(activeIndex);
      } else {
        activeIndex = index2.current % totalSlides;
        setActive(activeIndex);
      }
    }
    var finalY = index2.current % slides.length * 100;
    setOpacity(function(i) {
      return {
        opacity: i % totalSlides === activeIndex ? 1 : 0.8
      };
    });
    set({
      translateX: -finalY,
      moving: 0,
      config: {
        duration: void 0
      },
      onStart: function onStart() {
        runningAnimation.current = true;
      },
      onRest: function onRest() {
        runningAnimation.current = false;
        if (!loop2) {
          afterChange == null || afterChange(activeIndex);
          return;
        }
        if (index2.current === 0) {
          index2.current = slides.length - 2;
          set({
            translateX: -index2.current * 100,
            moving: 0,
            config: {
              duration: 0
            }
          });
        } else if (index2.current === slides.length - 1) {
          index2.current = 1;
          set({
            translateX: -index2.current * 100,
            moving: 0,
            config: {
              duration: 0
            }
          });
        }
        afterChange == null || afterChange(activeIndex - 1);
      }
    });
  }, [slides.length, setOpacity, set, afterChange, getTotalSlides, loop2]);
  var handleAutoPlay = (0, import_react106.useCallback)(function(now) {
    if (now - lastTimeAutoPlay.current >= duration) {
      lastTimeAutoPlay.current = now;
      if (!down) {
        runSprings(-1, false, -(SWIPE_DISTANCE + 1));
      }
    }
    autoPlayRequest.current = requestAnimationFrame(handleAutoPlay);
  }, [down, duration, runSprings]);
  var nextSlide = (0, import_react106.useCallback)(function() {
    if (down) {
      return;
    }
    if (!loop2 && index2.current >= slides.length - 1) {
      return;
    }
    runSprings(-1, false, -(SWIPE_DISTANCE + 1));
  }, [down, runSprings, loop2, slides]);
  var prevSlide = (0, import_react106.useCallback)(function() {
    if (down) {
      return;
    }
    if (!loop2 && index2.current === 0) {
      return;
    }
    runSprings(-1, false, SWIPE_DISTANCE + 1);
  }, [down, runSprings, loop2]);
  var goToSlide = (0, import_react106.useCallback)(function(slideIndex) {
    var totalSlides = getTotalSlides();
    var validIndex = slideIndex;
    if (slideIndex > totalSlides - 1) {
      validIndex = totalSlides - 1;
    }
    if (slideIndex < 0) {
      validIndex = 0;
    }
    var delta = validIndex - active;
    if (loop2) {
      delta += 1;
    }
    if (delta === 0) {
      return;
    }
    runSprings(-1, false, -delta * (SWIPE_DISTANCE + 1), Math.abs(delta));
  }, [active, loop2, getTotalSlides, runSprings]);
  (0, import_react106.useImperativeHandle)(ref, function() {
    return {
      next: nextSlide,
      prev: prevSlide,
      goTo: goToSlide,
      activeIndex: loop2 ? active - 1 : active
    };
  }, [active, nextSlide, prevSlide, goToSlide, loop2]);
  (0, import_react106.useEffect)(function() {
    if (autoplay) {
      autoPlayRequest.current = requestAnimationFrame(handleAutoPlay);
    }
    return function() {
      if (autoPlayRequest.current) {
        cancelAnimationFrame(autoPlayRequest.current);
      }
    };
  }, [autoplay, handleAutoPlay]);
  (0, import_react106.useEffect)(function() {
    if (down) {
      set({
        moving: xMove,
        config: {
          duration: 0
        }
      });
    }
  }, [down, xMove, set]);
  var bind = useDrag(function(_ref) {
    var _ref$velocity = _ref.velocity, vx = _ref$velocity[0], isDown = _ref.down, _ref$movement = _ref.movement, mx = _ref$movement[0];
    if (runningAnimation.current) {
      return;
    }
    var totalSlides = getTotalSlides();
    if (mx > 0 && index2.current === 0 && !loop2) {
      return;
    }
    if (mx < 0 && index2.current >= totalSlides - 1 && !loop2) {
      return;
    }
    setSpringState({
      xMove: mx,
      down: isDown
    });
    runSprings(-vx, isDown, mx);
  }, {
    filterTaps: true,
    enabled: !disableSwipe
  });
  var contextValue = (0, import_react106.useMemo)(function() {
    return {
      activeIndex: loop2 ? active - 1 : active,
      slides: loop2 ? slides.slice(1, slides.length - 1) : slides
    };
  }, [slides, active, loop2]);
  var transform = to2([translateX, moving], function(amount, movingAmount) {
    return "translateX(calc(" + amount + "% + " + movingAmount + "px))";
  });
  return import_react106.default.createElement(SwiperContext.Provider, {
    value: contextValue
  }, import_react106.default.createElement("div", {
    className: cls,
    id,
    style
  }, import_react106.default.createElement(animated.div, _extends({
    className: prefixCls + "-wrapper",
    style: {
      transform
    }
  }, bind()), springs.map(function(_ref2, i) {
    var opacity = _ref2.opacity;
    var slide = slides[i];
    var _slide$node$props = slide.node.props, slideStyle = _slide$node$props.style, rest = _objectWithoutPropertiesLoose(_slide$node$props, _excluded35);
    return import_react106.default.createElement(SwiperSlide_default, _extends({
      style: _objectSpread27(_objectSpread27({}, slideStyle), {}, {
        opacity
      })
    }, rest, {
      key: slide.key
    }), slide.children);
  })), dots && import_react106.default.createElement(SwiperDots_default, null)));
});
var Swiper_default = Swiper;

// node_modules/zmp-ui/esm/components/swiper/index.js
var Swiper2 = Swiper_default;
Swiper2.Slide = SwiperSlide_default;
var swiper_default = Swiper2;

// node_modules/zmp-ui/esm/components/image-viewer/index.js
var import_react111 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/image-viewer/Image.js
var import_react109 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/image-viewer/context.js
var import_react108 = __toESM(require_react());
var ImageViewerContext = (0, import_react108.createContext)(null);

// node_modules/zmp-ui/esm/components/image-viewer/Image.js
function ownKeys28(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread28(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys28(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys28(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Image = import_react109.default.forwardRef(function(props, ref) {
  var src = props.src, alt = props.alt;
  var width = window.innerWidth;
  var height = window.innerHeight;
  var targetRef = (0, import_react109.useRef)(null);
  var boundsRef = (0, import_react109.useRef)(null);
  var clicks = (0, import_react109.useRef)(0);
  var singleClickTimer = (0, import_react109.useRef)(0);
  var _useState = (0, import_react109.useState)(false), isPinching = _useState[0], setIsPinching = _useState[1];
  var _ref = (0, import_react109.useContext)(ImageViewerContext) || {
    isZoomed: false
  }, isZoomed = _ref.isZoomed, setIsZoomed = _ref.setIsZoomed, toggleHeader = _ref.setShowHeader;
  var getScale = function getScale2(_ref2) {
    var displayWidth = _ref2.displayWidth, displayHeight = _ref2.displayHeight;
    var imgEl = targetRef.current;
    if (imgEl) {
      var naturalHeight = imgEl.naturalHeight, naturalWidth = imgEl.naturalWidth;
      if (naturalHeight < displayHeight && naturalWidth < displayWidth) {
        return 1;
      }
      var realDisplayHeight = displayWidth * naturalHeight / naturalWidth;
      if (realDisplayHeight > displayHeight) {
        return naturalHeight / displayHeight;
      }
      return naturalWidth / displayWidth;
    }
    return 1;
  };
  var _useSpring = useSpring(function() {
    return {
      x: 0,
      y: 0,
      scale: getScale({
        displayWidth: width,
        displayHeight: height
      })
    };
  }), style = _useSpring[0], api = _useSpring[1];
  (0, import_react109.useImperativeHandle)(ref, function() {
    return boundsRef.current;
  });
  var prefixCls = getPrefixCls("image");
  var cls = clsx_m_default(prefixCls);
  var handleZoom = (0, import_react109.useCallback)(function(event) {
    var el = targetRef.current;
    var maxScale = getScale({
      displayHeight: height,
      displayWidth: width
    });
    if (!isZoomed && maxScale === 1) {
      return;
    }
    if (!isZoomed && el) {
      var clientX = event.clientX, clientY = event.clientY;
      api.start({
        x: Math.round((width / 2 - clientX) * maxScale),
        y: Math.round((height / 2 - clientY) * maxScale),
        scale: maxScale,
        onRest: function onRest() {
          setIsZoomed == null || setIsZoomed(true);
        }
      });
    } else if (el) {
      api.start({
        scale: 1,
        x: 0,
        y: 0,
        onRest: function onRest() {
          setIsZoomed == null || setIsZoomed(false);
        }
      });
    }
    toggleHeader == null || toggleHeader(!!isZoomed);
  }, [api, height, isZoomed, setIsZoomed, toggleHeader, width]);
  var handleOnPinch = function handleOnPinch2(_ref3) {
    var offset = _ref3.offset, first = _ref3.first, pinching = _ref3.pinching;
    var scaleValue = offset[0];
    var maxScale = getScale({
      displayHeight: height,
      displayWidth: width
    });
    if (!isZoomed && maxScale === 1) {
      return;
    }
    if (first) {
      setIsZoomed == null || setIsZoomed(true);
      setIsPinching(true);
      return;
    }
    if (pinching) {
      api.set({
        scale: scaleValue
      });
    } else {
      api.set({
        scale: scaleValue,
        x: 0,
        y: 0
      });
      setIsPinching(false);
      setIsZoomed == null || setIsZoomed(scaleValue > 1);
    }
  };
  var handleDragImage = function handleDragImage2(_ref4) {
    var first = _ref4.first, _ref4$movement = _ref4.movement, mx = _ref4$movement[0], my = _ref4$movement[1], _ref4$memo = _ref4.memo, memo = _ref4$memo === void 0 ? [] : _ref4$memo;
    if (!isZoomed || !mx && !my || isPinching) {
      return [0, 0, width, height];
    }
    var memoValue = memo;
    if (first) {
      var scale = style.scale.get();
      var _x = style.x.get();
      var _y = style.y.get();
      var _w = width * scale;
      var _h = height * scale;
      memoValue = [_x + mx, _y + my, _w, _h];
    }
    var _memoValue = memoValue, x = _memoValue[0], y = _memoValue[1], w = _memoValue[2], h = _memoValue[3];
    var posX = Math.min(w * 0.5, Math.max(x + mx, -w * 0.5));
    var posY = Math.min(w * 0.5, Math.max(y + my, -h * 0.5));
    api.start({
      x: posX,
      y: posY
    });
    return memoValue;
  };
  var handleClick = function handleClick2(_ref5) {
    var event = _ref5.event;
    clicks.current += 1;
    if (clicks.current === 1) {
      singleClickTimer.current = window.setTimeout(function() {
        toggleHeader == null || toggleHeader(function(show) {
          return !show;
        });
        clicks.current = 0;
        clearTimeout(singleClickTimer.current);
      }, 250);
    } else if (clicks.current === 2) {
      handleZoom(event);
      clicks.current = 0;
      clearTimeout(singleClickTimer.current);
    }
  };
  var bind = useGesture({
    onDrag: handleDragImage,
    onPinch: handleOnPinch,
    onClick: handleClick
  }, {
    pinch: {
      threshold: 0.1,
      scaleBounds: {
        min: 1,
        max: getScale({
          displayHeight: height,
          displayWidth: width
        })
      }
    },
    drag: {
      filterTaps: true,
      enabled: isZoomed
    }
  });
  return import_react109.default.createElement("div", {
    ref: boundsRef,
    className: prefixCls + "-container"
  }, import_react109.default.createElement(animated.img, _extends({
    ref: targetRef,
    className: cls,
    src,
    alt,
    style: _objectSpread28({}, style)
  }, bind())));
});
var Image_default = Image;

// node_modules/zmp-ui/esm/components/image-viewer/index.js
var _excluded36 = ["images", "visible", "onClose", "activeIndex", "maskStyle", "maskClassName"];
function ownKeys29(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread29(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys29(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys29(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var ImageViewer = import_react111.default.forwardRef(function(props, ref) {
  var images = props.images, visible = props.visible, onClose = props.onClose, defaultActiveIndex = props.activeIndex, maskStyle = props.maskStyle, maskClassName = props.maskClassName, rest = _objectWithoutPropertiesLoose(props, _excluded36);
  var _useState = (0, import_react111.useState)(false), isZoomed = _useState[0], setIsZoomed = _useState[1];
  var _useState2 = (0, import_react111.useState)(defaultActiveIndex || 0), activeIndex = _useState2[0], setActiveIndex = _useState2[1];
  var force = (0, import_react111.useRef)(false);
  var prevActiveIndex = (0, import_react111.useRef)(defaultActiveIndex || 0);
  var _useState3 = (0, import_react111.useState)(!!visible), animationVisible = _useState3[0], setAnimationVisible = _useState3[1];
  var _useState4 = (0, import_react111.useState)(true), showHeader = _useState4[0], setShowHeader = _useState4[1];
  var prefixCls = getPrefixCls("image-viewer");
  var cls = clsx_m_default(prefixCls);
  var contextValue = (0, import_react111.useMemo)(function() {
    return {
      isZoomed,
      setIsZoomed,
      currentIndex: activeIndex,
      showHeader,
      setShowHeader
    };
  }, [isZoomed, activeIndex, showHeader]);
  var style = useSpring({
    scale: visible ? 1 : 0.5,
    opacity: visible ? 1 : 0.5,
    config: {
      duration: 200
    },
    onRest: function onRest() {
      if (!visible) {
        setAnimationVisible(false);
      }
    }
  });
  var transitions = useTransition(activeIndex, {
    key: activeIndex,
    from: {
      opacity: 0,
      transform: activeIndex < prevActiveIndex.current ? "translate3d(-50%,0,0)" : "translate3d(50%,0,0)"
    },
    enter: {
      opacity: 1,
      transform: "translate3d(0%,0,0)",
      onRest: function onRest() {
        prevActiveIndex.current = activeIndex;
        force.current = false;
      },
      config: {
        duration: force.current ? 0 : 300
      }
    },
    leave: {
      opacity: 0,
      transform: activeIndex < prevActiveIndex.current ? "translate3d(50%,0,0)" : "translate3d(-50%,0,0)",
      config: {
        duration: force.current ? 0 : 200
      }
    },
    exitBeforeEnter: true
  });
  var bind = useDrag(function(_ref) {
    var isDown = _ref.down, _ref$movement = _ref.movement, mx = _ref$movement[0];
    if (isZoomed) {
      return;
    }
    var totalImages = images.length;
    if (mx > 0 && activeIndex === 0) {
      return;
    }
    if (mx < 0 && activeIndex >= totalImages - 1) {
      return;
    }
    if (!isDown && Math.abs(mx) > 100) {
      if (mx > 0) {
        setActiveIndex(activeIndex - 1);
      } else {
        setActiveIndex(activeIndex + 1);
      }
    }
  }, {
    filterTaps: true
  });
  (0, import_react111.useLayoutEffect)(function() {
    if (visible) {
      if (defaultActiveIndex !== prevActiveIndex.current) {
        force.current = true;
      }
      if (!Number.isNaN(defaultActiveIndex)) {
        setActiveIndex(defaultActiveIndex || 0);
      }
      setAnimationVisible(visible);
    }
  }, [visible]);
  var goToNextImage = function goToNextImage2() {
    setActiveIndex(function(curIndex) {
      return Math.min(curIndex + 1, images.length);
    });
  };
  var goToPrevImage = function goToPrevImage2() {
    setActiveIndex(function(curIndex) {
      return Math.max(curIndex - 1, 0);
    });
  };
  return import_react111.default.createElement(ImageViewerContext.Provider, {
    value: contextValue
  }, import_react111.default.createElement("div", _extends({
    className: cls,
    ref
  }, rest), import_react111.default.createElement(modal_mask_default, {
    visible,
    style: maskStyle,
    className: maskClassName
  }), visible && showHeader && import_react111.default.createElement("div", {
    className: prefixCls + "-header"
  }, import_react111.default.createElement("span", {
    role: "presentation",
    className: prefixCls + "-close-button",
    onClick: onClose
  }, "ÄÃ³ng")), import_react111.default.createElement(animated.div, {
    style: _objectSpread29({
      display: animationVisible ? "block" : "none"
    }, style),
    className: prefixCls + "-container"
  }, animationVisible && showHeader && images.length > 1 && !isZoomed && import_react111.default.createElement(import_react111.default.Fragment, null, import_react111.default.createElement(button_default, {
    disabled: activeIndex === 0,
    icon: import_react111.default.createElement(icon_default, {
      icon: "zi-chevron-left"
    }),
    className: prefixCls + "-nav-btn " + prefixCls + "-nav-btn-prev",
    size: "small",
    onClick: goToPrevImage
  }), import_react111.default.createElement(button_default, {
    disabled: activeIndex === images.length - 1,
    icon: import_react111.default.createElement(icon_default, {
      icon: "zi-chevron-right"
    }),
    className: prefixCls + "-nav-btn " + prefixCls + "-nav-btn-next",
    size: "small",
    onClick: goToNextImage
  })), animationVisible && transitions(function(transition, i) {
    return import_react111.default.createElement(animated.div, _extends({
      className: prefixCls + "-images",
      style: _objectSpread29({
        width: "100%",
        height: "100%"
      }, transition)
    }, bind()), images[i] && import_react111.default.createElement(Image_default, {
      src: images[i].src,
      alt: images[i].alt
    }));
  }))));
});
var image_viewer_default = ImageViewer;

// node_modules/zmp-ui/esm/components/stack/index.js
var import_react113 = __toESM(require_react());
var _excluded37 = ["id", "children", "className", "style", "space", "recursive", "splitAfter"];
function ownKeys30(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread30(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys30(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys30(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Stack = import_react113.default.forwardRef(function(props, ref) {
  var id = props.id, children2 = props.children, className = props.className, style = props.style, _props$space = props.space, space = _props$space === void 0 ? "var(--s1)" : _props$space, _props$recursive = props.recursive, recursive = _props$recursive === void 0 ? false : _props$recursive, splitAfter = props.splitAfter, rest = _objectWithoutPropertiesLoose(props, _excluded37);
  var prefixCls = getPrefixCls("stack");
  var classes = clsx_m_default(prefixCls, className);
  var stackStyle = _objectSpread30({}, style || {});
  var elementRef = (0, import_react113.useRef)(null);
  (0, import_react113.useImperativeHandle)(ref, function() {
    return {
      layout: elementRef.current
    };
  });
  (0, import_react113.useEffect)(function() {
    var render = function render2() {
      if (elementRef.current) {
        var i = "Stack-" + [space, recursive, splitAfter].join("");
        elementRef.current.dataset.i = i;
        if (!document.getElementById(i)) {
          var styleEl = document.createElement("style");
          styleEl.id = i;
          styleEl.innerHTML = ('\n              [data-i="' + i + '"]' + (recursive ? "" : " >") + " * + * {\n                margin-block-start: " + space + ";\n              }\n    \n              " + (splitAfter ? '\n                [data-i="' + i + '"]:only-child {\n                  block-size: 100%;\n                }\n    \n                [data-i="' + i + '"] > :nth-child(' + splitAfter + ") {\n                  margin-block-end: auto;\n                }" : "") + "\n            ").replace(/\s\s+/g, " ").trim();
          document.head.appendChild(styleEl);
        }
      }
    };
    render();
  }, [space, recursive, splitAfter]);
  return import_react113.default.createElement("div", _extends({}, rest, {
    ref: elementRef,
    id,
    style: stackStyle,
    className: classes
  }), children2);
});
var stack_default = Stack;

// node_modules/zmp-ui/esm/components/zbox/index.js
var import_react114 = __toESM(require_react());
var _excluded38 = ["id", "children", "className", "style", "padding", "borderWidth", "invert"];
function ownKeys31(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread31(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys31(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys31(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var ZBox = import_react114.default.forwardRef(function(props, ref) {
  var id = props.id, children2 = props.children, className = props.className, style = props.style, _props$padding = props.padding, padding = _props$padding === void 0 ? "var(--s1)" : _props$padding, _props$borderWidth = props.borderWidth, borderWidth = _props$borderWidth === void 0 ? "var(--border-thin)" : _props$borderWidth, _props$invert = props.invert, invert = _props$invert === void 0 ? false : _props$invert, rest = _objectWithoutPropertiesLoose(props, _excluded38);
  var prefixCls = getPrefixCls("zbox");
  var classes = clsx_m_default(prefixCls, className);
  var zBoxStyle = _objectSpread31({}, style || {});
  var elementRef = (0, import_react114.useRef)(null);
  (0, import_react114.useImperativeHandle)(ref, function() {
    return {
      layout: elementRef.current
    };
  });
  (0, import_react114.useEffect)(function() {
    var render = function render2() {
      if (elementRef.current) {
        var i = "ZBox-" + [padding, borderWidth, invert].join("");
        elementRef.current.dataset.i = i;
        if (!document.getElementById(i)) {
          var styleEl = document.createElement("style");
          styleEl.id = i;
          styleEl.innerHTML = ('\n                    [data-i="' + i + '"] {\n                        padding: ' + padding + ";\n                        border: " + borderWidth + " solid;\n                        " + (invert ? "background-color: var(--color-light);\n                          filter: invert(100%);" : "") + '\n                      }\n                  \n                      [data-i="' + i + '"] {\n                        background-color: inherit;\n                      }').replace(/\s\s+/g, " ").trim();
          document.head.appendChild(styleEl);
        }
      }
    };
    render();
  }, [padding, borderWidth, invert]);
  return import_react114.default.createElement("div", _extends({}, rest, {
    ref: elementRef,
    id,
    style: zBoxStyle,
    className: classes
  }), children2);
});
var zbox_default = ZBox;

// node_modules/zmp-ui/esm/components/center/index.js
var import_react115 = __toESM(require_react());
var _excluded39 = ["id", "children", "className", "style", "max", "andText", "gutters", "intrinsic"];
function ownKeys32(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread32(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys32(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys32(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Center = import_react115.default.forwardRef(function(props, ref) {
  var id = props.id, children2 = props.children, className = props.className, style = props.style, _props$max = props.max, max = _props$max === void 0 ? "var(--measure)" : _props$max, _props$andText = props.andText, andText = _props$andText === void 0 ? false : _props$andText, gutters = props.gutters, _props$intrinsic = props.intrinsic, intrinsic = _props$intrinsic === void 0 ? false : _props$intrinsic, rest = _objectWithoutPropertiesLoose(props, _excluded39);
  var prefixCls = getPrefixCls("center");
  var classes = clsx_m_default(prefixCls, className);
  var centerStyle = _objectSpread32({}, style || {});
  var elementRef = (0, import_react115.useRef)(null);
  (0, import_react115.useImperativeHandle)(ref, function() {
    return {
      layout: elementRef.current
    };
  });
  (0, import_react115.useEffect)(function() {
    var render = function render2() {
      if (elementRef.current) {
        var i = "Center-" + [max, andText, gutters, intrinsic].join("");
        elementRef.current.dataset.i = i;
        if (!document.getElementById(i)) {
          var styleEl = document.createElement("style");
          styleEl.id = i;
          styleEl.innerHTML = ('\n                    [data-i="' + i + '"] {\n                        max-width: ' + max + ";\n                        " + (gutters ? "\n                        padding-inline-start: " + gutters + ";\n                        padding-inline-end: " + gutters + ";" : "") + "\n                        " + (andText ? "text-align: center;" : "") + "\n                        " + (intrinsic ? "\n                        display: flex;\n                        flex-direction: column;\n                        align-items: center;" : "") + "\n                      }").replace(/\s\s+/g, " ").trim();
          document.head.appendChild(styleEl);
        }
      }
    };
    render();
  }, [max, andText, gutters, intrinsic]);
  return import_react115.default.createElement("div", _extends({}, rest, {
    ref: elementRef,
    id,
    style: centerStyle,
    className: classes
  }), children2);
});
var center_default = Center;

// node_modules/zmp-ui/esm/components/cluster/index.js
var import_react116 = __toESM(require_react());
var _excluded40 = ["id", "children", "className", "style", "justify", "align", "space"];
function ownKeys33(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread33(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys33(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys33(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Cluster = import_react116.default.forwardRef(function(props, ref) {
  var id = props.id, children2 = props.children, className = props.className, style = props.style, _props$justify = props.justify, justify = _props$justify === void 0 ? "flex-start" : _props$justify, _props$align = props.align, align = _props$align === void 0 ? "flex-start" : _props$align, _props$space = props.space, space = _props$space === void 0 ? "var(--s1)" : _props$space, rest = _objectWithoutPropertiesLoose(props, _excluded40);
  var prefixCls = getPrefixCls("cluster");
  var classes = clsx_m_default(prefixCls, className);
  var centerStyle = _objectSpread33({}, style || {});
  var elementRef = (0, import_react116.useRef)(null);
  (0, import_react116.useImperativeHandle)(ref, function() {
    return {
      layout: elementRef.current
    };
  });
  (0, import_react116.useEffect)(function() {
    var render = function render2() {
      if (elementRef.current) {
        var i = "Cluster-" + [justify, align, space].join("");
        elementRef.current.dataset.i = i;
        if (!document.getElementById(i)) {
          var styleEl = document.createElement("style");
          styleEl.id = i;
          styleEl.innerHTML = ('\n                    [data-i="' + i + '"] {\n                        justify-content: ' + justify + ";\n                        align-items: " + align + ";\n                        gap: " + space + ";\n                      }").replace(/\s\s+/g, " ").trim();
          document.head.appendChild(styleEl);
        }
      }
    };
    render();
  }, [justify, align, space]);
  return import_react116.default.createElement("div", _extends({}, rest, {
    ref: elementRef,
    id,
    style: centerStyle,
    className: classes
  }), children2);
});
var cluster_default = Cluster;

// node_modules/zmp-ui/esm/components/grid/index.js
var import_react117 = __toESM(require_react());
var _excluded41 = ["id", "children", "className", "style", "min", "columnCount", "rowSpace", "columnSpace"];
function ownKeys34(e, r2) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r2 && (o = o.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e, r3).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread34(e) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys34(Object(t), true).forEach(function(r3) {
      _defineProperty(e, r3, t[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys34(Object(t)).forEach(function(r3) {
      Object.defineProperty(e, r3, Object.getOwnPropertyDescriptor(t, r3));
    });
  }
  return e;
}
var Grid = import_react117.default.forwardRef(function(props, ref) {
  var id = props.id, children2 = props.children, className = props.className, style = props.style, _props$min = props.min, min = _props$min === void 0 ? "100%" : _props$min, columnCount = props.columnCount, _props$rowSpace = props.rowSpace, rowSpace = _props$rowSpace === void 0 ? "var(--s1)" : _props$rowSpace, _props$columnSpace = props.columnSpace, columnSpace = _props$columnSpace === void 0 ? "var(--s1)" : _props$columnSpace, rest = _objectWithoutPropertiesLoose(props, _excluded41);
  var prefixCls = getPrefixCls("grid");
  var classes = clsx_m_default(prefixCls, className);
  var centerStyle = _objectSpread34({}, style || {});
  var elementRef = (0, import_react117.useRef)(null);
  (0, import_react117.useImperativeHandle)(ref, function() {
    return {
      layout: elementRef.current
    };
  });
  (0, import_react117.useEffect)(function() {
    var render = function render2() {
      if (elementRef.current) {
        var i = "Grid-" + [columnCount, min, rowSpace, columnSpace].join("");
        elementRef.current.dataset.i = i;
        if (!document.getElementById(i)) {
          var styleEl = document.createElement("style");
          styleEl.id = i;
          styleEl.innerHTML = ('\n                    [data-i="' + i + '"] {\n                        ' + (rowSpace && "row-gap: " + rowSpace + ";") + "\n                        " + (columnSpace && "column-gap: " + columnSpace + ";") + "\n                        " + (columnCount && columnCount > 0 && "grid-template-columns: repeat(" + columnCount + ", 1fr)") + "\n                      }\n\n                      " + (typeof columnCount === "undefined" && "@supports (width: min(" + min + ', 100%)) {\n                            [data-i="' + i + '"] {\n                              grid-template-columns: repeat(auto-fill, minmax(min(' + min + ", 100%), 1fr));\n                            }\n                          }") + "\n            \n                      ").replace(/\s\s+/g, " ").trim();
          document.head.appendChild(styleEl);
        }
      }
    };
    render();
  }, [columnCount, min, rowSpace, columnSpace]);
  return import_react117.default.createElement("div", _extends({}, rest, {
    ref: elementRef,
    id,
    style: centerStyle,
    className: classes
  }), children2);
});
var grid_default = Grid;

// node_modules/zmp-ui/esm/components/calendar/Calendar.js
var import_react122 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/calendar/props-type.js
var CellType = function(CellType2) {
  CellType2["IN_VIEW"] = "in-view";
  CellType2["OUT_OF_VIEW"] = "out-of-view";
  return CellType2;
}({});

// node_modules/zmp-ui/esm/components/calendar/CalendarHeader.js
var import_react119 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/calendar/context.js
var import_react118 = __toESM(require_react());
var CalendarContext = (0, import_react118.createContext)({
  date: /* @__PURE__ */ new Date(),
  selectedDate: /* @__PURE__ */ new Date(),
  mode: "date",
  locale: "vi-VN"
});

// node_modules/zmp-ui/esm/components/calendar/CalendarHeader.js
var CalendarHeaderTitle = function CalendarHeaderTitle2(props) {
  var children2 = props.children, onClick = props.onClick;
  var prefixCls = getPrefixCls("calendar-header-title");
  return import_react119.default.createElement("span", {
    className: prefixCls,
    onClick,
    role: "presentation"
  }, children2);
};
var CalendarHeader = function CalendarHeader2(props) {
  var context = (0, import_react119.useContext)(CalendarContext);
  var rootClassName = props.rootClassName, onNext = props.onNext, onPrev = props.onPrev, onTypeChange = props.onTypeChange, currentValue = props.value;
  var locale = context == null ? void 0 : context.locale;
  var mode = context == null ? void 0 : context.mode;
  var prefixCls = getPrefixCls("calendar-header");
  var classes = clsx_m_default(prefixCls, rootClassName);
  var handleTypeChange = (0, import_react119.useCallback)(function(type) {
    onTypeChange(type);
  }, [onTypeChange]);
  var renderDateViewModeTitle = import_react119.default.useMemo(function() {
    var dateString = currentValue.toLocaleString(locale, {
      month: "long",
      year: "numeric"
    });
    var monthString = currentValue.toLocaleString(locale, {
      month: "long"
    });
    var yearString = currentValue.toLocaleString(locale, {
      year: "numeric"
    });
    var monthPosition = dateString.indexOf(monthString.toLocaleLowerCase());
    if (monthPosition === 0) {
      return import_react119.default.createElement(import_react119.default.Fragment, null, import_react119.default.createElement(CalendarHeaderTitle, {
        onClick: function onClick() {
          return handleTypeChange("month");
        }
      }, monthString), " ", import_react119.default.createElement(CalendarHeaderTitle, {
        onClick: function onClick() {
          return handleTypeChange("year");
        }
      }, yearString));
    }
    return import_react119.default.createElement(import_react119.default.Fragment, null, import_react119.default.createElement(CalendarHeaderTitle, {
      onClick: function onClick() {
        return handleTypeChange("year");
      }
    }, yearString), " ", import_react119.default.createElement(CalendarHeaderTitle, {
      onClick: function onClick() {
        return handleTypeChange("month");
      }
    }, monthString));
  }, [currentValue, handleTypeChange, locale]);
  var renderMonthViewModeTitle = import_react119.default.useMemo(function() {
    var yearString = currentValue.toLocaleString(locale, {
      year: "numeric"
    });
    return import_react119.default.createElement(CalendarHeaderTitle, {
      onClick: function onClick() {
        return handleTypeChange("year");
      }
    }, yearString);
  }, [currentValue, handleTypeChange, locale]);
  var renderYearViewModeTitle = import_react119.default.useMemo(function() {
    var currentYear = currentValue.getFullYear();
    var decadeStartYear = Math.floor(currentYear / 10) * 10;
    var decadeEndYear = decadeStartYear + 9;
    var decadeString = decadeStartYear + " - " + decadeEndYear;
    return import_react119.default.createElement(CalendarHeaderTitle, {
      onClick: function onClick() {
        return handleTypeChange("decade");
      }
    }, decadeString);
  }, [currentValue, handleTypeChange]);
  var renderDecadeViewModeTitle = import_react119.default.useMemo(function() {
    var currentYear = currentValue.getFullYear();
    var centuryStartYear = Math.floor(currentYear / 100) * 100;
    var centuryEndYear = centuryStartYear + 99;
    var centuryString = centuryStartYear + " - " + centuryEndYear;
    return import_react119.default.createElement(CalendarHeaderTitle, {
      onClick: function onClick() {
        return null;
      }
    }, centuryString);
  }, [currentValue]);
  var formattedTitle = import_react119.default.useMemo(function() {
    switch (mode) {
      case "date":
        return renderDateViewModeTitle;
      case "month":
        return renderMonthViewModeTitle;
      case "year":
        return renderYearViewModeTitle;
      case "decade":
        return renderDecadeViewModeTitle;
      default:
        return renderDateViewModeTitle;
    }
  }, [mode, renderDateViewModeTitle, renderMonthViewModeTitle, renderYearViewModeTitle, renderDecadeViewModeTitle]);
  return import_react119.default.createElement("div", {
    className: classes
  }, import_react119.default.createElement(button_default, {
    className: prefixCls + "-btn-prev",
    icon: import_react119.default.createElement(icon_default, {
      icon: "zi-arrow-left"
    }),
    variant: "tertiary",
    onClick: onPrev
  }), import_react119.default.createElement("div", {
    className: prefixCls + "-title"
  }, formattedTitle), import_react119.default.createElement(button_default, {
    className: prefixCls + "-btn-next",
    icon: import_react119.default.createElement(icon_default, {
      icon: "zi-arrow-right"
    }),
    variant: "tertiary",
    onClick: onNext
  }));
};
var CalendarHeader_default = CalendarHeader;

// node_modules/zmp-ui/esm/components/calendar/CalendarPanel.js
var import_react121 = __toESM(require_react());

// node_modules/zmp-ui/esm/components/calendar/CalendarCell.js
var import_react120 = __toESM(require_react());
var CalendarCell = function CalendarCell2(props) {
  var label = props.label, content = props.content;
  var prefixCls = getPrefixCls("calendar-cell-inner");
  var classes = clsx_m_default(prefixCls);
  return import_react120.default.createElement("div", {
    className: classes
  }, import_react120.default.createElement("div", {
    className: prefixCls + "-label"
  }, label), import_react120.default.createElement("div", {
    className: prefixCls + "-content"
  }, content));
};
var CalendarCell_default = CalendarCell;

// node_modules/zmp-ui/esm/components/calendar/CalendarPanel.js
var CalendarPanel = import_react121.default.forwardRef(function(props, ref) {
  var header = props.header, body = props.body, onCellClick = props.onCellClick, numberOfLine = props.numberOfLine;
  var _useContext = (0, import_react121.useContext)(CalendarContext), cellRender = _useContext.cellRender, fullCellRender = _useContext.fullCellRender, mode = _useContext.mode, selectedDate = _useContext.selectedDate;
  var prefixCls = getPrefixCls("calendar-panel");
  var classes = clsx_m_default(prefixCls, [prefixCls + "-" + mode]);
  var compareDate = function compareDate2(date1, date2) {
    return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate();
  };
  return import_react121.default.createElement("div", {
    className: classes,
    ref
  }, import_react121.default.createElement("div", {
    className: prefixCls + "-body"
  }, import_react121.default.createElement("table", {
    className: prefixCls + "-content"
  }, header.length > 0 && import_react121.default.createElement("thead", null, import_react121.default.createElement("tr", null, header.map(function(item, index2) {
    return import_react121.default.createElement("th", {
      key: index2
    }, item);
  }))), import_react121.default.createElement("tbody", null, import_react121.default.createElement(TransitionGroup_default, {
    component: null
  }, body.map(function(item, index2) {
    var key = String(index2);
    if (numberOfLine && index2 >= numberOfLine) return null;
    return import_react121.default.createElement(CSSTransition_default, {
      key,
      timeout: 400,
      classNames: "item"
    }, import_react121.default.createElement("tr", null, item.map(function(cell) {
      var _classNames;
      var cellContent = cell.content;
      if (typeof cellRender === "function") {
        var cellInfo = {
          originNode: cell.content,
          today: /* @__PURE__ */ new Date(),
          type: mode
        };
        cellContent = cellRender(cell.value, cellInfo);
      }
      var fullCellContent = import_react121.default.createElement(CalendarCell_default, {
        label: cell.label,
        content: cellContent
      });
      if (typeof fullCellRender === "function") {
        var _cellInfo = {
          originNode: fullCellContent,
          today: /* @__PURE__ */ new Date(),
          type: mode
        };
        fullCellContent = fullCellRender(cell.value, _cellInfo);
      }
      return import_react121.default.createElement("td", {
        key: cell.label,
        className: clsx_m_default(prefixCls + "-cell", (_classNames = {}, _classNames[prefixCls + "-cell-in-view"] = cell.type === CellType.IN_VIEW, _classNames[prefixCls + "-cell-selected"] = compareDate(cell.value, selectedDate), _classNames[prefixCls + "-cell-today"] = compareDate(cell.value, /* @__PURE__ */ new Date()), _classNames[prefixCls + "-cell-disabled"] = cell.disabled, _classNames)),
        onClick: function onClick() {
          var currentDate = /* @__PURE__ */ new Date();
          if (!cell.disabled) {
            var selectedValue = new Date(cell.value.setHours(currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), currentDate.getMilliseconds()));
            onCellClick == null || onCellClick(selectedValue, cell.type);
          }
        },
        role: "presentation"
      }, fullCellContent);
    })));
  }))))));
});
var CalendarPanel_default = CalendarPanel;

// node_modules/zmp-ui/esm/components/calendar/Calendar.js
var Calendar = import_react122.default.forwardRef(function(props, ref) {
  var _classNames;
  var rootClassName = props.rootClassName, className = props.className, defaultValue = props.defaultValue, _props$locale = props.locale, locale = _props$locale === void 0 ? "vi-VN" : _props$locale, _props$startOfWeek = props.startOfWeek, startOfWeek = _props$startOfWeek === void 0 ? 0 : _props$startOfWeek, _props$numberOfWeek = props.numberOfWeek, numberOfWeek = _props$numberOfWeek === void 0 ? "auto" : _props$numberOfWeek, _props$dayOfWeekNameF = props.dayOfWeekNameFormat, dayOfWeekNameFormat = _props$dayOfWeekNameF === void 0 ? "short" : _props$dayOfWeekNameF, dayOfWeekNameRender = props.dayOfWeekNameRender, disabledDate = props.disabledDate, cellRender = props.cellRender, fullCellRender = props.fullCellRender, onSelect = props.onSelect, onPanelChange = props.onPanelChange, headerRender = props.headerRender;
  var dayFormatter3 = (0, import_react122.useMemo)(function() {
    return new Intl.DateTimeFormat(locale, {
      weekday: dayOfWeekNameFormat
    });
  }, [locale, dayOfWeekNameFormat]);
  var _useState = (0, import_react122.useState)("date"), calendarMode = _useState[0], setCalendarMode = _useState[1];
  var swiperRef = (0, import_react122.useRef)(null);
  var _useMergedState = useMergedState(defaultValue, {
    value: props.value
  }), value = _useMergedState[0];
  var _React$useState = import_react122.default.useState(value != null ? value : /* @__PURE__ */ new Date()), currentValue = _React$useState[0], setCurrentValue = _React$useState[1];
  var _React$useState2 = import_react122.default.useState(value != null ? value : /* @__PURE__ */ new Date()), selectedValue = _React$useState2[0], setSelectedValue = _React$useState2[1];
  var prefixCls = getPrefixCls("calendar");
  var classes = clsx_m_default(prefixCls, rootClassName, className, (_classNames = {}, _classNames[prefixCls + "-full"] = props.fullscreen, _classNames));
  var calendarRef = (0, import_react122.useRef)(null);
  (0, import_react122.useImperativeHandle)(ref, function() {
    return {
      calendar: calendarRef.current
    };
  });
  var checkCellType = function checkCellType2(condition) {
    if (condition) {
      return CellType.IN_VIEW;
    }
    return CellType.OUT_OF_VIEW;
  };
  var dayOfWeekArray = (0, import_react122.useMemo)(function() {
    return getDayOfWeekArray(startOfWeek);
  }, [startOfWeek]);
  var contextValue = (0, import_react122.useMemo)(function() {
    return {
      date: currentValue,
      selectedDate: selectedValue,
      mode: calendarMode,
      locale,
      cellRender,
      fullCellRender
    };
  }, [selectedValue, currentValue, calendarMode, locale, cellRender, fullCellRender]);
  var handleOnTypeChange = function handleOnTypeChange2(type) {
    setCalendarMode(type);
  };
  var generatePanelData = (0, import_react122.useCallback)(function(date) {
    if (date === void 0) {
      date = /* @__PURE__ */ new Date();
    }
    var header = [];
    var data = [];
    var year = date.getFullYear();
    var month = date.getMonth() + 1;
    var day = numberOfWeek === "auto" ? 1 : date.getDate();
    var weeksInMonth = numberOfWeek === "auto" ? getWeeksInMonth(year, month, startOfWeek) : numberOfWeek;
    if (calendarMode === "date") {
      var startDate = new Date(year, month - 1, day);
      var dayOfStartDate = startDate.getDay();
      var aDate = new Date(startDate.setDate(startDate.getDate() - dayOfWeekArray.indexOf(dayOfStartDate)));
      for (var i = 0; i < weeksInMonth; i++) {
        data[Number(i)] = [];
        for (var j = 0; j < 7; j++) {
          if (i === 0) {
            header[Number(j)] = typeof dayOfWeekNameRender === "function" ? dayOfWeekNameRender(aDate.getDay()) : dayFormatter3.format(aDate);
          }
          data[Number(i)][Number(j)] = {
            label: aDate.getDate().toString(),
            value: new Date(aDate),
            type: checkCellType(aDate.getMonth() === month - 1 || numberOfWeek !== "auto"),
            disabled: !!disabledDate && disabledDate(aDate)
          };
          aDate.setDate(aDate.getDate() + 1);
        }
      }
    } else if (calendarMode === "month") {
      data[0] = [];
      for (var _i = 0; _i < 12; _i++) {
        data[0][Number(_i)] = {
          label: monthFormatter(locale).format(new Date(year, _i)),
          value: new Date(year, _i, 1),
          type: CellType.IN_VIEW,
          disabled: false
        };
      }
    } else if (calendarMode === "year") {
      var decadeStartYear = Math.floor(year / 10) * 10;
      var decadeEndYear = decadeStartYear + 9;
      data[0] = [];
      for (var _i2 = 0; _i2 < 12; _i2++) {
        var aYear = decadeStartYear + _i2 - 1;
        data[0][Number(_i2)] = {
          label: String(aYear),
          value: new Date(aYear, 0, 1),
          type: checkCellType(aYear >= decadeStartYear && aYear <= decadeEndYear),
          disabled: false
        };
      }
    } else if (calendarMode === "decade") {
      var centuryStartYear = Math.floor(year / 100) * 100;
      var centuryEndYear = centuryStartYear + 99;
      data[0] = [];
      for (var _i3 = 0; _i3 < 12; _i3++) {
        var _aYear = centuryStartYear + _i3 * 10 - 10;
        data[0][Number(_i3)] = {
          label: _aYear + "-" + (_aYear + 9),
          value: new Date(_aYear, 0, 1),
          type: checkCellType(_aYear >= centuryStartYear && _aYear <= centuryEndYear),
          disabled: false
        };
      }
    } else {
      throw new Error("Invalid calendar mode: " + calendarMode);
    }
    return {
      header,
      body: data
    };
  }, [disabledDate, dayFormatter3, calendarMode, dayOfWeekArray, dayOfWeekNameRender, numberOfWeek, startOfWeek, locale]);
  var getPrevValue = import_react122.default.useCallback(function(aValue) {
    var newDate = new Date(aValue);
    var monthDecrement;
    var dayDecrement;
    var yearDecrement;
    switch (calendarMode) {
      case "date":
        var _ref = numberOfWeek === "auto" ? [1, 0] : [0, 7 * numberOfWeek];
        monthDecrement = _ref[0];
        dayDecrement = _ref[1];
        newDate.setMonth(newDate.getMonth() - monthDecrement);
        newDate.setDate(newDate.getDate() - dayDecrement);
        break;
      case "month":
      case "year":
      case "decade":
        yearDecrement = calendarMode === "month" ? 1 : calendarMode === "year" ? 10 : 100;
        newDate.setFullYear(newDate.getFullYear() - yearDecrement);
        newDate.setMonth(0);
        newDate.setDate(1);
        break;
      default:
        break;
    }
    return newDate;
  }, [calendarMode, numberOfWeek]);
  var getNextValue = import_react122.default.useCallback(function(aValue) {
    var newDate = new Date(aValue);
    var monthIncrement;
    var dayIncrement;
    var yearIncrement;
    switch (calendarMode) {
      case "date":
        var _ref2 = numberOfWeek === "auto" ? [1, 0] : [0, 7 * numberOfWeek];
        monthIncrement = _ref2[0];
        dayIncrement = _ref2[1];
        newDate.setMonth(newDate.getMonth() + monthIncrement);
        newDate.setDate(newDate.getDate() + dayIncrement);
        break;
      case "month":
      case "year":
      case "decade":
        yearIncrement = calendarMode === "month" ? 1 : calendarMode === "year" ? 10 : 100;
        newDate.setFullYear(newDate.getFullYear() + yearIncrement);
        newDate.setMonth(0);
        newDate.setDate(1);
        break;
      default:
        break;
    }
    return newDate;
  }, [calendarMode, numberOfWeek]);
  var _React$useState3 = import_react122.default.useState([getPrevValue(currentValue), currentValue, getNextValue(currentValue)]), panelArray = _React$useState3[0], setPanelArray = _React$useState3[1];
  var _React$useState4 = import_react122.default.useState(1), currentIndex = _React$useState4[0], setCurrentIndex = _React$useState4[1];
  var handleCellClick = import_react122.default.useCallback(function(data, _type, currentPanelIndex) {
    var nextPanelMode = calendarMode === "date" ? "date" : calendarMode === "month" ? "date" : calendarMode === "year" ? "month" : "year";
    setPanelArray(function(prev) {
      var newPanelArray = [].concat(prev);
      newPanelArray[Number(currentPanelIndex)] = data;
      return newPanelArray;
    });
    setCurrentValue(data);
    setCalendarMode(nextPanelMode);
    setSelectedValue(data);
    onSelect == null || onSelect(data, {
      source: calendarMode
    });
  }, [calendarMode, onSelect]);
  var handleSwiperChange = import_react122.default.useCallback(function(nextIndex) {
    if (currentIndex === 1 && nextIndex === 0 || currentIndex === 2 && nextIndex === 1 || currentIndex === 0 && nextIndex === 2) {
      panelArray[Number(nextIndex)] = getPrevValue(panelArray[Number(currentIndex)]);
      panelArray[Number(nextIndex + 2) % 3] = getPrevValue(panelArray[Number(nextIndex)]);
      setPanelArray(panelArray);
      setCurrentIndex(nextIndex);
    } else if (currentIndex === 0 && nextIndex === 1 || currentIndex === 1 && nextIndex === 2 || currentIndex === 2 && nextIndex === 0) {
      panelArray[Number(nextIndex)] = getNextValue(panelArray[Number(currentIndex)]);
      panelArray[Number(nextIndex + 1) % 3] = getNextValue(panelArray[Number(nextIndex)]);
      setPanelArray(panelArray);
      setCurrentIndex(nextIndex);
    }
    setCurrentValue(panelArray[nextIndex]);
    onPanelChange == null || onPanelChange(panelArray[nextIndex], calendarMode);
  }, [calendarMode, currentIndex, getNextValue, getPrevValue, onPanelChange, panelArray]);
  var calendarHeader = (0, import_react122.useMemo)(function() {
    var originNode = import_react122.default.createElement(CalendarHeader_default, {
      value: currentValue,
      onPrev: function onPrev() {
        var _swiperRef$current;
        (_swiperRef$current = swiperRef.current) == null || _swiperRef$current.prev();
      },
      onNext: function onNext() {
        var _swiperRef$current2;
        (_swiperRef$current2 = swiperRef.current) == null || _swiperRef$current2.next();
      },
      onTypeChange: function onTypeChange(type) {
        return handleOnTypeChange(type);
      },
      defaultMode: calendarMode
    });
    var header = originNode;
    if (headerRender) {
      header = headerRender(originNode, {
        value: currentValue,
        onPrev: function onPrev() {
          var _swiperRef$current3;
          (_swiperRef$current3 = swiperRef.current) == null || _swiperRef$current3.prev();
        },
        onNext: function onNext() {
          var _swiperRef$current4;
          (_swiperRef$current4 = swiperRef.current) == null || _swiperRef$current4.next();
        },
        onTypeChange: function onTypeChange(type) {
          return handleOnTypeChange(type);
        },
        defaultMode: calendarMode
      });
    }
    return header;
  }, [calendarMode, currentValue, headerRender]);
  (0, import_react122.useEffect)(function() {
    if (value && typeof value.getMonth === "function") {
      handleCellClick(value, CellType.IN_VIEW, currentIndex);
    }
  }, [value]);
  return import_react122.default.createElement(CalendarContext.Provider, {
    value: contextValue
  }, import_react122.default.createElement("div", {
    ref: calendarRef,
    className: clsx_m_default(classes, props.className),
    style: props.style
  }, calendarHeader, import_react122.default.createElement(swiper_default, {
    dots: false,
    ref: swiperRef,
    afterChange: function afterChange(index2) {
      handleSwiperChange(index2);
    },
    defaultActive: currentIndex,
    loop: true
  }, panelArray.map(function(item, index2) {
    var panelData = generatePanelData(item);
    var numberOfLine = numberOfWeek === "auto" ? getWeeksInMonth(panelArray[currentIndex].getFullYear(), panelArray[currentIndex].getMonth() + 1, startOfWeek) : void 0;
    return import_react122.default.createElement(swiper_default.Slide, {
      key: index2
    }, import_react122.default.createElement(CalendarPanel_default, {
      body: panelData.body,
      header: panelData.header,
      onCellClick: function onCellClick(data, type) {
        return handleCellClick(data, type, index2);
      },
      numberOfLine
    }));
  }))));
});
var Calendar_default = Calendar;

// node_modules/zmp-ui/esm/components/calendar/index.js
var Calendar2 = Calendar_default;
var calendar_default = Calendar2;

// node_modules/zmp-ui/esm/hooks/useSnackbar/index.js
var useSnackbar_default = useSnackbar;
export {
  AnimationRoutes_default as AnimationRoutes,
  app_default as App,
  avatar_default2 as Avatar,
  bottom_navigation_default as BottomNavigation,
  box_default as Box,
  button_default as Button,
  calendar_default as Calendar,
  center_default as Center,
  checkbox_default as Checkbox,
  cluster_default as Cluster,
  date_picker_default as DatePicker,
  grid_default as Grid,
  header_default as Header,
  icon_default as Icon,
  image_viewer_default as ImageViewer,
  input_default as Input,
  list_default2 as List,
  modal_default as Modal,
  page_default as Page,
  picker_default as Picker,
  progress_default as Progress,
  radio_default as Radio,
  Route,
  select_default as Select,
  sheet_default2 as Sheet,
  slider_default as Slider,
  snackbar_provider_default as SnackbarProvider,
  spinner_default as Spinner,
  stack_default as Stack,
  swiper_default as Swiper,
  switch_default as Switch,
  tabs_default as Tabs,
  text_default as Text,
  zbox_default as ZBox,
  router_default as ZMPRouter,
  useLocation,
  useNavigate_default as useNavigate,
  useParams,
  useRouteError,
  useSearchParams,
  useSnackbar_default as useSnackbar,
  useTheme
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=zmp-ui.js.map
